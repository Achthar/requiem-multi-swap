{
  "language": "Solidity",
  "sources": {
    "contracts/AssetHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\nimport \"./interfaces/IAsset.sol\";\n\nabstract contract AssetHelpers {\n    // solhint-disable-next-line var-name-mixedcase\n    IWETH private immutable _weth;\n\n    // Sentinel value used to indicate WETH with wrapping/unwrapping semantics. The zero address is a good choice for\n    // multiple reasons: it is cheap to pass as a calldata argument, it is a known invalid token and non-contract, and\n    // it is an address Pools cannot register as a token.\n    address private constant _ETH = address(0);\n\n    constructor(IWETH weth) {\n        _weth = weth;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _WETH() internal view returns (IWETH) {\n        return _weth;\n    }\n\n    /**\n     * @dev Returns true if `asset` is the sentinel value that represents ETH.\n     */\n    function _isETH(IAsset asset) internal pure returns (bool) {\n        return address(asset) == _ETH;\n    }\n\n    /**\n     * @dev Translates `asset` into an equivalent IERC20 token address. If `asset` represents ETH, it will be translated\n     * to the WETH contract.\n     */\n    function _translateToIERC20(IAsset asset) internal view returns (IERC20) {\n        return _isETH(asset) ? _WETH() : _asIERC20(asset);\n    }\n\n    /**\n     * @dev Same as `_translateToIERC20(IAsset)`, but for an entire array.\n     */\n    function _translateToIERC20(IAsset[] memory assets) internal view returns (IERC20[] memory) {\n        IERC20[] memory tokens = new IERC20[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            tokens[i] = _translateToIERC20(assets[i]);\n        }\n        return tokens;\n    }\n\n    /**\n     * @dev Interprets `asset` as an IERC20 token. This function should only be called on `asset` if `_isETH` previously\n     * returned false for it, that is, if `asset` is guaranteed not to be the ETH sentinel value.\n     */\n    function _asIERC20(IAsset asset) internal pure returns (IERC20) {\n        return IERC20(address(asset));\n    }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\n/**\n * @dev Interface for WETH9.\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\n */\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "contracts/AssetTransfersHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/Address.sol\";\nimport \"./interfaces/IWETH.sol\";\n\nimport \"./interfaces/IAsset.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./AssetHelpers.sol\";\n\nabstract contract AssetTransfersHandler is AssetHelpers {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /**\n     * @dev Receives `amount` of `asset` from `sender`. If `fromInternalBalance` is true, it first withdraws as much\n     * as possible from Internal Balance, then transfers any remaining amount.\n     *\n     * If `asset` is ETH, `fromInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\n     * will be wrapped into WETH.\n     *\n     * WARNING: this function does not check that the contract caller has actually supplied any ETH - it is up to the\n     * caller of this function to check that this is true to prevent the Vault from using its own ETH (though the Vault\n     * typically doesn't hold any).\n     */\n    function _receiveAsset(\n        IAsset asset,\n        uint256 amount,\n        address sender,\n        bool fromInternalBalance\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (_isETH(asset)) {\n            _require(!fromInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\n\n            // The ETH amount to receive is deposited into the WETH contract, which will in turn mint WETH for\n            // the Vault at a 1:1 ratio.\n\n            // A check for this condition is also introduced by the compiler, but this one provides a revert reason.\n            // Note we're checking for the Vault's total balance, *not* ETH sent in this transaction.\n            _require(address(this).balance >= amount, Errors.INSUFFICIENT_ETH);\n            _WETH().deposit{ value: amount }();\n        } else {\n            IERC20 token = _asIERC20(asset);\n\n            if (fromInternalBalance) {\n                // We take as many tokens from Internal Balance as possible: any remaining amounts will be transferred.\n                uint256 deductedBalance = _decreaseInternalBalance(sender, token, amount, true);\n                // Because `deductedBalance` will be always the lesser of the current internal balance\n                // and the amount to decrease, it is safe to perform unchecked arithmetic.\n                amount -= deductedBalance;\n            }\n\n            if (amount > 0) {\n                token.safeTransferFrom(sender, address(this), amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Sends `amount` of `asset` to `recipient`. If `toInternalBalance` is true, the asset is deposited as Internal\n     * Balance instead of being transferred.\n     *\n     * If `asset` is ETH, `toInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\n     * are instead sent directly after unwrapping WETH.\n     */\n    function _sendAsset(\n        IAsset asset,\n        uint256 amount,\n        address payable recipient,\n        bool toInternalBalance\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (_isETH(asset)) {\n            // Sending ETH is not as involved as receiving it: the only special behavior is it cannot be\n            // deposited to Internal Balance.\n            _require(!toInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\n\n            // First, the Vault withdraws deposited ETH from the WETH contract, by burning the same amount of WETH\n            // from the Vault. This receipt will be handled by the Vault's `receive`.\n            _WETH().withdraw(amount);\n\n            // Then, the withdrawn ETH is sent to the recipient.\n            recipient.sendValue(amount);\n        } else {\n            IERC20 token = _asIERC20(asset);\n            if (toInternalBalance) {\n                _increaseInternalBalance(recipient, token, amount);\n            } else {\n                token.safeTransfer(recipient, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns excess ETH back to the contract caller, assuming `amountUsed` has been spent. Reverts\n     * if the caller sent less ETH than `amountUsed`.\n     *\n     * Because the caller might not know exactly how much ETH a Vault action will require, they may send extra.\n     * Note that this excess value is returned *to the contract caller* (msg.sender). If caller and e.g. swap sender are\n     * not the same (because the caller is a relayer for the sender), then it is up to the caller to manage this\n     * returned ETH.\n     */\n    function _handleRemainingEth(uint256 amountUsed) internal {\n        _require(msg.value >= amountUsed, Errors.INSUFFICIENT_ETH);\n\n        uint256 excess = msg.value - amountUsed;\n        if (excess > 0) {\n            payable(msg.sender).transfer(excess);\n        }\n    }\n\n    /**\n     * @dev Enables the Vault to receive ETH. This is required for it to be able to unwrap WETH, which sends ETH to the\n     * caller.\n     *\n     * Any ETH sent to the Vault outside of the WETH unwrapping mechanism would be forever locked inside the Vault, so\n     * we prevent that from happening. Other mechanisms used to send ETH to the Vault (such as being the recipient of an\n     * ETH swap, Pool exit or withdrawal, contract self-destruction, or receiving the block mining reward) will result\n     * in locked funds, but are not otherwise a security or soundness issue. This check only exists as an attempt to\n     * prevent user error.\n     */\n    receive() external payable {\n        _require(msg.sender == address(_WETH()), Errors.ETH_TRANSFER);\n    }\n\n    // This contract uses virtual internal functions instead of inheriting from the modules that implement them (in\n    // this case UserBalance) in order to decouple it from the rest of the system and enable standalone testing by\n    // implementing these with mocks.\n\n    function _increaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) internal virtual;\n\n    function _decreaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount,\n        bool capped\n    ) internal virtual returns (uint256);\n}\n"
    },
    "contracts/libraries/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\n * Adapted from OpenZeppelin's SafeMath library\n */\nlibrary Math {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_OVERFLOW\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SUB_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n        return c;\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        return roundUp ? divUp(a, b) : divDown(a, b);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n        return a / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            return 1 + (a - 1) / b;\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/RequiemErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAL#\" part is a known constant\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20/IERC20.sol\";\nimport \"./ISignaturesValidatorVault.sol\";\nimport \"./ITemporarilyPausableVault.sol\";\nimport \"./IWETH.sol\";\n\nimport \"./IAsset.sol\";\nimport \"./IAuthorizer.sol\";\nimport \"./IFlashLoanRecipient.sol\";\nimport \"./IProtocolFeesCollector.sol\";\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault is ISignaturesValidatorVault, ITemporarilyPausableVault {\n    // Generalities about the Vault:\n    //\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\n    //\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\n    //\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\n\n    // Authorizer\n    //\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\n    // can perform a given action.\n\n    /**\n     * @dev Returns the Vault's Authorizer.\n     */\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    /**\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\n     *\n     * Emits an `AuthorizerChanged` event.\n     */\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\n\n    /**\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\n     */\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\n\n    // Relayers\n    //\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n    // this power, two things must occur:\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n    //    functions.\n    //  - Each user must approve the relayer to act on their behalf.\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n    /**\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n    /**\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    /**\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\n     */\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user's Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n    /**\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n\n    /**\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n    /**\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n    /**\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    // Flash Loans\n\n    /**\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\n     *\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\n     * for each token contract. `tokens` must be sorted in ascending order.\n     *\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\n     * `receiveFlashLoan` call.\n     *\n     * Emits `FlashLoan` events.\n     */\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n\n    /**\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\n     */\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\n\n    // Asset Management\n    //\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\n    //\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\n    //\n    // This concept is unrelated to the IAsset interface.\n\n    /**\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\n     *\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\n     * operations of different kinds, with different Pools and tokens, at once.\n     *\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\n     */\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    /**\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\n     *\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\n     *\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\n     */\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n\n    /**\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\n     */\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n    // Protocol Fees\n    //\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\n    // permissioned accounts.\n    //\n    // There are two kinds of protocol fees:\n    //\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\n    //\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\n    // exiting a Pool in debt without first paying their share.\n\n    /**\n     * @dev Returns the current protocol fee module.\n     */\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\n\n    /**\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\n     * error in some part of the system.\n     *\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\n     *\n     * While the contract is paused, the following features are disabled:\n     * - depositing and transferring internal balance\n     * - transferring external balance (using the Vault's allowance)\n     * - swaps\n     * - joining Pools\n     * - Asset Manager interactions\n     *\n     * Internal Balance can still be withdrawn, and Pools exited.\n     */\n    function setPaused(bool paused) external;\n\n    /**\n     * @dev Returns the Vault's WETH instance.\n     */\n    function WETH() external view returns (IWETH);\n    // solhint-disable-previous-line func-name-mixedcase\n}\n"
    },
    "contracts/interfaces/ISignaturesValidatorVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidatorVault {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITemporarilyPausableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausableVault {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChangedVault(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedStateVault()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n"
    },
    "contracts/interfaces/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\ninterface IAuthorizer {\n    /**\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\n     */\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address where\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashLoanRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n// Inspired by Aave Protocol's IFlashLoanReceiver.\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IFlashLoanRecipient {\n    /**\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\n     *\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\n     * Vault, or else the entire flash loan will revert.\n     *\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external;\n}\n"
    },
    "contracts/interfaces/IProtocolFeesCollector.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20/IERC20.sol\";\n\nimport \"./IVault.sol\";\nimport \"./IAuthorizer.sol\";\n\ninterface IProtocolFeesCollector {\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\n\n    function withdrawCollectedFees(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external;\n\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\n\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\n\n    function getSwapFeePercentage() external view returns (uint256);\n\n    function getFlashLoanFeePercentage() external view returns (uint256);\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\n\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    function vault() external view returns (IVault);\n}\n"
    },
    "contracts/test/vault/MockAssetTransfersHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/math/Math.sol\";\nimport \"../../libraries/math/FixedPoint.sol\";\nimport \"../../libraries/SafeERC20.sol\";\n\nimport \"../../AssetTransfersHandler.sol\";\n\ncontract MockAssetTransfersHandler is AssetTransfersHandler {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    mapping(address => mapping(IERC20 => uint256)) private _internalTokenBalance;\n\n    constructor(IWETH weth) AssetHelpers(weth) {}\n\n    function receiveAsset(\n        IAsset asset,\n        uint256 amount,\n        address sender,\n        bool fromInternalBalance\n    ) external payable {\n        _receiveAsset(asset, amount, sender, fromInternalBalance);\n    }\n\n    function sendAsset(\n        IAsset asset,\n        uint256 amount,\n        address payable recipient,\n        bool toInternalBalance\n    ) external {\n        _sendAsset(asset, amount, recipient, toInternalBalance);\n    }\n\n    function getInternalBalance(address account, IERC20 token) external view returns (uint256) {\n        return _internalTokenBalance[account][token];\n    }\n\n    function depositToInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) external {\n        token.safeTransferFrom(account, address(this), amount);\n        _increaseInternalBalance(account, token, amount);\n    }\n\n    function _increaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) internal override {\n        _internalTokenBalance[account][token] += amount;\n    }\n\n    function _decreaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount,\n        bool capped\n    ) internal override returns (uint256 deducted) {\n        uint256 currentBalance = _internalTokenBalance[account][token];\n        deducted = capped ? Math.min(currentBalance, amount) : amount;\n        _internalTokenBalance[account][token] = currentBalance.sub(deducted);\n    }\n}\n"
    },
    "contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./LogExpMath.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        require(b <= a, \"SUB_OVERFLOW\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        require(a == 0 || product / a == b, \"MUL_OVERFLOW\");\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        require(a == 0 || product / a == b, \"MUL_OVERFLOW\");\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, \"DIV_INTERNAL\"); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, \"DIV_INTERNAL\"); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return sub(raw, maxError);\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        return add(raw, maxError);\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}\n"
    },
    "contracts/libraries/math/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.10;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        require(x < 2**255, \"X_OUT_OF_BOUNDS\");\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        require(y < MILD_EXPONENT_BOUND, \"Y_OUT_OF_BOUNDS\");\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            \"PRODUCT_OUT_OF_BOUNDS\"\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"INVALID_EXPONENT\");\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        require(a > 0, \"OUT_OF_BOUNDS\");\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n"
    },
    "contracts/test/vault/MockFlashLoanRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../libraries/math/Math.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\nimport \"../TestToken.sol\";\n\nimport \"../../interfaces/IFlashLoanRecipient.sol\";\nimport \"../../interfaces/IVault.sol\";\n\ncontract MockFlashLoanRecipient is IFlashLoanRecipient {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable vault;\n    bool public repayLoan;\n    bool public repayInExcess;\n    bool public reenter;\n\n    constructor(address _vault) {\n        vault = _vault;\n        repayLoan = true;\n        repayInExcess = false;\n        reenter = false;\n    }\n\n    function setRepayLoan(bool _repayLoan) public {\n        repayLoan = _repayLoan;\n    }\n\n    function setRepayInExcess(bool _repayInExcess) public {\n        repayInExcess = _repayInExcess;\n    }\n\n    function setReenter(bool _reenter) public {\n        reenter = _reenter;\n    }\n\n    // Repays loan unless setRepayLoan was called with 'false'\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external override {\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n            uint256 feeAmount = feeAmounts[i];\n\n            require(token.balanceOf(address(this)) == amount, \"INVALID_FLASHLOAN_BALANCE\");\n\n            if (reenter) {\n                IVault(msg.sender).flashLoan(IFlashLoanRecipient(address(this)), tokens, amounts, userData);\n            }\n\n            TestToken(address(token)).mint(address(this), repayInExcess ? feeAmount.add(1) : feeAmount);\n\n            uint256 totalDebt = amount.add(feeAmount);\n\n            if (!repayLoan) {\n                totalDebt = totalDebt.sub(1);\n            } else if (repayInExcess) {\n                totalDebt = totalDebt.add(1);\n            }\n\n            token.safeTransfer(vault, totalDebt);\n        }\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20Test.sol\";\nimport \"../libraries/ERC20Burnable.sol\";\nimport \"../libraries/AccessControl.sol\";\n\ncontract TestToken is AccessControl, ERC20, ERC20Burnable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        address admin,\n        string memory name,\n        string memory symbol // ,\n        // uint8 decimals\n    ) ERC20(name, symbol) {\n        // _setupDecimals(decimals);\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n        _setupRole(MINTER_ROLE, admin);\n    }\n\n    function mint(address recipient, uint256 amount) external {\n        require(hasRole(MINTER_ROLE, msg.sender), \"NOT_MINTER\");\n        _mint(recipient, amount);\n    }\n}\n"
    },
    "contracts/test/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/helpers/RequiemErrors.sol\";\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../libraries/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Test is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        _require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, msg.sender).sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\n\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/libraries/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        _require(hasRole(_roles[role].adminRole, msg.sender), Errors.GRANT_SENDER_NOT_ADMIN);\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had already been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        _require(hasRole(_roles[role].adminRole, msg.sender), Errors.REVOKE_SENDER_NOT_ADMIN);\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        _require(account == msg.sender, Errors.RENOUNCE_SENDER_NOT_ALLOWED);\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, Errors.SUB_OVERFLOW);\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        uint256 errorCode\n    ) internal pure returns (uint256) {\n        _require(b <= a, errorCode);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/libraries/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the EnumerableSet library from OpenZeppelin Contracts, altered to remove the base private functions that\n// work on bytes32, replacing them with a native implementation for address and bytes32 values, to reduce bytecode \n// size and runtime costs.\n// The `unchecked_at` function was also added, which allows for more gas efficient data reads in some scenarios.\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // The original OpenZeppelin implementation uses a generic Set type with bytes32 values: this was replaced with\n    // AddressSet, which uses address keys natively, resulting in more dense bytecode.\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                address lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        _require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(set, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return set._values[index];\n    }\n\n    function rawIndexOf(AddressSet storage set, address value) internal view returns (uint256) {\n        return set._indexes[value] - 1;\n    }\n\n    struct Bytes32Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0 \n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not \n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        _require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(set, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return set._values[index];\n    }\n\n    function rawIndexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\n        return set._indexes[value] - 1;\n    }\n}\n"
    },
    "contracts/WeightedPoolNoAMFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IVault.sol\";\n\nimport \"./libraries/factories/BasePoolSplitCodeFactory.sol\";\nimport \"./libraries/factories/FactoryWidePauseWindow.sol\";\n\nimport \"./WeightedPool.sol\";\n\ncontract WeightedPoolNoAMFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(WeightedPool).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `WeightedPool` without asset managers.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n            _create(\n                abi.encode(\n                    getVault(),\n                    name,\n                    symbol,\n                    tokens,\n                    weights,\n                    new address[](tokens.length), // Don't allow asset managers\n                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/factories/BasePoolSplitCodeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../helpers/BaseSplitCodeFactory.sol\";\nimport \"../../interfaces/IVault.sol\";\n\n/**\n * @dev Same as `BasePoolFactory`, for Pools whose creation code is so large that the factory cannot hold it.\n */\nabstract contract BasePoolSplitCodeFactory is BaseSplitCodeFactory {\n    IVault private immutable _vault;\n    mapping(address => bool) private _isPoolFromFactory;\n\n    event PoolCreated(address indexed pool);\n\n    constructor(IVault vault, bytes memory creationCode) BaseSplitCodeFactory(creationCode) {\n        _vault = vault;\n    }\n\n    /**\n     * @dev Returns the Vault's address.\n     */\n    function getVault() public view returns (IVault) {\n        return _vault;\n    }\n\n    /**\n     * @dev Returns true if `pool` was created by this factory.\n     */\n    function isPoolFromFactory(address pool) external view returns (bool) {\n        return _isPoolFromFactory[pool];\n    }\n\n    function _create(bytes memory constructorArgs) internal override returns (address) {\n        address pool = super._create(constructorArgs);\n\n        _isPoolFromFactory[pool] = true;\n        emit PoolCreated(pool);\n\n        return pool;\n    }\n}\n"
    },
    "contracts/libraries/factories/FactoryWidePauseWindow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Utility to create Pool factories for Pools that use the `TemporarilyPausable` contract.\n *\n * By calling `TemporarilyPausable`'s constructor with the result of `getPauseConfiguration`, all Pools created by this\n * factory will share the same Pause Window end time, after which both old and new Pools will not be pausable.\n */\ncontract FactoryWidePauseWindow {\n    // This contract relies on timestamps in a similar way as `TemporarilyPausable` does - the same caveats apply.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _INITIAL_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _BUFFER_PERIOD_DURATION = 30 days;\n\n    // Time when the pause window for all created Pools expires, and the pause window duration of new Pools becomes\n    // zero.\n    uint256 private immutable _poolsPauseWindowEndTime;\n\n    constructor() {\n        _poolsPauseWindowEndTime = block.timestamp + _INITIAL_PAUSE_WINDOW_DURATION;\n    }\n\n    /**\n     * @dev Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this\n     * factory.\n     *\n     * `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and\n     * `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable.\n     */\n    function getPauseConfiguration() public view returns (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        uint256 currentTime = block.timestamp;\n        if (currentTime < _poolsPauseWindowEndTime) {\n            // The buffer period is always the same since its duration is related to how much time is needed to respond\n            // to a potential emergency. The Pause Window duration however decreases as the end time approaches.\n\n            pauseWindowDuration = _poolsPauseWindowEndTime - currentTime; // No need for checked arithmetic.\n            bufferPeriodDuration = _BUFFER_PERIOD_DURATION;\n        } else {\n            // After the end time, newly created Pools have no Pause Window, nor Buffer Period (since they are not\n            // pausable in the first place).\n\n            pauseWindowDuration = 0;\n            bufferPeriodDuration = 0;\n        }\n    }\n}\n"
    },
    "contracts/WeightedPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseWeightedPool.sol\";\n\n/**\n * @dev Basic Weighted Pool with immutable weights.\n */\ncontract WeightedPool is BaseWeightedPool {\n    using FixedPoint for uint256;\n\n    uint256 private constant _MAX_TOKENS = 20;\n\n    uint256 private immutable _totalTokens;\n\n    IERC20 internal immutable _token0;\n    IERC20 internal immutable _token1;\n    IERC20 internal immutable _token2;\n    IERC20 internal immutable _token3;\n    IERC20 internal immutable _token4;\n    IERC20 internal immutable _token5;\n    IERC20 internal immutable _token6;\n    IERC20 internal immutable _token7;\n    IERC20 internal immutable _token8;\n    IERC20 internal immutable _token9;\n    IERC20 internal immutable _token10;\n    IERC20 internal immutable _token11;\n    IERC20 internal immutable _token12;\n    IERC20 internal immutable _token13;\n    IERC20 internal immutable _token14;\n    IERC20 internal immutable _token15;\n    IERC20 internal immutable _token16;\n    IERC20 internal immutable _token17;\n    IERC20 internal immutable _token18;\n    IERC20 internal immutable _token19;\n\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\n\n    uint256 internal immutable _scalingFactor0;\n    uint256 internal immutable _scalingFactor1;\n    uint256 internal immutable _scalingFactor2;\n    uint256 internal immutable _scalingFactor3;\n    uint256 internal immutable _scalingFactor4;\n    uint256 internal immutable _scalingFactor5;\n    uint256 internal immutable _scalingFactor6;\n    uint256 internal immutable _scalingFactor7;\n    uint256 internal immutable _scalingFactor8;\n    uint256 internal immutable _scalingFactor9;\n    uint256 internal immutable _scalingFactor10;\n    uint256 internal immutable _scalingFactor11;\n    uint256 internal immutable _scalingFactor12;\n    uint256 internal immutable _scalingFactor13;\n    uint256 internal immutable _scalingFactor14;\n    uint256 internal immutable _scalingFactor15;\n    uint256 internal immutable _scalingFactor16;\n    uint256 internal immutable _scalingFactor17;\n    uint256 internal immutable _scalingFactor18;\n    uint256 internal immutable _scalingFactor19;\n\n    // The protocol fees will always be charged using the token associated with the max weight in the pool.\n    // Since these Pools will register tokens only once, we can assume this index will be constant.\n    uint256 internal immutable _maxWeightTokenIndex;\n\n    uint256 internal immutable _normalizedWeight0;\n    uint256 internal immutable _normalizedWeight1;\n    uint256 internal immutable _normalizedWeight2;\n    uint256 internal immutable _normalizedWeight3;\n    uint256 internal immutable _normalizedWeight4;\n    uint256 internal immutable _normalizedWeight5;\n    uint256 internal immutable _normalizedWeight6;\n    uint256 internal immutable _normalizedWeight7;\n    uint256 internal immutable _normalizedWeight8;\n    uint256 internal immutable _normalizedWeight9;\n    uint256 internal immutable _normalizedWeight10;\n    uint256 internal immutable _normalizedWeight11;\n    uint256 internal immutable _normalizedWeight12;\n    uint256 internal immutable _normalizedWeight13;\n    uint256 internal immutable _normalizedWeight14;\n    uint256 internal immutable _normalizedWeight15;\n    uint256 internal immutable _normalizedWeight16;\n    uint256 internal immutable _normalizedWeight17;\n    uint256 internal immutable _normalizedWeight18;\n    uint256 internal immutable _normalizedWeight19;\n\n    constructor(\n        IVault vault,\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory normalizedWeights,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        BaseWeightedPool(\n            vault,\n            name,\n            symbol,\n            tokens,\n            assetManagers,\n            swapFeePercentage,\n            pauseWindowDuration,\n            bufferPeriodDuration,\n            owner\n        )\n    {\n        uint256 numTokens = tokens.length;\n        InputHelpers.ensureInputLengthMatch(numTokens, normalizedWeights.length);\n\n        _totalTokens = numTokens;\n\n        // Ensure  each normalized weight is above them minimum and find the token index of the maximum weight\n        uint256 normalizedSum = 0;\n        uint256 maxWeightTokenIndex = 0;\n        uint256 maxNormalizedWeight = 0;\n        for (uint8 i = 0; i < numTokens; i++) {\n            uint256 normalizedWeight = normalizedWeights[i];\n            _require(normalizedWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n\n            normalizedSum = normalizedSum.add(normalizedWeight);\n            if (normalizedWeight > maxNormalizedWeight) {\n                maxWeightTokenIndex = i;\n                maxNormalizedWeight = normalizedWeight;\n            }\n        }\n        // Ensure that the normalized weights sum to ONE\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\n\n        _maxWeightTokenIndex = maxWeightTokenIndex;\n\n        _normalizedWeight0 = normalizedWeights[0];\n        _normalizedWeight1 = normalizedWeights[1];\n        _normalizedWeight2 = numTokens > 2 ? normalizedWeights[2] : 0;\n        _normalizedWeight3 = numTokens > 3 ? normalizedWeights[3] : 0;\n        _normalizedWeight4 = numTokens > 4 ? normalizedWeights[4] : 0;\n        _normalizedWeight5 = numTokens > 5 ? normalizedWeights[5] : 0;\n        _normalizedWeight6 = numTokens > 6 ? normalizedWeights[6] : 0;\n        _normalizedWeight7 = numTokens > 7 ? normalizedWeights[7] : 0;\n        _normalizedWeight8 = numTokens > 8 ? normalizedWeights[8] : 0;\n        _normalizedWeight9 = numTokens > 9 ? normalizedWeights[9] : 0;\n        _normalizedWeight10 = numTokens > 10 ? normalizedWeights[10] : 0;\n        _normalizedWeight11 = numTokens > 11 ? normalizedWeights[11] : 0;\n        _normalizedWeight12 = numTokens > 12 ? normalizedWeights[12] : 0;\n        _normalizedWeight13 = numTokens > 13 ? normalizedWeights[13] : 0;\n        _normalizedWeight14 = numTokens > 14 ? normalizedWeights[14] : 0;\n        _normalizedWeight15 = numTokens > 15 ? normalizedWeights[15] : 0;\n        _normalizedWeight16 = numTokens > 16 ? normalizedWeights[16] : 0;\n        _normalizedWeight17 = numTokens > 17 ? normalizedWeights[17] : 0;\n        _normalizedWeight18 = numTokens > 18 ? normalizedWeights[18] : 0;\n        _normalizedWeight19 = numTokens > 19 ? normalizedWeights[19] : 0;\n\n        // Immutable variables cannot be initialized inside an if statement, so we must do conditional assignments\n        _token0 = tokens[0];\n        _token1 = tokens[1];\n        _token2 = numTokens > 2 ? tokens[2] : IERC20(address(0));\n        _token3 = numTokens > 3 ? tokens[3] : IERC20(address(0));\n        _token4 = numTokens > 4 ? tokens[4] : IERC20(address(0));\n        _token5 = numTokens > 5 ? tokens[5] : IERC20(address(0));\n        _token6 = numTokens > 6 ? tokens[6] : IERC20(address(0));\n        _token7 = numTokens > 7 ? tokens[7] : IERC20(address(0));\n        _token8 = numTokens > 8 ? tokens[8] : IERC20(address(0));\n        _token9 = numTokens > 9 ? tokens[9] : IERC20(address(0));\n        _token10 = numTokens > 10 ? tokens[10] : IERC20(address(0));\n        _token11 = numTokens > 11 ? tokens[11] : IERC20(address(0));\n        _token12 = numTokens > 12 ? tokens[12] : IERC20(address(0));\n        _token13 = numTokens > 13 ? tokens[13] : IERC20(address(0));\n        _token14 = numTokens > 14 ? tokens[14] : IERC20(address(0));\n        _token15 = numTokens > 15 ? tokens[15] : IERC20(address(0));\n        _token16 = numTokens > 16 ? tokens[16] : IERC20(address(0));\n        _token17 = numTokens > 17 ? tokens[17] : IERC20(address(0));\n        _token18 = numTokens > 18 ? tokens[18] : IERC20(address(0));\n        _token19 = numTokens > 19 ? tokens[19] : IERC20(address(0));\n\n        _scalingFactor0 = _computeScalingFactor(tokens[0]);\n        _scalingFactor1 = _computeScalingFactor(tokens[1]);\n        _scalingFactor2 = numTokens > 2 ? _computeScalingFactor(tokens[2]) : 0;\n        _scalingFactor3 = numTokens > 3 ? _computeScalingFactor(tokens[3]) : 0;\n        _scalingFactor4 = numTokens > 4 ? _computeScalingFactor(tokens[4]) : 0;\n        _scalingFactor5 = numTokens > 5 ? _computeScalingFactor(tokens[5]) : 0;\n        _scalingFactor6 = numTokens > 6 ? _computeScalingFactor(tokens[6]) : 0;\n        _scalingFactor7 = numTokens > 7 ? _computeScalingFactor(tokens[7]) : 0;\n        _scalingFactor8 = numTokens > 8 ? _computeScalingFactor(tokens[8]) : 0;\n        _scalingFactor9 = numTokens > 9 ? _computeScalingFactor(tokens[9]) : 0;\n        _scalingFactor10 = numTokens > 10 ? _computeScalingFactor(tokens[10]) : 0;\n        _scalingFactor11 = numTokens > 11 ? _computeScalingFactor(tokens[11]) : 0;\n        _scalingFactor12 = numTokens > 12 ? _computeScalingFactor(tokens[12]) : 0;\n        _scalingFactor13 = numTokens > 13 ? _computeScalingFactor(tokens[13]) : 0;\n        _scalingFactor14 = numTokens > 14 ? _computeScalingFactor(tokens[14]) : 0;\n        _scalingFactor15 = numTokens > 15 ? _computeScalingFactor(tokens[15]) : 0;\n        _scalingFactor16 = numTokens > 16 ? _computeScalingFactor(tokens[16]) : 0;\n        _scalingFactor17 = numTokens > 17 ? _computeScalingFactor(tokens[17]) : 0;\n        _scalingFactor18 = numTokens > 18 ? _computeScalingFactor(tokens[18]) : 0;\n        _scalingFactor19 = numTokens > 19 ? _computeScalingFactor(tokens[19]) : 0;\n    }\n\n    function _getNormalizedWeight(IERC20 token) internal view virtual override returns (uint256) {\n        // prettier-ignore\n        if (token == _token0) { return _normalizedWeight0; }\n        else if (token == _token1) { return _normalizedWeight1; }\n        else if (token == _token2) { return _normalizedWeight2; }\n        else if (token == _token3) { return _normalizedWeight3; }\n        else if (token == _token4) { return _normalizedWeight4; }\n        else if (token == _token5) { return _normalizedWeight5; }\n        else if (token == _token6) { return _normalizedWeight6; }\n        else if (token == _token7) { return _normalizedWeight7; }\n        else if (token == _token8) { return _normalizedWeight8; }\n        else if (token == _token9) { return _normalizedWeight9; }\n        else if (token == _token10) { return _normalizedWeight10; }\n        else if (token == _token11) { return _normalizedWeight11; }\n        else if (token == _token12) { return _normalizedWeight12; }\n        else if (token == _token13) { return _normalizedWeight13; }\n        else if (token == _token14) { return _normalizedWeight14; }\n        else if (token == _token15) { return _normalizedWeight15; }\n        else if (token == _token16) { return _normalizedWeight16; }\n        else if (token == _token17) { return _normalizedWeight17; }\n        else if (token == _token18) { return _normalizedWeight18; }\n        else if (token == _token19) { return _normalizedWeight19; }\n        else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    function _getNormalizedWeights() internal view virtual override returns (uint256[] memory) {\n        uint256 totalTokens = _getTotalTokens();\n        uint256[] memory normalizedWeights = new uint256[](totalTokens);\n\n        // prettier-ignore\n        {\n            normalizedWeights[0] = _normalizedWeight0;\n            normalizedWeights[1] = _normalizedWeight1;\n            if (totalTokens > 2) { normalizedWeights[2] = _normalizedWeight2; } else { return normalizedWeights; }\n            if (totalTokens > 3) { normalizedWeights[3] = _normalizedWeight3; } else { return normalizedWeights; }\n            if (totalTokens > 4) { normalizedWeights[4] = _normalizedWeight4; } else { return normalizedWeights; }\n            if (totalTokens > 5) { normalizedWeights[5] = _normalizedWeight5; } else { return normalizedWeights; }\n            if (totalTokens > 6) { normalizedWeights[6] = _normalizedWeight6; } else { return normalizedWeights; }\n            if (totalTokens > 7) { normalizedWeights[7] = _normalizedWeight7; } else { return normalizedWeights; }\n            if (totalTokens > 8) { normalizedWeights[8] = _normalizedWeight8; } else { return normalizedWeights; }\n            if (totalTokens > 9) { normalizedWeights[9] = _normalizedWeight9; } else { return normalizedWeights; }\n            if (totalTokens > 10) { normalizedWeights[10] = _normalizedWeight10; } else { return normalizedWeights; }\n            if (totalTokens > 11) { normalizedWeights[11] = _normalizedWeight11; } else { return normalizedWeights; }\n            if (totalTokens > 12) { normalizedWeights[12] = _normalizedWeight12; } else { return normalizedWeights; }\n            if (totalTokens > 13) { normalizedWeights[13] = _normalizedWeight13; } else { return normalizedWeights; }\n            if (totalTokens > 14) { normalizedWeights[14] = _normalizedWeight14; } else { return normalizedWeights; }\n            if (totalTokens > 15) { normalizedWeights[15] = _normalizedWeight15; } else { return normalizedWeights; }\n            if (totalTokens > 16) { normalizedWeights[16] = _normalizedWeight16; } else { return normalizedWeights; }\n            if (totalTokens > 17) { normalizedWeights[17] = _normalizedWeight17; } else { return normalizedWeights; }\n            if (totalTokens > 18) { normalizedWeights[18] = _normalizedWeight18; } else { return normalizedWeights; }\n            if (totalTokens > 19) { normalizedWeights[19] = _normalizedWeight19; } else { return normalizedWeights; }\n        }\n\n        return normalizedWeights;\n    }\n\n    function _getNormalizedWeightsAndMaxWeightIndex()\n        internal\n        view\n        virtual\n        override\n        returns (uint256[] memory, uint256)\n    {\n        return (_getNormalizedWeights(), _maxWeightTokenIndex);\n    }\n\n    function _getMaxTokens() internal pure virtual override returns (uint256) {\n        return _MAX_TOKENS;\n    }\n\n    function _getTotalTokens() internal view virtual override returns (uint256) {\n        return _totalTokens;\n    }\n\n    /**\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\n     * Pool.\n     */\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\n        // prettier-ignore\n        if (token == _token0) { return _scalingFactor0; }\n        else if (token == _token1) { return _scalingFactor1; }\n        else if (token == _token2) { return _scalingFactor2; }\n        else if (token == _token3) { return _scalingFactor3; }\n        else if (token == _token4) { return _scalingFactor4; }\n        else if (token == _token5) { return _scalingFactor5; }\n        else if (token == _token6) { return _scalingFactor6; }\n        else if (token == _token7) { return _scalingFactor7; }\n        else if (token == _token8) { return _scalingFactor8; }\n        else if (token == _token9) { return _scalingFactor9; }\n        else if (token == _token10) { return _scalingFactor10; }\n        else if (token == _token11) { return _scalingFactor11; }\n        else if (token == _token12) { return _scalingFactor12; }\n        else if (token == _token13) { return _scalingFactor13; }\n        else if (token == _token14) { return _scalingFactor14; }\n        else if (token == _token15) { return _scalingFactor15; }\n        else if (token == _token16) { return _scalingFactor16; }\n        else if (token == _token17) { return _scalingFactor17; }\n        else if (token == _token18) { return _scalingFactor18; }\n        else if (token == _token19) { return _scalingFactor19; }\n        else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    function _scalingFactors() internal view virtual override returns (uint256[] memory) {\n        uint256 totalTokens = _getTotalTokens();\n        uint256[] memory scalingFactors = new uint256[](totalTokens);\n\n        // prettier-ignore\n        {\n            scalingFactors[0] = _scalingFactor0;\n            scalingFactors[1] = _scalingFactor1;\n            if (totalTokens > 2) { scalingFactors[2] = _scalingFactor2; } else { return scalingFactors; }\n            if (totalTokens > 3) { scalingFactors[3] = _scalingFactor3; } else { return scalingFactors; }\n            if (totalTokens > 4) { scalingFactors[4] = _scalingFactor4; } else { return scalingFactors; }\n            if (totalTokens > 5) { scalingFactors[5] = _scalingFactor5; } else { return scalingFactors; }\n            if (totalTokens > 6) { scalingFactors[6] = _scalingFactor6; } else { return scalingFactors; }\n            if (totalTokens > 7) { scalingFactors[7] = _scalingFactor7; } else { return scalingFactors; }\n            if (totalTokens > 8) { scalingFactors[8] = _scalingFactor8; } else { return scalingFactors; }\n            if (totalTokens > 9) { scalingFactors[9] = _scalingFactor9; } else { return scalingFactors; }\n            if (totalTokens > 10) { scalingFactors[10] = _scalingFactor10; } else { return scalingFactors; }\n            if (totalTokens > 11) { scalingFactors[11] = _scalingFactor11; } else { return scalingFactors; }\n            if (totalTokens > 12) { scalingFactors[12] = _scalingFactor12; } else { return scalingFactors; }\n            if (totalTokens > 13) { scalingFactors[13] = _scalingFactor13; } else { return scalingFactors; }\n            if (totalTokens > 14) { scalingFactors[14] = _scalingFactor14; } else { return scalingFactors; }\n            if (totalTokens > 15) { scalingFactors[15] = _scalingFactor15; } else { return scalingFactors; }\n            if (totalTokens > 16) { scalingFactors[16] = _scalingFactor16; } else { return scalingFactors; }\n            if (totalTokens > 17) { scalingFactors[17] = _scalingFactor17; } else { return scalingFactors; }\n            if (totalTokens > 18) { scalingFactors[18] = _scalingFactor18; } else { return scalingFactors; }\n            if (totalTokens > 19) { scalingFactors[19] = _scalingFactor19; } else { return scalingFactors; }\n        }\n\n        return scalingFactors;\n    }\n}\n"
    },
    "contracts/libraries/helpers/BaseSplitCodeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./CodeDeployer.sol\";\n\n/**\n * @dev Base factory for contracts whose creation code is so large that the factory cannot hold it. This happens when\n * the contract's creation code grows close to 24kB.\n *\n * Note that this factory cannot help with contracts that have a *runtime* (deployed) bytecode larger than 24kB.\n */\nabstract contract BaseSplitCodeFactory {\n    // The contract's creation code is stored as code in two separate addresses, and retrieved via `extcodecopy`. This\n    // means this factory supports contracts with creation code of up to 48kB.\n    // We rely on inline-assembly to achieve this, both to make the entire operation highly gas efficient, and because\n    // `extcodecopy` is not available in Solidity.\n\n    // solhint-disable no-inline-assembly\n\n    address private immutable _creationCodeContractA;\n    uint256 private immutable _creationCodeSizeA;\n\n    address private immutable _creationCodeContractB;\n    uint256 private immutable _creationCodeSizeB;\n\n    /**\n     * @dev The creation code of a contract Foo can be obtained inside Solidity with `type(Foo).creationCode`.\n     */\n    constructor(bytes memory creationCode) {\n        uint256 creationCodeSize = creationCode.length;\n\n        // We are going to deploy two contracts: one with approximately the first half of `creationCode`'s contents\n        // (A), and another with the remaining half (B).\n        // We store the lengths in both immutable and stack variables, since immutable variables cannot be read during\n        // construction.\n        uint256 creationCodeSizeA = creationCodeSize / 2;\n        _creationCodeSizeA = creationCodeSizeA;\n\n        uint256 creationCodeSizeB = creationCodeSize - creationCodeSizeA;\n        _creationCodeSizeB = creationCodeSizeB;\n\n        // To deploy the contracts, we're going to use `CodeDeployer.deploy()`, which expects a memory array with\n        // the code to deploy. Note that we cannot simply create arrays for A and B's code by copying or moving\n        // `creationCode`'s contents as they are expected to be very large (> 24kB), so we must operate in-place.\n\n        // Memory: [ code length ] [ A.data ] [ B.data ]\n\n        // Creating A's array is simple: we simply replace `creationCode`'s length with A's length. We'll later restore\n        // the original length.\n\n        bytes memory creationCodeA;\n        assembly {\n            creationCodeA := creationCode\n            mstore(creationCodeA, creationCodeSizeA)\n        }\n\n        // Memory: [ A.length ] [ A.data ] [ B.data ]\n        //         ^ creationCodeA\n\n        _creationCodeContractA = CodeDeployer.deploy(creationCodeA);\n\n        // Creating B's array is a bit more involved: since we cannot move B's contents, we are going to create a 'new'\n        // memory array starting at A's last 32 bytes, which will be replaced with B's length. We'll back-up this last\n        // byte to later restore it.\n\n        bytes memory creationCodeB;\n        bytes32 lastByteA;\n\n        assembly {\n            // `creationCode` points to the array's length, not data, so by adding A's length to it we arrive at A's\n            // last 32 bytes.\n            creationCodeB := add(creationCode, creationCodeSizeA)\n            lastByteA := mload(creationCodeB)\n            mstore(creationCodeB, creationCodeSizeB)\n        }\n\n        // Memory: [ A.length ] [ A.data[ : -1] ] [ B.length ][ B.data ]\n        //         ^ creationCodeA                ^ creationCodeB\n\n        _creationCodeContractB = CodeDeployer.deploy(creationCodeB);\n\n        // We now restore the original contents of `creationCode` by writing back the original length and A's last byte.\n        assembly {\n            mstore(creationCodeA, creationCodeSize)\n            mstore(creationCodeB, lastByteA)\n        }\n    }\n\n    /**\n     * @dev Returns the two addresses where the creation code of the contract crated by this factory is stored.\n     */\n    function getCreationCodeContracts() public view returns (address contractA, address contractB) {\n        return (_creationCodeContractA, _creationCodeContractB);\n    }\n\n    /**\n     * @dev Returns the creation code of the contract this factory creates.\n     */\n    function getCreationCode() public view returns (bytes memory) {\n        return _getCreationCodeWithArgs(\"\");\n    }\n\n    /**\n     * @dev Returns the creation code that will result in a contract being deployed with `constructorArgs`.\n     */\n    function _getCreationCodeWithArgs(bytes memory constructorArgs) private view returns (bytes memory code) {\n        // This function exists because `abi.encode()` cannot be instructed to place its result at a specific address.\n        // We need for the ABI-encoded constructor arguments to be located immediately after the creation code, but\n        // cannot rely on `abi.encodePacked()` to perform concatenation as that would involve copying the creation code,\n        // which would be prohibitively expensive.\n        // Instead, we compute the creation code in a pre-allocated array that is large enough to hold *both* the\n        // creation code and the constructor arguments, and then copy the ABI-encoded arguments (which should not be\n        // overly long) right after the end of the creation code.\n\n        // Immutable variables cannot be used in assembly, so we store them in the stack first.\n        address creationCodeContractA = _creationCodeContractA;\n        uint256 creationCodeSizeA = _creationCodeSizeA;\n        address creationCodeContractB = _creationCodeContractB;\n        uint256 creationCodeSizeB = _creationCodeSizeB;\n\n        uint256 creationCodeSize = creationCodeSizeA + creationCodeSizeB;\n        uint256 constructorArgsSize = constructorArgs.length;\n\n        uint256 codeSize = creationCodeSize + constructorArgsSize;\n\n        assembly {\n            // First, we allocate memory for `code` by retrieving the free memory pointer and then moving it ahead of\n            // `code` by the size of the creation code plus constructor arguments, and 32 bytes for the array length.\n            code := mload(0x40)\n            mstore(0x40, add(code, add(codeSize, 32)))\n\n            // We now store the length of the code plus constructor arguments.\n            mstore(code, codeSize)\n\n            // Next, we concatenate the creation code stored in A and B.\n            let dataStart := add(code, 32)\n            extcodecopy(creationCodeContractA, dataStart, 0, creationCodeSizeA)\n            extcodecopy(creationCodeContractB, add(dataStart, creationCodeSizeA), 0, creationCodeSizeB)\n        }\n\n        // Finally, we copy the constructorArgs to the end of the array. Unfortunately there is no way to avoid this\n        // copy, as it is not possible to tell Solidity where to store the result of `abi.encode()`.\n        uint256 constructorArgsDataPtr;\n        uint256 constructorArgsCodeDataPtr;\n        assembly {\n            constructorArgsDataPtr := add(constructorArgs, 32)\n            constructorArgsCodeDataPtr := add(add(code, 32), creationCodeSize)\n        }\n\n        _memcpy(constructorArgsCodeDataPtr, constructorArgsDataPtr, constructorArgsSize);\n    }\n\n    /**\n     * @dev Deploys a contract with constructor arguments. To create `constructorArgs`, call `abi.encode()` with the\n     * contract's constructor arguments, in order.\n     */\n    function _create(bytes memory constructorArgs) internal virtual returns (address) {\n        bytes memory creationCode = _getCreationCodeWithArgs(constructorArgs);\n\n        address destination;\n        assembly {\n            destination := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        if (destination == address(0)) {\n            // Bubble up inner revert reason\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        return destination;\n    }\n\n    // From\n    // https://github.com/Arachnid/solidity-stringutils/blob/b9a6f6615cf18a87a823cbc461ce9e140a61c305/src/strings.sol\n    function _memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/CodeDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as\n * contract code, which can be retrieved via the `extcodecopy` opcode.\n */\nlibrary CodeDeployer {\n    // During contract construction, the full code supplied exists as code, and can be accessed via `codesize` and\n    // `codecopy`. This is not the contract's final code however: whatever the constructor returns is what will be\n    // stored as its code.\n    //\n    // We use this mechanism to have a simple constructor that stores whatever is appended to it. The following opcode\n    // sequence corresponds to the creation code of the following equivalent Solidity contract, plus padding to make the\n    // full code 32 bytes long:\n    //\n    // contract CodeDeployer {\n    //     constructor() payable {\n    //         uint256 size;\n    //         assembly {\n    //             size := sub(codesize(), 32) // size of appended data, as constructor is 32 bytes long\n    //             codecopy(0, 32, size) // copy all appended data to memory at position 0\n    //             return(0, size) // return appended data for it to be stored as code\n    //         }\n    //     }\n    // }\n    //\n    // More specifically, it is composed of the following opcodes (plus padding):\n    //\n    // [1] PUSH1 0x20\n    // [2] CODESIZE\n    // [3] SUB\n    // [4] DUP1\n    // [6] PUSH1 0x20\n    // [8] PUSH1 0x00\n    // [9] CODECOPY\n    // [11] PUSH1 0x00\n    // [12] RETURN\n    //\n    // The padding is just the 0xfe sequence (invalid opcode).\n    bytes32 private constant _DEPLOYER_CREATION_CODE = 0x602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe;\n\n    /**\n     * @dev Deploys a contract with `code` as its code, returning the destination address.\n     *\n     * Reverts if deployment fails.\n     */\n    function deploy(bytes memory code) internal returns (address destination) {\n        bytes32 deployerCreationCode = _DEPLOYER_CREATION_CODE;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let codeLength := mload(code)\n\n            // `code` is composed of length and data. We've already stored its length in `codeLength`, so we simply\n            // replace it with the deployer creation code (which is exactly 32 bytes long).\n            mstore(code, deployerCreationCode)\n\n            // At this point, `code` now points to the deployer creation code immediately followed by `code`'s data\n            // contents. This is exactly what the deployer expects to receive when created.\n            destination := create(0, code, add(codeLength, 32))\n\n            // Finally, we restore the original length in order to not mutate `code`.\n            mstore(code, codeLength)\n        }\n\n        // The create opcode returns the zero address when contract creation fails, so we revert if this happens.\n        require(destination != address(0), \"CODE_DEPLOYMENT_FAILED\");\n    }\n}\n"
    },
    "contracts/BaseWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\n\nimport \"./BaseMinimalSwapInfoPool.sol\";\n\nimport \"./libraries/weighted/WeightedMath.sol\";\nimport \"./libraries/weighted/WeightedPoolUserDataHelpers.sol\";\n\n/**\n * @dev Base class for WeightedPools containing swap, join and exit logic, but leaving storage and management of\n * the weights to subclasses. Derived contracts can choose to make weights immutable, mutable, or even dynamic\n *  based on local or external logic.\n */\nabstract contract BaseWeightedPool is BaseMinimalSwapInfoPool {\n    using FixedPoint for uint256;\n    using WeightedPoolUserDataHelpers for bytes;\n\n    uint256 private _lastInvariant;\n\n    // For backwards compatibility, make sure new join and exit kinds are added at the end of the enum.\n\n    enum JoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT,\n        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT\n    }\n    enum ExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\n        MANAGEMENT_FEE_TOKENS_OUT // for ManagedPool\n    }\n\n    constructor(\n        IVault vault,\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        BasePool(\n            vault,\n            // Given BaseMinimalSwapInfoPool supports both of these specializations, and this Pool never registers or\n            // deregisters any tokens after construction, picking Two Token when the Pool only has two tokens is free\n            // gas savings.\n            tokens.length == 2 ? IVault.PoolSpecialization.TWO_TOKEN : IVault.PoolSpecialization.MINIMAL_SWAP_INFO,\n            name,\n            symbol,\n            tokens,\n            assetManagers,\n            swapFeePercentage,\n            pauseWindowDuration,\n            bufferPeriodDuration,\n            owner\n        )\n    {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // Virtual functions\n\n    /**\n     * @dev Returns the normalized weight of `token`. Weights are fixed point numbers that sum to FixedPoint.ONE.\n     */\n    function _getNormalizedWeight(IERC20 token) internal view virtual returns (uint256);\n\n    /**\n     * @dev Returns all normalized weights, in the same order as the Pool's tokens.\n     */\n    function _getNormalizedWeights() internal view virtual returns (uint256[] memory);\n\n    /**\n     * @dev Returns all normalized weights, in the same order as the Pool's tokens, along with the index of the token\n     * with the highest weight.\n     */\n    function _getNormalizedWeightsAndMaxWeightIndex() internal view virtual returns (uint256[] memory, uint256);\n\n    function getLastInvariant() public view virtual returns (uint256) {\n        return _lastInvariant;\n    }\n\n    /**\n     * @dev Returns the current value of the invariant.\n     */\n    function getInvariant() public view returns (uint256) {\n        (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());\n\n        // Since the Pool hooks always work with upscaled balances, we manually\n        // upscale here for consistency\n        _upscaleArray(balances, _scalingFactors());\n\n        (uint256[] memory normalizedWeights, ) = _getNormalizedWeightsAndMaxWeightIndex();\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\n    }\n\n    function getNormalizedWeights() external view returns (uint256[] memory) {\n        return _getNormalizedWeights();\n    }\n\n    // Base Pool handlers\n\n    // Swap\n\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view virtual override whenNotPaused returns (uint256) {\n        // Swaps are disabled while the contract is paused.\n\n        return WeightedMath._calcOutGivenIn(currentBalanceTokenIn, _getNormalizedWeight(swapRequest.tokenIn), currentBalanceTokenOut, _getNormalizedWeight(swapRequest.tokenOut), swapRequest.amount);\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view virtual override whenNotPaused returns (uint256) {\n        // Swaps are disabled while the contract is paused.\n\n        return WeightedMath._calcInGivenOut(currentBalanceTokenIn, _getNormalizedWeight(swapRequest.tokenIn), currentBalanceTokenOut, _getNormalizedWeight(swapRequest.tokenOut), swapRequest.amount);\n    }\n\n    // Initialize\n\n    function _onInitializePool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal virtual override whenNotPaused returns (uint256, uint256[] memory) {\n        // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent\n        // initialization in this case.\n\n        JoinKind kind = userData.joinKind();\n        _require(kind == JoinKind.INIT, Errors.UNINITIALIZED);\n\n        uint256[] memory amountsIn = userData.initialAmountsIn();\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), amountsIn.length);\n        _upscaleArray(amountsIn, scalingFactors);\n\n        (uint256[] memory normalizedWeights, ) = _getNormalizedWeightsAndMaxWeightIndex();\n\n        uint256 invariantAfterJoin = WeightedMath._calculateInvariant(normalizedWeights, amountsIn);\n\n        // Set the initial BPT to the value of the invariant times the number of tokens. This makes BPT supply more\n        // consistent in Pools with similar compositions but different number of tokens.\n        uint256 bptAmountOut = Math.mul(invariantAfterJoin, _getTotalTokens());\n\n        _lastInvariant = invariantAfterJoin;\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    // Join\n\n    function _onJoinPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        override\n        whenNotPaused\n        returns (\n            uint256,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        // All joins are disabled while the contract is paused.\n\n        (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex) = _getNormalizedWeightsAndMaxWeightIndex();\n\n        // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join\n        // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas\n        // computing them on each individual swap\n        uint256 invariantBeforeJoin = WeightedMath._calculateInvariant(normalizedWeights, balances);\n\n        uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, normalizedWeights, maxWeightTokenIndex, _lastInvariant, invariantBeforeJoin, protocolSwapFeePercentage);\n\n        // Update current balances by subtracting the protocol fee amounts\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n        (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, normalizedWeights, scalingFactors, userData);\n\n        // Update the invariant with the balances the Pool will have after the join, in order to compute the\n        // protocol swap fee amounts due in future joins and exits.\n        _lastInvariant = _invariantAfterJoin(balances, amountsIn, normalizedWeights);\n\n        return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);\n    }\n\n    function _doJoin(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal returns (uint256, uint256[] memory) {\n        JoinKind kind = userData.joinKind();\n\n        if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, scalingFactors, userData);\n        } else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT) {\n            return _joinAllTokensInForExactBPTOut(balances, userData);\n        } else {\n            _revert(Errors.UNHANDLED_JOIN_KIND);\n        }\n    }\n\n    function _joinExactTokensInForBPTOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) private returns (uint256, uint256[] memory) {\n        (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), amountsIn.length);\n\n        _upscaleArray(amountsIn, scalingFactors);\n\n        (uint256 bptAmountOut, uint256[] memory swapFees) = WeightedMath._calcBptOutGivenExactTokensIn(balances, normalizedWeights, amountsIn, totalSupply(), getSwapFeePercentage());\n\n        // Note that swapFees is already upscaled\n        _processSwapFeeAmounts(swapFees);\n\n        _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _joinTokenInForExactBPTOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private returns (uint256, uint256[] memory) {\n        (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();\n        // Note that there is no maximum amountIn parameter: this is handled by `IVault.joinPool`.\n\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\n\n        (uint256 amountIn, uint256 swapFee) = WeightedMath._calcTokenInGivenExactBptOut(balances[tokenIndex], normalizedWeights[tokenIndex], bptAmountOut, totalSupply(), getSwapFeePercentage());\n\n        // Note that swapFee is already upscaled\n        _processSwapFeeAmount(tokenIndex, swapFee);\n\n        // We join in a single token, so we initialize amountsIn with zeros\n        uint256[] memory amountsIn = new uint256[](_getTotalTokens());\n        // And then assign the result to the selected token\n        amountsIn[tokenIndex] = amountIn;\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _joinAllTokensInForExactBPTOut(uint256[] memory balances, bytes memory userData) private view returns (uint256, uint256[] memory) {\n        uint256 bptAmountOut = userData.allTokensInForExactBptOut();\n        // Note that there is no maximum amountsIn parameter: this is handled by `IVault.joinPool`.\n\n        uint256[] memory amountsIn = WeightedMath._calcAllTokensInGivenExactBptOut(balances, bptAmountOut, totalSupply());\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    // Exit\n\n    function _onExitPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        override\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex) = _getNormalizedWeightsAndMaxWeightIndex();\n\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\n        // out) remain functional.\n\n        if (_isNotPaused()) {\n            // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous\n            // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids\n            // spending gas calculating the fees on each individual swap.\n            uint256 invariantBeforeExit = WeightedMath._calculateInvariant(normalizedWeights, balances);\n            dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, normalizedWeights, maxWeightTokenIndex, _lastInvariant, invariantBeforeExit, protocolSwapFeePercentage);\n\n            // Update current balances by subtracting the protocol fee amounts\n            _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n        } else {\n            // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and\n            // reduce the potential for errors.\n            dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\n        }\n\n        (bptAmountIn, amountsOut) = _doExit(balances, normalizedWeights, scalingFactors, userData);\n\n        // Update the invariant with the balances the Pool will have after the exit, in order to compute the\n        // protocol swap fees due in future joins and exits.\n        _lastInvariant = _invariantAfterExit(balances, amountsOut, normalizedWeights);\n\n        return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);\n    }\n\n    function _doExit(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal returns (uint256, uint256[] memory) {\n        ExitKind kind = userData.exitKind();\n\n        if (kind == ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {\n            return _exitExactBPTInForTokenOut(balances, normalizedWeights, userData);\n        } else if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {\n            return _exitExactBPTInForTokensOut(balances, userData);\n        } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {\n            return _exitBPTInForExactTokensOut(balances, normalizedWeights, scalingFactors, userData);\n        } else {\n            _revert(Errors.UNHANDLED_EXIT_KIND);\n        }\n    }\n\n    function _exitExactBPTInForTokenOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private whenNotPaused returns (uint256, uint256[] memory) {\n        // This exit function is disabled if the contract is paused.\n\n        (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\n\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\n\n        (uint256 amountOut, uint256 swapFee) = WeightedMath._calcTokenOutGivenExactBptIn(balances[tokenIndex], normalizedWeights[tokenIndex], bptAmountIn, totalSupply(), getSwapFeePercentage());\n\n        // This is an exceptional situation in which the fee is charged on a token out instead of a token in.\n        // Note that swapFee is already upscaled.\n        _processSwapFeeAmount(tokenIndex, swapFee);\n\n        // We exit in a single token, so we initialize amountsOut with zeros\n        uint256[] memory amountsOut = new uint256[](_getTotalTokens());\n        // And then assign the result to the selected token\n        amountsOut[tokenIndex] = amountOut;\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData) private view returns (uint256, uint256[] memory) {\n        // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted\n        // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.\n        // This particular exit function is the only one that remains available because it is the simplest one, and\n        // therefore the one with the lowest likelihood of errors.\n\n        uint256 bptAmountIn = userData.exactBptInForTokensOut();\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\n\n        uint256[] memory amountsOut = WeightedMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _exitBPTInForExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) private whenNotPaused returns (uint256, uint256[] memory) {\n        // This exit function is disabled if the contract is paused.\n\n        (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();\n        InputHelpers.ensureInputLengthMatch(amountsOut.length, _getTotalTokens());\n        _upscaleArray(amountsOut, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory swapFees) = WeightedMath._calcBptInGivenExactTokensOut(balances, normalizedWeights, amountsOut, totalSupply(), getSwapFeePercentage());\n        _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);\n\n        // This is an exceptional situation in which the fee is charged on a token out instead of a token in.\n        // Note that swapFee is already upscaled.\n        _processSwapFeeAmounts(swapFees);\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    // Helpers\n\n    function _getDueProtocolFeeAmounts(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256 maxWeightTokenIndex,\n        uint256 previousInvariant,\n        uint256 currentInvariant,\n        uint256 protocolSwapFeePercentage\n    ) private view returns (uint256[] memory) {\n        // Initialize with zeros\n        uint256[] memory dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\n\n        // Early return if the protocol swap fee percentage is zero, saving gas.\n        if (protocolSwapFeePercentage == 0) {\n            return dueProtocolFeeAmounts;\n        }\n\n        // The protocol swap fees are always paid using the token with the largest weight in the Pool. As this is the\n        // token that is expected to have the largest balance, using it to pay fees should not unbalance the Pool.\n        dueProtocolFeeAmounts[maxWeightTokenIndex] = WeightedMath._calcDueTokenProtocolSwapFeeAmount(\n            balances[maxWeightTokenIndex],\n            normalizedWeights[maxWeightTokenIndex],\n            previousInvariant,\n            currentInvariant,\n            protocolSwapFeePercentage\n        );\n\n        return dueProtocolFeeAmounts;\n    }\n\n    /**\n     * @dev Returns the value of the invariant given `balances`, assuming they are increased by `amountsIn`. All\n     * amounts are expected to be upscaled.\n     */\n    function _invariantAfterJoin(\n        uint256[] memory balances,\n        uint256[] memory amountsIn,\n        uint256[] memory normalizedWeights\n    ) private view returns (uint256) {\n        _mutateAmounts(balances, amountsIn, FixedPoint.add);\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\n    }\n\n    function _invariantAfterExit(\n        uint256[] memory balances,\n        uint256[] memory amountsOut,\n        uint256[] memory normalizedWeights\n    ) private view returns (uint256) {\n        _mutateAmounts(balances, amountsOut, FixedPoint.sub);\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\n    }\n\n    /**\n     * @dev Mutates `amounts` by applying `mutation` with each entry in `arguments`.\n     *\n     * Equivalent to `amounts = amounts.map(mutation)`.\n     */\n    function _mutateAmounts(\n        uint256[] memory toMutate,\n        uint256[] memory arguments,\n        function(uint256, uint256) pure returns (uint256) mutation\n    ) private view {\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            toMutate[i] = mutation(toMutate[i], arguments[i]);\n        }\n    }\n\n    /**\n     * @dev This function returns the appreciation of one BPT relative to the\n     * underlying tokens. This starts at 1 when the pool is created and grows over time\n     */\n    function getRate() public view returns (uint256) {\n        // The initial BPT supply is equal to the invariant times the number of tokens.\n        return Math.mul(getInvariant(), _getTotalTokens()).divDown(totalSupply());\n    }\n}\n"
    },
    "contracts/libraries/helpers/InputHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nlibrary InputHelpers {\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\n        require(a == b, \"INPUT_LENGTH_MISMATCH\");\n    }\n\n    function ensureInputLengthMatch(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure {\n        require(a == b && b == c, \"INPUT_LENGTH_MISMATCH\");\n    }\n\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\n        address[] memory addressArray;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addressArray := array\n        }\n        ensureArrayIsSorted(addressArray);\n    }\n\n    function ensureArrayIsSorted(address[] memory array) internal pure {\n        if (array.length < 2) {\n            return;\n        }\n\n        address previous = array[0];\n        for (uint256 i = 1; i < array.length; ++i) {\n            address current = array[i];\n            require(previous < current, \"UNSORTED_ARRAY\");\n            previous = current;\n        }\n    }\n}\n"
    },
    "contracts/BaseMinimalSwapInfoPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BasePool.sol\";\nimport \"./interfaces/IMinimalSwapInfoPool.sol\";\n\n/**\n * @dev Extension of `BasePool`, adding a handler for `IMinimalSwapInfoPool.onSwap`.\n *\n * Derived contracts must call `BasePool`'s constructor, and implement `_onSwapGivenIn` and `_onSwapGivenOut` along with\n * `BasePool`'s virtual functions. Inheriting from this contract lets derived contracts choose the Two Token or Minimal\n * Swap Info specialization settings.\n */\nabstract contract BaseMinimalSwapInfoPool is IMinimalSwapInfoPool, BasePool {\n    // Swap Hooks\n\n    function onSwap(\n        SwapRequest memory request,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\n        uint256 scalingFactorTokenIn = _scalingFactor(request.tokenIn);\n        uint256 scalingFactorTokenOut = _scalingFactor(request.tokenOut);\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // Fees are subtracted before scaling, to reduce the complexity of the rounding direction analysis.\n            uint256 amountInMinusSwapFees = _subtractSwapFeeAmount(request.amount);\n\n            // Process the (upscaled!) swap fee.\n            uint256 swapFee = request.amount - amountInMinusSwapFees;\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\n\n            request.amount = amountInMinusSwapFees;\n\n            // All token amounts are upscaled.\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\n            request.amount = _upscale(request.amount, scalingFactorTokenIn);\n\n            uint256 amountOut = _onSwapGivenIn(request, balanceTokenIn, balanceTokenOut);\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactorTokenOut);\n        } else {\n            // All token amounts are upscaled.\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\n            request.amount = _upscale(request.amount, scalingFactorTokenOut);\n\n            uint256 amountIn = _onSwapGivenOut(request, balanceTokenIn, balanceTokenOut);\n\n            // amountIn tokens are entering the Pool, so we round up.\n            amountIn = _downscaleUp(amountIn, scalingFactorTokenIn);\n\n            // Fees are added after scaling happens, to reduce the complexity of the rounding direction analysis.\n            uint256 amountInPlusSwapFees = _addSwapFeeAmount(amountIn);\n\n            // Process the (upscaled!) swap fee.\n            uint256 swapFee = amountInPlusSwapFees - amountIn;\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\n\n            return amountInPlusSwapFees;\n        }\n    }\n\n    /*\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens entering the Pool is known.\n     *\n     * Returns the amount of tokens that will be taken from the Pool in return.\n     *\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled. The swap fee has already\n     * been deducted from `swapRequest.amount`.\n     *\n     * The return value is also considered upscaled, and will be downscaled (rounding down) before returning it to the\n     * Vault.\n     */\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) internal virtual returns (uint256);\n\n    /*\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens exiting the Pool is known.\n     *\n     * Returns the amount of tokens that will be granted to the Pool in return.\n     *\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled.\n     *\n     * The return value is also considered upscaled, and will be downscaled (rounding up) before applying the swap fee\n     * and returning it to the Vault.\n     */\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev Called whenever a swap fee is charged. Implementations should call their parents via super, to ensure all\n     * implementations in the inheritance tree are called.\n     *\n     * Callers must call one of the three `_processSwapFeeAmount` functions when swap fees are computed,\n     * and upscale `amount`.\n     */\n    function _processSwapFeeAmount(\n        uint256, /*index*/\n        uint256 /*amount*/\n    ) internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function _processSwapFeeAmount(IERC20 token, uint256 amount) internal {\n        _processSwapFeeAmount(_tokenAddressToIndex(token), amount);\n    }\n\n    function _processSwapFeeAmounts(uint256[] memory amounts) internal {\n        InputHelpers.ensureInputLengthMatch(amounts.length, _getTotalTokens());\n\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            _processSwapFeeAmount(i, amounts[i]);\n        }\n    }\n\n    /**\n     * @dev Returns the index of `token` in the Pool's token array (i.e. the one `vault.getPoolTokens()` would return).\n     *\n     * A trivial (and incorrect!) implementation is already provided for Pools that don't override\n     * `_processSwapFeeAmount` and skip the entire feature. However, Pools that do override `_processSwapFeeAmount`\n     * *must* override this function with a meaningful implementation.\n     */\n    function _tokenAddressToIndex(\n        IERC20 /*token*/\n    ) internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/libraries/weighted/WeightedMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./../math/FixedPoint.sol\";\nimport \"./../math/Math.sol\";\nimport \"../helpers/InputHelpers.sol\";\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\nlibrary WeightedMath {\n    using FixedPoint for uint256;\n    // A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n    // implementation of the power function, as these ratios are often exponents.\n    uint256 internal constant _MIN_WEIGHT = 0.01e18;\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n    uint256 internal constant _MAX_WEIGHTED_TOKENS = 100;\n\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n    // ratio).\n\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\n    uint256 internal constant _MAX_IN_RATIO = 0.3e18;\n    uint256 internal constant _MAX_OUT_RATIO = 0.3e18;\n\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\n    uint256 internal constant _MAX_INVARIANT_RATIO = 3e18;\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\n    uint256 internal constant _MIN_INVARIANT_RATIO = 0.7e18;\n\n    // About swap fees on joins and exits:\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n    // swap fees, it follows that (some) joins and exits should as well.\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n    // is the one to which swap fees are applied.\n\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\n    // and, because there is a minimum BPT, we round down the invariant.\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances)\n        internal\n        pure\n        returns (uint256 invariant)\n    {\n        /**********************************************************************************************\n        // invariant               _____                                                             //\n        // wi = weight index i      | |      wi                                                      //\n        // bi = balance index i     | |  bi ^   = i                                                  //\n        // i = invariant                                                                             //\n        **********************************************************************************************/\n\n        invariant = FixedPoint.ONE;\n        for (uint256 i = 0; i < normalizedWeights.length; i++) {\n            invariant = invariant.mulDown(balances[i].powDown(normalizedWeights[i]));\n        }\n\n        require(invariant > 0, \"ZERO_INVARIANT\");\n    }\n\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n    // current balances and weights.\n    function _calcOutGivenIn(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountIn\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // outGivenIn                                                                                //\n        // aO = amountOut                                                                            //\n        // bO = balanceOut                                                                           //\n        // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n        // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n        // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n        // wO = weightOut                                                                            //\n        **********************************************************************************************/\n\n        // Amount out, so we round down overall.\n\n        // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\n        // Because bI / (bI + aI) <= 1, the exponent rounds down.\n\n        // Cannot exceed maximum in ratio\n        require(amountIn <= balanceIn.mulDown(_MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        uint256 denominator = balanceIn.add(amountIn);\n        uint256 base = balanceIn.divUp(denominator);\n        uint256 exponent = weightIn.divDown(weightOut);\n        uint256 power = base.powUp(exponent);\n\n        return balanceOut.mulDown(power.complement());\n    }\n\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n    // current balances and weights.\n    function _calcInGivenOut(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountOut\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // inGivenOut                                                                                //\n        // aO = amountOut                                                                            //\n        // bO = balanceOut                                                                           //\n        // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n        // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n        // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n        // wO = weightOut                                                                            //\n        **********************************************************************************************/\n\n        // Amount in, so we round up overall.\n\n        // The multiplication rounds up, and the power rounds up (so the base rounds up too).\n        // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\n\n        // Cannot exceed maximum out ratio\n        require(amountOut <= balanceOut.mulDown(_MAX_OUT_RATIO), \"MAX_OUT_RATIO\");\n\n        uint256 base = balanceOut.divUp(balanceOut.sub(amountOut));\n        uint256 exponent = weightOut.divUp(weightIn);\n        uint256 power = base.powUp(exponent);\n\n        // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n        // the following subtraction should never revert.\n        uint256 ratio = power.sub(FixedPoint.ONE);\n\n        return balanceIn.mulUp(ratio);\n    }\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256, uint256[] memory) {\n        // BPT out, so we round down overall.\n\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\n\n        uint256 invariantRatioWithFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\n            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));\n        }\n\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeJoinExactTokensInInvariantRatio(\n            balances,\n            normalizedWeights,\n            amountsIn,\n            balanceRatiosWithFee,\n            invariantRatioWithFees,\n            swapFeePercentage\n        );\n\n        uint256 bptOut = (invariantRatio > FixedPoint.ONE)\n            ? bptTotalSupply.mulDown(invariantRatio.sub(FixedPoint.ONE))\n            : 0;\n        return (bptOut, swapFees);\n    }\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    function _computeJoinExactTokensInInvariantRatio(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256[] memory balanceRatiosWithFee,\n        uint256 invariantRatioWithFees,\n        uint256 swapFeePercentage\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\n        // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\n        // increase.\n        swapFees = new uint256[](amountsIn.length);\n        invariantRatio = FixedPoint.ONE;\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 amountInWithoutFee;\n\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));\n                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n                uint256 swapFee = taxableAmount.mulUp(swapFeePercentage);\n\n                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.sub(swapFee));\n                swapFees[i] = swapFee;\n            } else {\n                amountInWithoutFee = amountsIn[i];\n            }\n\n            uint256 balanceRatio = balances[i].add(amountInWithoutFee).divDown(balances[i]);\n\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\n        }\n    }\n\n    function _calcTokenInGivenExactBptOut(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256 amountIn, uint256 swapFee) {\n        /******************************************************************************************\n        // tokenInForExactBPTOut                                                                 //\n        // a = amountIn                                                                          //\n        // b = balance                      /  /    totalBPT + bptOut      \\    (1 / w)       \\  //\n        // bptOut = bptAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\n        // bpt = totalBPT                   \\  \\       totalBPT            /                  /  //\n        // w = weight                                                                            //\n        ******************************************************************************************/\n\n        // Token in, so we round up overall.\n\n        // Calculate the factor by which the invariant will increase after minting BPTAmountOut\n        uint256 invariantRatio = bptTotalSupply.add(bptAmountOut).divUp(bptTotalSupply);\n        require(invariantRatio <= _MAX_INVARIANT_RATIO, \"MAX_OUT_BPT_FOR_TOKEN_IN\");\n\n        // Calculate by how much the token balance has to increase to match the invariantRatio\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divUp(normalizedWeight));\n\n        uint256 amountInWithoutFee = balance.mulUp(balanceRatio.sub(FixedPoint.ONE));\n\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n        // accordingly.\n        uint256 taxablePercentage = normalizedWeight.complement();\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n        uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE.sub(swapFeePercentage));\n\n        swapFee = taxableAmountPlusFees - taxableAmount;\n        amountIn = nonTaxableAmount.add(taxableAmountPlusFees);\n    }\n\n    function _calcAllTokensInGivenExactBptOut(\n        uint256[] memory balances,\n        uint256 bptAmountOut,\n        uint256 totalBPT\n    ) internal pure returns (uint256[] memory) {\n        /************************************************************************************\n        // tokensInForExactBptOut                                                          //\n        // (per token)                                                                     //\n        // aI = amountIn                   /   bptOut   \\                                  //\n        // b = balance           aI = b * | ------------ |                                 //\n        // bptOut = bptAmountOut           \\  totalBPT  /                                  //\n        // bpt = totalBPT                                                                  //\n        ************************************************************************************/\n\n        // Tokens in, so we round up overall.\n        uint256 bptRatio = bptAmountOut.divUp(totalBPT);\n\n        uint256[] memory amountsIn = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsIn[i] = balances[i].mulUp(bptRatio);\n        }\n\n        return amountsIn;\n    }\n\n    function _calcBptInGivenExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256, uint256[] memory) {\n        // BPT in, so we round up overall.\n\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\n        uint256 invariantRatioWithoutFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);\n            invariantRatioWithoutFees = invariantRatioWithoutFees.add(\n                balanceRatiosWithoutFee[i].mulUp(normalizedWeights[i])\n            );\n        }\n\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeExitExactTokensOutInvariantRatio(\n            balances,\n            normalizedWeights,\n            amountsOut,\n            balanceRatiosWithoutFee,\n            invariantRatioWithoutFees,\n            swapFeePercentage\n        );\n\n        uint256 bptIn = bptTotalSupply.mulUp(invariantRatio.complement());\n        return (bptIn, swapFees);\n    }\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    function _computeExitExactTokensOutInvariantRatio(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256[] memory balanceRatiosWithoutFee,\n        uint256 invariantRatioWithoutFees,\n        uint256 swapFeePercentage\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\n        swapFees = new uint256[](amountsOut.length);\n        invariantRatio = FixedPoint.ONE;\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n            // 'token out'. This results in slightly larger price impact.\n\n            uint256 amountOutWithFee;\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\n                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n                uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE.sub(swapFeePercentage));\n\n                swapFees[i] = taxableAmountPlusFees - taxableAmount;\n                amountOutWithFee = nonTaxableAmount.add(taxableAmountPlusFees);\n            } else {\n                amountOutWithFee = amountsOut[i];\n            }\n\n            uint256 balanceRatio = balances[i].sub(amountOutWithFee).divDown(balances[i]);\n\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\n        }\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256 amountOut, uint256 swapFee) {\n        /*****************************************************************************************\n        // exactBPTInForTokenOut                                                                //\n        // a = amountOut                                                                        //\n        // b = balance                     /      /    totalBPT - bptIn       \\    (1 / w)  \\   //\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n        // bpt = totalBPT                  \\      \\       totalBPT            /             /   //\n        // w = weight                                                                           //\n        *****************************************************************************************/\n\n        // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n        // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\n\n        // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n        uint256 invariantRatio = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply);\n        require(invariantRatio >= _MIN_INVARIANT_RATIO, \"MIN_BPT_IN_FOR_TOKEN_OUT\");\n\n        // Calculate by how much the token balance has to decrease to match invariantRatio\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\n\n        // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n        uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\n\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n        // in swap fees.\n        uint256 taxablePercentage = normalizedWeight.complement();\n\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n        swapFee = taxableAmount.mulUp(swapFeePercentage);\n        amountOut = nonTaxableAmount.add(taxableAmount.sub(swapFee));\n    }\n\n    function _calcTokensOutGivenExactBptIn(\n        uint256[] memory balances,\n        uint256 bptAmountIn,\n        uint256 totalBPT\n    ) internal pure returns (uint256[] memory) {\n        /**********************************************************************************************\n        // exactBPTInForTokensOut                                                                    //\n        // (per token)                                                                               //\n        // aO = amountOut                  /        bptIn         \\                                  //\n        // b = balance           a0 = b * | ---------------------  |                                 //\n        // bptIn = bptAmountIn             \\       totalBPT       /                                  //\n        // bpt = totalBPT                                                                            //\n        **********************************************************************************************/\n\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\n        // multiplication and division.\n\n        uint256 bptRatio = bptAmountIn.divDown(totalBPT);\n\n        uint256[] memory amountsOut = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsOut[i] = balances[i].mulDown(bptRatio);\n        }\n\n        return amountsOut;\n    }\n\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 previousInvariant,\n        uint256 currentInvariant,\n        uint256 protocolSwapFeePercentage\n    ) internal pure returns (uint256) {\n        /*********************************************************************************\n        /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\n        *********************************************************************************/\n\n        if (currentInvariant <= previousInvariant) {\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n            return 0;\n        }\n\n        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n        // fees to the Vault.\n\n        // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\n        // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\n\n        uint256 base = previousInvariant.divUp(currentInvariant);\n        uint256 exponent = FixedPoint.ONE.divDown(normalizedWeight);\n\n        // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\n        // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\n        // 1 / min exponent) the Pool will pay less in protocol fees than it should.\n        base = Math.max(base, FixedPoint.MIN_POW_BASE_FREE_EXPONENT);\n\n        uint256 power = base.powUp(exponent);\n\n        uint256 tokenAccruedFees = balance.mulDown(power.complement());\n        return tokenAccruedFees.mulDown(protocolSwapFeePercentage);\n    }\n}\n"
    },
    "contracts/libraries/weighted/WeightedPoolUserDataHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nimport \"../../BaseWeightedPool.sol\";\n\nlibrary WeightedPoolUserDataHelpers {\n    function joinKind(bytes memory self) internal pure returns (BaseWeightedPool.JoinKind) {\n        return abi.decode(self, (BaseWeightedPool.JoinKind));\n    }\n\n    function exitKind(bytes memory self) internal pure returns (BaseWeightedPool.ExitKind) {\n        return abi.decode(self, (BaseWeightedPool.ExitKind));\n    }\n\n    // Joins\n\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\n        (, amountsIn) = abi.decode(self, (BaseWeightedPool.JoinKind, uint256[]));\n    }\n\n    function exactTokensInForBptOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\n    {\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (BaseWeightedPool.JoinKind, uint256[], uint256));\n    }\n\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (BaseWeightedPool.JoinKind, uint256, uint256));\n    }\n\n    function allTokensInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut) {\n        (, bptAmountOut) = abi.decode(self, (BaseWeightedPool.JoinKind, uint256));\n    }\n\n    // Exits\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (BaseWeightedPool.ExitKind, uint256, uint256));\n    }\n\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\n        (, bptAmountIn) = abi.decode(self, (BaseWeightedPool.ExitKind, uint256));\n    }\n\n    function bptInForExactTokensOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\n    {\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (BaseWeightedPool.ExitKind, uint256[], uint256));\n    }\n}\n"
    },
    "contracts/BasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./libraries/helpers/TemporarilyPausable.sol\";\nimport \"./libraries/helpers/WordCodec.sol\";\nimport \"./libraries/ERC20.sol\";\n\n// import \"./interfaces/IVault.sol\";\nimport \"./interfaces/IBasePool.sol\";\n\nimport \"./interfaces/IAssetManager.sol\";\n\nimport \"./RequiemPoolToken.sol\";\nimport \"./BasePoolAuthorization.sol\";\n\n// solhint-disable max-states-count\n\n/**\n * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with optional\n * Asset Managers, an admin-controlled swap fee percentage, and an emergency pause mechanism.\n *\n * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that\n * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the\n * `whenNotPaused` modifier.\n *\n * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.\n *\n * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from\n * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces\n * and implement the swap callbacks themselves.\n */\nabstract contract BasePool is IBasePool, BasePoolAuthorization, RequiemPoolToken, TemporarilyPausable {\n    using WordCodec for bytes32;\n    using FixedPoint for uint256;\n\n    uint256 private constant _MIN_TOKENS = 2;\n\n    uint256 private constant _MINIMUM_BPT = 1e6;\n\n    // 1e18 corresponds to 1.0, or a 100% fee\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits\n\n    // Storage slot that can be used to store unrelated pieces of information. In particular, by default is used\n    // to store only the swap fee percentage of a pool. But it can be extended to store some more pieces of information.\n    // The swap fee percentage is stored in the most-significant 64 bits, therefore the remaining 192 bits can be\n    // used to store any other piece of information.\n    bytes32 private _miscData;\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;\n\n    bytes32 private immutable _poolId;\n\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\n\n    constructor(\n        IVault vault,\n        IVault.PoolSpecialization specialization,\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        // Base Pools are expected to be deployed using factories. By using the factory address as the action\n        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for\n        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in\n        // any Pool created by the same factory), while still making action identifiers unique among different factories\n        // if the selectors match, preventing accidental errors.\n        Authentication(bytes32(uint256(uint160(msg.sender)) << 96))\n        RequiemPoolToken(name, symbol, vault)\n        BasePoolAuthorization(owner)\n        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)\n    {\n        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);\n        _require(tokens.length <= _getMaxTokens(), Errors.MAX_TOKENS);\n\n        // The Vault only requires the token list to be ordered for the Two Token Pools specialization. However,\n        // to make the developer experience consistent, we are requiring this condition for all the native pools.\n        // Also, since these Pools will register tokens only once, we can ensure the Pool tokens will follow the same\n        // order. We rely on this property to make Pools simpler to write, as it lets us assume that the\n        // order of token-specific parameters (such as token weights) will not change.\n        InputHelpers.ensureArrayIsSorted(tokens);\n\n        _setSwapFeePercentage(swapFeePercentage);\n\n        bytes32 poolId = vault.registerPool(specialization);\n\n        vault.registerTokens(poolId, tokens, assetManagers);\n\n        // Set immutable state variables - these cannot be read from during construction\n        _poolId = poolId;\n    }\n\n    // Getters / Setters\n\n    function getPoolId() public view override returns (bytes32) {\n        return _poolId;\n    }\n\n    function _getTotalTokens() internal view virtual returns (uint256);\n\n    function _getMaxTokens() internal pure virtual returns (uint256);\n\n    function _getMinimumBpt() internal pure virtual returns (uint256) {\n        return _MINIMUM_BPT;\n    }\n\n    function getSwapFeePercentage() public view returns (uint256) {\n        return _miscData.decodeUint64(_SWAP_FEE_PERCENTAGE_OFFSET);\n    }\n\n    function setSwapFeePercentage(uint256 swapFeePercentage) external virtual authenticate whenNotPaused {\n        _setSwapFeePercentage(swapFeePercentage);\n    }\n\n    function _setSwapFeePercentage(uint256 swapFeePercentage) private {\n        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);\n        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);\n\n        _miscData = _miscData.insertUint64(swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET);\n        emit SwapFeePercentageChanged(swapFeePercentage);\n    }\n\n    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n        public\n        virtual\n        authenticate\n        whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }\n\n    function _setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig) private {\n        bytes32 poolId = getPoolId();\n        (, , , address assetManager) = getVault().getPoolTokenInfo(poolId, token);\n\n        IAssetManager(assetManager).setConfig(poolId, poolConfig);\n    }\n\n    function setPaused(bool paused) external authenticate {\n        _setPaused(paused);\n    }\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\n        return\n            (actionId == getActionId(this.setSwapFeePercentage.selector)) ||\n            (actionId == getActionId(this.setAssetManagerPoolConfig.selector));\n    }\n\n    function _getMiscData() internal view returns (bytes32) {\n        return _miscData;\n    }\n\n    /**\n     * Inserts data into the least-significant 192 bits of the misc data storage slot.\n     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.\n     */\n    function _setMiscData(bytes32 newData) internal {\n        _miscData = _miscData.insertBits192(newData, 0);\n    }\n\n    // Join / Exit Hooks\n\n    modifier onlyVault(bytes32 poolId) {\n        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);\n        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);\n        _;\n    }\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\n            // Pool from ever being fully drained.\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _getMinimumBpt());\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }\n\n    // Query functions\n\n    /**\n     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }\n\n    /**\n     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }\n\n    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are\n    // upscaled.\n\n    /**\n     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.\n     *\n     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.\n     *\n     * Minted BPT will be sent to `recipient`, except for _getMinimumBpt(), which will be deducted from this amount and\n     * sent to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP\n     * from ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire\n     * Pool's lifetime.\n     *\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\n     * be downscaled (rounding up) before being returned to the Vault.\n     */\n    function _onInitializePool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);\n\n    /**\n     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).\n     *\n     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of\n     * tokens to pay in protocol swap fees.\n     *\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\n     *\n     * Minted BPT will be sent to `recipient`.\n     *\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\n     * be downscaled (rounding up) before being returned to the Vault.\n     *\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\n     */\n    function _onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        returns (\n            uint256 bptAmountOut,\n            uint256[] memory amountsIn,\n            uint256[] memory dueProtocolFeeAmounts\n        );\n\n    /**\n     * @dev Called whenever the Pool is exited.\n     *\n     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and\n     * the number of tokens to pay in protocol swap fees.\n     *\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\n     *\n     * BPT will be burnt from `sender`.\n     *\n     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled\n     * (rounding down) before being returned to the Vault.\n     *\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\n     */\n    function _onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOut,\n            uint256[] memory dueProtocolFeeAmounts\n        );\n\n    // Internal functions\n\n    /**\n     * @dev Adds swap fee amount to `amount`, returning a higher value.\n     */\n    function _addSwapFeeAmount(uint256 amount) internal view returns (uint256) {\n        // This returns amount + fee amount, so we round up (favoring a higher fee amount).\n        return amount.divUp(FixedPoint.ONE.sub(getSwapFeePercentage()));\n    }\n\n    /**\n     * @dev Subtracts swap fee amount from `amount`, returning a lower value.\n     */\n    function _subtractSwapFeeAmount(uint256 amount) internal view returns (uint256) {\n        // This returns amount - fee amount, so we round up (favoring a higher fee amount).\n        uint256 feeAmount = amount.mulUp(getSwapFeePercentage());\n        return amount.sub(feeAmount);\n    }\n\n    // Scaling\n\n    /**\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n     * it had 18 decimals.\n     */\n    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {\n        if (address(token) == address(this)) {\n            return FixedPoint.ONE;\n        }\n\n        // Tokens that don't implement the `decimals` method are not supported.\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\n\n        // Tokens with more than 18 decimals are not supported.\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\n        return FixedPoint.ONE * 10**decimalsDifference;\n    }\n\n    /**\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\n     * Pool.\n     *\n     * All scaling factors are fixed-point values with 18 decimals, to allow for this function to be overridden by\n     * derived contracts that need to apply further scaling, making these factors potentially non-integer.\n     *\n     * The largest 'base' scaling factor (i.e. in tokens with less than 18 decimals) is 10**18, which in fixed-point is\n     * 10**36. This value can be multiplied with a 112 bit Vault balance with no overflow by a factor of ~1e7, making\n     * even relatively 'large' factors safe to use.\n     *\n     * The 1e7 figure is the result of 2**256 / (1e18 * 1e18 * 2**112).\n     */\n    function _scalingFactor(IERC20 token) internal view virtual returns (uint256);\n\n    /**\n     * @dev Same as `_scalingFactor()`, except for all registered tokens (in the same order as registered). The Vault\n     * will always pass balances in this order when calling any of the Pool hooks.\n     */\n    function _scalingFactors() internal view virtual returns (uint256[] memory);\n\n    function getScalingFactors() external view returns (uint256[] memory) {\n        return _scalingFactors();\n    }\n\n    /**\n     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\n     * scaling or not.\n     */\n    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of\n        // token in should be rounded up, and that of token out rounded down. This is the only place where we round in\n        // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no\n        // rounding error unless `_scalingFactor()` is overriden).\n        return FixedPoint.mulDown(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\n     * the `amounts` array.\n     */\n    function _upscaleArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            amounts[i] = FixedPoint.mulDown(amounts[i], scalingFactors[i]);\n        }\n    }\n\n    /**\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n     * whether it needed scaling or not. The result is rounded down.\n     */\n    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        return FixedPoint.divDown(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\n     * *mutates* the `amounts` array.\n     */\n    function _downscaleDownArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            amounts[i] = FixedPoint.divDown(amounts[i], scalingFactors[i]);\n        }\n    }\n\n    /**\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n     * whether it needed scaling or not. The result is rounded up.\n     */\n    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        return FixedPoint.divUp(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\n     * *mutates* the `amounts` array.\n     */\n    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            amounts[i] = FixedPoint.divUp(amounts[i], scalingFactors[i]);\n        }\n    }\n\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\n        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which\n        // accounts can call permissioned functions: for example, to perform emergency pauses.\n        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under\n        // Governance control.\n        return getVault().getAuthorizer();\n    }\n\n    function _queryAction(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)\n            internal\n            returns (uint256, uint256[] memory, uint256[] memory) _action,\n        function(uint256[] memory, uint256[] memory) internal view _downscaleArray\n    ) private {\n        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed\n        // explanation.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the bpt and token amounts from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of the\n                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded\n                        // representation of these.\n                        // An ABI-encoded response will include one additional field to indicate the starting offset of\n                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the\n                        // returndata.\n                        //\n                        // In returndata:\n                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]\n                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]\n                        //\n                        // We now need to return (ABI-encoded values):\n                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]\n                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]\n\n                        // We copy 32 bytes for the `bptAmount` from returndata into memory.\n                        // Note that we skip the first 4 bytes for the error signature\n                        returndatacopy(0, 0x04, 32)\n\n                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after\n                        // the initial 64 bytes.\n                        mstore(0x20, 64)\n\n                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.\n                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also\n                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.\n                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))\n\n                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to\n                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the\n                        // error signature.\n                        return(0, add(returndatasize(), 28))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn't happen\n                        invalid()\n                    }\n            }\n        } else {\n            uint256[] memory scalingFactors = _scalingFactors();\n            _upscaleArray(balances, scalingFactors);\n\n            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            _downscaleArray(tokenAmounts, scalingFactors);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of\n                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values\n                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32\n                let size := mul(mload(tokenAmounts), 32)\n\n                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there\n                // will be at least one available slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                let start := sub(tokenAmounts, 0x20)\n                mstore(start, bptAmount)\n\n                // We send one extra value for the error signature \"QueryError(uint256,uint256[])\" which is 0x43adbafb\n                // We use the previous slot to `bptAmount`.\n                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)\n                start := sub(start, 0x04)\n\n                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return\n                // the `bptAmount`, the array 's length, and the error signature.\n                revert(start, add(size, 68))\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMinimalSwapInfoPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IBasePool.sol\";\n\n/**\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\n * to the pool in a 'given out' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IMinimalSwapInfoPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/libraries/helpers/TemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ITemporarilyPausable.sol\";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausable is ITemporarilyPausable {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, \"MAX_PAUSE_WINDOW_DURATION\");\n        require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, \"MAX_BUFFER_PERIOD_DURATION\");\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPaused() {\n        _ensureNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedState()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPaused();\n        pauseWindowEndTime = _getPauseWindowEndTime();\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPaused(bool paused) internal {\n        if (paused) {\n            require(block.timestamp < _getPauseWindowEndTime(), \"PAUSE_WINDOW_EXPIRED\");\n        } else {\n            require(block.timestamp < _getBufferPeriodEndTime(), \"BUFFER_PERIOD_EXPIRED\");\n        }\n\n        _paused = paused;\n        emit PausedStateChanged(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPaused() internal view {\n        require(_isNotPaused(), \"PAUSED\");\n    }\n\n    /**\n     * @dev Reverts if the contract is not paused.\n     */\n    function _ensurePaused() internal view {\n        require(!_isNotPaused(), \"NOT_PAUSED\");\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPaused() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTime() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTime() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n"
    },
    "contracts/libraries/helpers/WordCodec.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n *\n * We could use Solidity structs to pack values together in a single storage slot instead of relying on a custom and\n * error-prone library, but unfortunately Solidity only allows for structs to live in either storage, calldata or\n * memory. Because a memory struct uses not just memory but also a slot in the stack (to store its memory location),\n * using memory for word-sized values (i.e. of 256 bits or less) is strictly less gas performant, and doesn't even\n * prevent stack-too-deep issues. This is compounded by the fact that Balancer contracts typically are memory-intensive,\n * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and\n * unpacking is therefore the preferred approach.\n */\nlibrary WordCodec {\n    // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,\n    // or to insert a new one replacing the old.\n    uint256 private constant _MASK_1 = 2**(1) - 1;\n    uint256 private constant _MASK_5 = 2**(5) - 1;\n    uint256 private constant _MASK_7 = 2**(7) - 1;\n    uint256 private constant _MASK_10 = 2**(10) - 1;\n    uint256 private constant _MASK_16 = 2**(16) - 1;\n    uint256 private constant _MASK_22 = 2**(22) - 1;\n    uint256 private constant _MASK_31 = 2**(31) - 1;\n    uint256 private constant _MASK_32 = 2**(32) - 1;\n    uint256 private constant _MASK_53 = 2**(53) - 1;\n    uint256 private constant _MASK_64 = 2**(64) - 1;\n    uint256 private constant _MASK_128 = 2**(128) - 1;\n    uint256 private constant _MASK_192 = 2**(192) - 1;\n\n    // Largest positive values that can be represented as N bits signed integers.\n    int256 private constant _MAX_INT_22 = 2**(21) - 1;\n    int256 private constant _MAX_INT_53 = 2**(52) - 1;\n\n    // In-place insertion\n\n    /**\n     * @dev Inserts a boolean value shifted by an offset into a 256 bit word, replacing the old value. Returns the new\n     * word.\n     */\n    function insertBool(\n        bytes32 word,\n        bool value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));\n        return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Inserts a 5 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 5 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint5(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_5 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 7 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 7 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint7(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_7 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 10 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 10 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint10(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_10 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 16 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value.\n     * Returns the new word.\n     *\n     * Assumes `value` only uses its least significant 16 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint16(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_16 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 31 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 31 bits.\n     */\n    function insertUint31(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_31 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 32 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 32 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint32(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_32 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 64 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 64 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint64(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_64 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Inserts a 22 bits signed integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 22 bits.\n     */\n    function insertInt22(\n        bytes32 word,\n        int256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_22 << offset));\n        // Integer values need masking to remove the upper bits of negative values.\n        return clearedWord | bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    // Bytes\n\n    /**\n     * @dev Inserts 192 bit shifted by an offset into a 256 bit word, replacing the old value. Returns the new word.\n     *\n     * Assumes `value` can be represented using 192 bits.\n     */\n    function insertBits192(\n        bytes32 word,\n        bytes32 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));\n        return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);\n    }\n\n    // Encoding\n\n    // Unsigned\n\n    /**\n     * @dev Encodes an unsigned integer shifted by an offset. This performs no size checks: it is up to the caller to\n     * ensure that the values are bounded.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeUint(uint256 value, uint256 offset) internal pure returns (bytes32) {\n        return bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Encodes a 22 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt22(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    /**\n     * @dev Encodes a 53 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt53(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_53) << offset);\n    }\n\n    // Decoding\n\n    /**\n     * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.\n     */\n    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {\n        return (uint256(word >> offset) & _MASK_1) == 1;\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Decodes and returns a 5 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint5(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_5;\n    }\n\n    /**\n     * @dev Decodes and returns a 7 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint7(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_7;\n    }\n\n    /**\n     * @dev Decodes and returns a 10 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint10(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_10;\n    }\n\n    /**\n     * @dev Decodes and returns a 16 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint16(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_16;\n    }\n\n    /**\n     * @dev Decodes and returns a 31 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint31(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_31;\n    }\n\n    /**\n     * @dev Decodes and returns a 32 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint32(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_32;\n    }\n\n    /**\n     * @dev Decodes and returns a 64 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint64(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_64;\n    }\n\n    /**\n     * @dev Decodes and returns a 128 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint128(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_128;\n    }\n\n    // Signed\n\n    /**\n     * @dev Decodes and returns a 22 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt22(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_22);\n        // In case the decoded value is greater than the max positive integer that can be represented with 22 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n        return value > _MAX_INT_22 ? (value | int256(~_MASK_22)) : value;\n    }\n\n    /**\n     * @dev Decodes and returns a 53 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt53(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_53);\n        // In case the decoded value is greater than the max positive integer that can be represented with 53 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n\n        return value > _MAX_INT_53 ? (value | int256(~_MASK_53)) : value;\n    }\n}\n"
    },
    "contracts/interfaces/IBasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IVault.sol\";\nimport \"./IPoolSwapStructs.sol\";\n\n/**\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\n * either IGeneralPool or IMinimalSwapInfoPool\n */\ninterface IBasePool is IPoolSwapStructs {\n    /**\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\n     *\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\n     * designated to receive any benefits (typically pool shares). `balances` contains the total balances\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as minting pool shares.\n     */\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\n\n    /**\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\n     * `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\n     *\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\n     * to which the Vault will send the proceeds. `balances` contains the total token balances for each token\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as burning pool shares.\n     */\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\n\n    function getPoolId() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IAssetManager {\n    /**\n     * @notice Emitted when asset manager is rebalanced\n     */\n    event Rebalance(bytes32 poolId);\n\n    /**\n     * @notice Sets the config\n     */\n    function setConfig(bytes32 poolId, bytes calldata config) external;\n\n    /**\n     * Note: No function to read the asset manager config is included in IAssetManager\n     * as the signature is expected to vary between asset manager implementations\n     */\n\n    /**\n     * @notice Returns the asset manager's token\n     */\n    function getToken() external view returns (IERC20);\n\n    /**\n     * @return the current assets under management of this asset manager\n     */\n    function getAUM(bytes32 poolId) external view returns (uint256);\n\n    /**\n     * @return poolCash - The up-to-date cash balance of the pool\n     * @return poolManaged - The up-to-date managed balance of the pool\n     */\n    function getPoolBalances(bytes32 poolId) external view returns (uint256 poolCash, uint256 poolManaged);\n\n    /**\n     * @return The difference in tokens between the target investment\n     * and the currently invested amount (i.e. the amount that can be invested)\n     */\n    function maxInvestableBalance(bytes32 poolId) external view returns (int256);\n\n    /**\n     * @notice Updates the Vault on the value of the pool's investment returns\n     */\n    function updateBalanceOfPool(bytes32 poolId) external;\n\n    /**\n     * @notice Determines whether the pool should rebalance given the provided balances\n     */\n    function shouldRebalance(uint256 cash, uint256 managed) external view returns (bool);\n\n    /**\n     * @notice Rebalances funds between the pool and the asset manager to maintain target investment percentage.\n     * @param poolId - the poolId of the pool to be rebalanced\n     * @param force - a boolean representing whether a rebalance should be forced even when the pool is near balance\n     */\n    function rebalance(bytes32 poolId, bool force) external;\n\n    /**\n     * @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\n     * @param poolId - the poolId of the pool to withdraw funds back to\n     * @param amount - the amount of tokens to withdraw back to the pool\n     */\n    function capitalOut(bytes32 poolId, uint256 amount) external;\n}\n"
    },
    "contracts/RequiemPoolToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/ERC20.sol\";\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Highly opinionated token implementation\n * @author Balancer Labs\n * @dev\n * - Includes functions to increase and decrease allowance as a workaround\n *   for the well-known issue with `approve`:\n *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n * - Allows for 'infinite allowance', where an allowance of 0xff..ff is not\n *   decreased by calls to transferFrom\n * - Lets a token holder use `transferFrom` to send their own tokens,\n *   without first setting allowance\n * - Emits 'Approval' events whenever allowance is changed by `transferFrom`\n * - Assigns infinite allowance for all token holders to the Vault\n */\ncontract RequiemPoolToken is ERC20, ERC20Permit {\n    IVault private immutable _vault;\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        IVault vault\n    ) ERC20(tokenName, tokenSymbol) ERC20Permit(tokenName) {\n        _vault = vault;\n    }\n\n    function getVault() public view returns (IVault) {\n        return _vault;\n    }\n\n    // Overrides\n\n    /**\n     * @dev Override to grant the Vault infinite allowance, causing for Pool Tokens to not require approval.\n     *\n     * This is sound as the Vault already provides authorization mechanisms when initiation token transfers, which this\n     * contract inherits.\n     */\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        if (spender == address(getVault())) {\n            return type(uint128).max;\n        } else {\n            return super.allowance(owner, spender);\n        }\n    }\n\n    /**\n     * @dev Override to allow for 'infinite allowance' and let the token owner use `transferFrom` with no self-allowance\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = allowance(sender, msg.sender);\n        require(msg.sender == sender || currentAllowance >= amount, \"ERC20_TRANSFER_EXCEEDS_ALLOWANCE\");\n\n        _transfer(sender, recipient, amount);\n\n        if (msg.sender != sender && currentAllowance != type(uint128).max) {\n            // Because of the previous require, we know that if msg.sender != sender then currentAllowance >= amount\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Override to allow decreasing allowance by more than the current amount (setting it to zero)\n     */\n    function decreaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        uint256 currentAllowance = allowance(msg.sender, spender);\n\n        if (amount >= currentAllowance) {\n            _approve(msg.sender, spender, 0);\n        } else {\n            // No risk of underflow due to if condition\n            _approve(msg.sender, spender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    // Internal functions\n\n    function _mintPoolTokens(address recipient, uint256 amount) internal {\n        _mint(recipient, amount);\n    }\n\n    function _burnPoolTokens(address sender, uint256 amount) internal {\n        _burn(sender, amount);\n    }\n}\n"
    },
    "contracts/BasePoolAuthorization.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/helpers/Authentication.sol\";\nimport \"./interfaces/IAuthorizer.sol\";\n\n// import \"./BasePool.sol\";\n\n/**\n * @dev Base authorization layer implementation for Pools.\n *\n * The owner account can call some of the permissioned functions - access control of the rest is delegated to the\n * Authorizer. Note that this owner is immutable: more sophisticated permission schemes, such as multiple ownership,\n * granular roles, etc., could be built on top of this by making the owner a smart contract.\n *\n * Access control of all other permissioned functions is delegated to an Authorizer. It is also possible to delegate\n * control of *all* permissioned functions to the Authorizer by setting the owner address to `_DELEGATE_OWNER`.\n */\nabstract contract BasePoolAuthorization is Authentication {\n    address private immutable _owner;\n\n    address private constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;\n\n    constructor(address owner) {\n        _owner = owner;\n    }\n\n    function getOwner() public view returns (address) {\n        return _owner;\n    }\n\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _getAuthorizer();\n    }\n\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\n        if ((getOwner() != _DELEGATE_OWNER) && _isOwnerOnlyAction(actionId)) {\n            // Only the owner can perform \"owner only\" actions, unless the owner is delegated.\n            return msg.sender == getOwner();\n        } else {\n            // Non-owner actions are always processed via the Authorizer, as \"owner only\" ones are when delegated.\n            return _getAuthorizer().canPerform(actionId, account, address(this));\n        }\n    }\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual returns (bool);\n\n    function _getAuthorizer() internal view virtual returns (IAuthorizer);\n}\n"
    },
    "contracts/interfaces/ITemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausable {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChanged(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedState()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n"
    },
    "contracts/interfaces/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20/IERC20.sol\";\n\nimport \"./IVault.sol\";\n\ninterface IPoolSwapStructs {\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\n    // IMinimalSwapInfoPool.\n    //\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\n    //\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\n    //\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\n    // some Pools.\n    //\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\n    // one Pool.\n    //\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\n    //    balance.\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\n    //\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\n    // where the Pool sends the outgoing tokens.\n    //\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Permit.sol\";\nimport \"./EIP712.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    mapping(address => uint256) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"EXPIRED_PERMIT\");\n\n        uint256 nonce = _nonces[owner];\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ecrecover(hash, v, r, s);\n        require((signer != address(0)) && (signer == owner), \"INVALID_SIGNATURE\");\n\n        _nonces[owner] = nonce + 1;\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/Authentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"./IAuthentication.sol\";\n\n/**\n * @dev Building block for performing access control on external functions.\n *\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\n * to external functions to only make them callable by authorized accounts.\n *\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\n */\nabstract contract Authentication is IAuthentication {\n    bytes32 private immutable _actionIdDisambiguator;\n\n    /**\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\n     * multi contract systems.\n     *\n     * There are two main uses for it:\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\n     *    unique. The contract's own address is a good option.\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\n     *    shared by the entire family (and no other contract) should be used instead.\n     */\n    constructor(bytes32 actionIdDisambiguator) {\n        _actionIdDisambiguator = actionIdDisambiguator;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\n     */\n    modifier authenticate() {\n        _authenticateCaller();\n        _;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call the entry point function.\n     */\n    function _authenticateCaller() internal view {\n        bytes32 actionId = getActionId(msg.sig);\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\n    }\n\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\n        // multiple contracts.\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\n}\n"
    },
    "contracts/libraries/helpers/IAuthentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\ninterface IAuthentication {\n    /**\n     * @dev Returns the action identifier associated with the external function described by `selector`.\n     */\n    function getActionId(bytes4 selector) external view returns (bytes32);\n}\n"
    },
    "contracts/WeightedPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IVault.sol\";\n\nimport \"./libraries/factories/BasePoolSplitCodeFactory.sol\";\nimport \"./libraries/factories/FactoryWidePauseWindow.sol\";\n\nimport \"./WeightedPool.sol\";\n\ncontract WeightedPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(WeightedPool).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `WeightedPool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n            _create(\n                abi.encode(\n                    getVault(),\n                    name,\n                    symbol,\n                    tokens,\n                    weights,\n                    assetManagers,\n                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner\n                )\n            );\n    }\n}\n"
    },
    "contracts/WeightedPool2TokensFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IVault.sol\";\n\nimport \"./libraries/factories/BasePoolSplitCodeFactory.sol\";\nimport \"./libraries/factories/FactoryWidePauseWindow.sol\";\n\nimport \"./WeightedPool2Tokens.sol\";\n\ncontract WeightedPool2TokensFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(WeightedPool2Tokens).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `WeightedPool2Tokens`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        bool oracleEnabled,\n        address owner\n    ) external returns (address) {\n        // TODO: Do not use arrays in the interface for tokens and weights\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        WeightedPool2Tokens.NewPoolParams memory params = WeightedPool2Tokens.NewPoolParams({\n            vault: getVault(),\n            name: name,\n            symbol: symbol,\n            token0: tokens[0],\n            token1: tokens[1],\n            normalizedWeight0: weights[0],\n            normalizedWeight1: weights[1],\n            swapFeePercentage: swapFeePercentage,\n            pauseWindowDuration: pauseWindowDuration,\n            bufferPeriodDuration: bufferPeriodDuration,\n            oracleEnabled: oracleEnabled,\n            owner: owner\n        });\n\n        return _create(abi.encode(params));\n    }\n}\n"
    },
    "contracts/WeightedPool2Tokens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./libraries/LogCompression.sol\";\nimport \"./libraries/helpers/TemporarilyPausable.sol\";\nimport \"./libraries/ERC20.sol\";\n\nimport \"./interfaces/IMinimalSwapInfoPool.sol\";\n\nimport \"./BasePoolAuthorization.sol\";\nimport \"./RequiemPoolToken.sol\";\nimport \"./BasePool.sol\";\nimport \"./libraries/oracle/PoolPriceOracle.sol\";\nimport \"./libraries/oracle/Buffer.sol\";\n\nimport \"./libraries/weighted/WeightedMath.sol\";\nimport \"./libraries/weighted/WeightedOracleMath.sol\";\nimport \"./libraries/weighted/WeightedPoolUserDataHelpers.sol\";\nimport \"./libraries/weighted/WeightedPool2TokensMiscData.sol\";\n\ncontract WeightedPool2Tokens is\n    IMinimalSwapInfoPool,\n    BasePoolAuthorization,\n    RequiemPoolToken,\n    TemporarilyPausable,\n    PoolPriceOracle,\n    WeightedOracleMath\n{\n    using FixedPoint for uint256;\n    using WeightedPoolUserDataHelpers for bytes;\n    using WeightedPool2TokensMiscData for bytes32;\n\n    uint256 private constant _MINIMUM_BPT = 1e6;\n\n    // 1e18 corresponds to 1.0, or a 100% fee\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10%\n    // The swap fee is internally stored using 64 bits, which is enough to represent _MAX_SWAP_FEE_PERCENTAGE.\n\n    bytes32 internal _miscData;\n    uint256 private _lastInvariant;\n\n    bytes32 private immutable _poolId;\n\n    IERC20 internal immutable _token0;\n    IERC20 internal immutable _token1;\n\n    uint256 private immutable _normalizedWeight0;\n    uint256 private immutable _normalizedWeight1;\n\n    // The protocol fees will always be charged using the token associated with the max weight in the pool.\n    // Since these Pools will register tokens only once, we can assume this index will be constant.\n    uint256 private immutable _maxWeightTokenIndex;\n\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\n    uint256 internal immutable _scalingFactor0;\n    uint256 internal immutable _scalingFactor1;\n\n    event OracleEnabledChanged(bool enabled);\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\n\n    modifier onlyVault(bytes32 poolId) {\n        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);\n        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);\n        _;\n    }\n\n    struct NewPoolParams {\n        IVault vault;\n        string name;\n        string symbol;\n        IERC20 token0;\n        IERC20 token1;\n        uint256 normalizedWeight0;\n        uint256 normalizedWeight1;\n        uint256 swapFeePercentage;\n        uint256 pauseWindowDuration;\n        uint256 bufferPeriodDuration;\n        bool oracleEnabled;\n        address owner;\n    }\n\n    constructor(NewPoolParams memory params)\n        // Base Pools are expected to be deployed using factories. By using the factory address as the action\n        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for\n        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in\n        // any Pool created by the same factory), while still making action identifiers unique among different factories\n        // if the selectors match, preventing accidental errors.\n        Authentication(bytes32(uint256(uint160(msg.sender)) << 96))\n        RequiemPoolToken(params.name, params.symbol, params.vault)\n        BasePoolAuthorization(params.owner)\n        TemporarilyPausable(params.pauseWindowDuration, params.bufferPeriodDuration)\n    {\n        _setOracleEnabled(params.oracleEnabled);\n        _setSwapFeePercentage(params.swapFeePercentage);\n\n        bytes32 poolId = params.vault.registerPool(IVault.PoolSpecialization.TWO_TOKEN);\n\n        // Pass in zero addresses for Asset Managers\n        IERC20[] memory tokens = new IERC20[](2);\n        tokens[0] = params.token0;\n        tokens[1] = params.token1;\n        params.vault.registerTokens(poolId, tokens, new address[](2));\n\n        // Set immutable state variables - these cannot be read from during construction\n        _poolId = poolId;\n\n        _token0 = params.token0;\n        _token1 = params.token1;\n\n        _scalingFactor0 = _computeScalingFactor(params.token0);\n        _scalingFactor1 = _computeScalingFactor(params.token1);\n\n        // Ensure each normalized weight is above them minimum and find the token index of the maximum weight\n        _require(params.normalizedWeight0 >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n        _require(params.normalizedWeight1 >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n\n        // Ensure that the normalized weights sum to ONE\n        uint256 normalizedSum = params.normalizedWeight0.add(params.normalizedWeight1);\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\n\n        _normalizedWeight0 = params.normalizedWeight0;\n        _normalizedWeight1 = params.normalizedWeight1;\n        _maxWeightTokenIndex = params.normalizedWeight0 >= params.normalizedWeight1 ? 0 : 1;\n    }\n\n    // Getters / Setters\n\n    function getPoolId() public view override returns (bytes32) {\n        return _poolId;\n    }\n\n    function getMiscData()\n        external\n        view\n        returns (\n            int256 logInvariant,\n            int256 logTotalSupply,\n            uint256 oracleSampleCreationTimestamp,\n            uint256 oracleIndex,\n            bool oracleEnabled,\n            uint256 swapFeePercentage\n        )\n    {\n        bytes32 miscData = _miscData;\n        logInvariant = miscData.logInvariant();\n        logTotalSupply = miscData.logTotalSupply();\n        oracleSampleCreationTimestamp = miscData.oracleSampleCreationTimestamp();\n        oracleIndex = miscData.oracleIndex();\n        oracleEnabled = miscData.oracleEnabled();\n        swapFeePercentage = miscData.swapFeePercentage();\n    }\n\n    function getSwapFeePercentage() public view returns (uint256) {\n        return _miscData.swapFeePercentage();\n    }\n\n    // Caller must be approved by the Vault's Authorizer\n    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual authenticate whenNotPaused {\n        _setSwapFeePercentage(swapFeePercentage);\n    }\n\n    function _setSwapFeePercentage(uint256 swapFeePercentage) private {\n        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);\n        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);\n\n        _miscData = _miscData.setSwapFeePercentage(swapFeePercentage);\n        emit SwapFeePercentageChanged(swapFeePercentage);\n    }\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\n        return\n            (actionId == getActionId(BasePool.setSwapFeePercentage.selector)) ||\n            (actionId == getActionId(BasePool.setAssetManagerPoolConfig.selector));\n    }\n\n    /**\n     * @dev Balancer Governance can always enable the Oracle, even if it was originally not enabled. This allows for\n     * Pools that unexpectedly drive much more volume and liquidity than expected to serve as Price Oracles.\n     *\n     * Note that the Oracle can only be enabled - it can never be disabled.\n     */\n    function enableOracle() external whenNotPaused authenticate {\n        _setOracleEnabled(true);\n\n        // Cache log invariant and supply only if the pool was initialized\n        if (totalSupply() > 0) {\n            _cacheInvariantAndSupply();\n        }\n    }\n\n    function _setOracleEnabled(bool enabled) internal {\n        _miscData = _miscData.setOracleEnabled(enabled);\n        emit OracleEnabledChanged(enabled);\n    }\n\n    // Caller must be approved by the Vault's Authorizer\n    function setPaused(bool paused) external authenticate {\n        _setPaused(paused);\n    }\n\n    function getNormalizedWeights() external view returns (uint256[] memory) {\n        return _normalizedWeights();\n    }\n\n    function _normalizedWeights() internal view virtual returns (uint256[] memory) {\n        uint256[] memory normalizedWeights = new uint256[](2);\n        normalizedWeights[0] = _normalizedWeights(true);\n        normalizedWeights[1] = _normalizedWeights(false);\n        return normalizedWeights;\n    }\n\n    function _normalizedWeights(bool token0) internal view virtual returns (uint256) {\n        return token0 ? _normalizedWeight0 : _normalizedWeight1;\n    }\n\n    function getLastInvariant() external view returns (uint256) {\n        return _lastInvariant;\n    }\n\n    /**\n     * @dev Returns the current value of the invariant.\n     */\n    function getInvariant() public view returns (uint256) {\n        (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());\n\n        // Since the Pool hooks always work with upscaled balances, we manually\n        // upscale here for consistency\n        _upscaleArray(balances);\n\n        uint256[] memory normalizedWeights = _normalizedWeights();\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\n    }\n\n    // Swap Hooks\n\n    function onSwap(\n        SwapRequest memory request,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) public virtual override whenNotPaused onlyVault(request.poolId) returns (uint256) {\n        bool tokenInIsToken0 = request.tokenIn == _token0;\n\n        uint256 scalingFactorTokenIn = _scalingFactor(tokenInIsToken0);\n        uint256 scalingFactorTokenOut = _scalingFactor(!tokenInIsToken0);\n\n        uint256 normalizedWeightIn = _normalizedWeights(tokenInIsToken0);\n        uint256 normalizedWeightOut = _normalizedWeights(!tokenInIsToken0);\n\n        // All token amounts are upscaled.\n        balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\n        balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\n\n        // Update price oracle with the pre-swap balances\n        _updateOracle(\n            request.lastChangeBlock,\n            tokenInIsToken0 ? balanceTokenIn : balanceTokenOut,\n            tokenInIsToken0 ? balanceTokenOut : balanceTokenIn\n        );\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // Fees are subtracted before scaling, to reduce the complexity of the rounding direction analysis.\n            // This is amount - fee amount, so we round up (favoring a higher fee amount).\n            uint256 feeAmount = request.amount.mulUp(getSwapFeePercentage());\n            request.amount = _upscale(request.amount.sub(feeAmount), scalingFactorTokenIn);\n\n            uint256 amountOut = _onSwapGivenIn(\n                request,\n                balanceTokenIn,\n                balanceTokenOut,\n                normalizedWeightIn,\n                normalizedWeightOut\n            );\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactorTokenOut);\n        } else {\n            request.amount = _upscale(request.amount, scalingFactorTokenOut);\n\n            uint256 amountIn = _onSwapGivenOut(\n                request,\n                balanceTokenIn,\n                balanceTokenOut,\n                normalizedWeightIn,\n                normalizedWeightOut\n            );\n\n            // amountIn tokens are entering the Pool, so we round up.\n            amountIn = _downscaleUp(amountIn, scalingFactorTokenIn);\n\n            // Fees are added after scaling happens, to reduce the complexity of the rounding direction analysis.\n            // This is amount + fee amount, so we round up (favoring a higher fee amount).\n            return amountIn.divUp(getSwapFeePercentage().complement());\n        }\n    }\n\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut,\n        uint256 normalizedWeightIn,\n        uint256 normalizedWeightOut\n    ) private pure returns (uint256) {\n        // Swaps are disabled while the contract is paused.\n        return\n            WeightedMath._calcOutGivenIn(\n                currentBalanceTokenIn,\n                normalizedWeightIn,\n                currentBalanceTokenOut,\n                normalizedWeightOut,\n                swapRequest.amount\n            );\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut,\n        uint256 normalizedWeightIn,\n        uint256 normalizedWeightOut\n    ) private pure returns (uint256) {\n        // Swaps are disabled while the contract is paused.\n        return\n            WeightedMath._calcInGivenOut(\n                currentBalanceTokenIn,\n                normalizedWeightIn,\n                currentBalanceTokenOut,\n                normalizedWeightOut,\n                swapRequest.amount\n            );\n    }\n\n    // Join Hook\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    )\n        public\n        virtual\n        override\n        onlyVault(poolId)\n        whenNotPaused\n        returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts)\n    {\n        // All joins, including initializations, are disabled while the contract is paused.\n\n        uint256 bptAmountOut;\n        if (totalSupply() == 0) {\n            (bptAmountOut, amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n\n            // There are no due protocol fee amounts during initialization\n            dueProtocolFeeAmounts = new uint256[](2);\n        } else {\n            _upscaleArray(balances);\n\n            // Update price oracle with the pre-join balances\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n            (bptAmountOut, amountsIn, dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts);\n        }\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n        // oracle updates.\n        _cacheInvariantAndSupply();\n    }\n\n    /**\n     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.\n     *\n     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.\n     *\n     * Minted BPT will be sent to `recipient`, except for _MINIMUM_BPT, which will be deducted from this amount and sent\n     * to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP from\n     * ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire Pool's\n     * lifetime.\n     *\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\n     * be downscaled (rounding up) before being returned to the Vault.\n     */\n    function _onInitializePool(\n        bytes32,\n        address,\n        address,\n        bytes memory userData\n    ) private returns (uint256, uint256[] memory) {\n        BaseWeightedPool.JoinKind kind = userData.joinKind();\n        _require(kind == BaseWeightedPool.JoinKind.INIT, Errors.UNINITIALIZED);\n\n        uint256[] memory amountsIn = userData.initialAmountsIn();\n        InputHelpers.ensureInputLengthMatch(amountsIn.length, 2);\n        _upscaleArray(amountsIn);\n\n        uint256[] memory normalizedWeights = _normalizedWeights();\n\n        uint256 invariantAfterJoin = WeightedMath._calculateInvariant(normalizedWeights, amountsIn);\n\n        // Set the initial BPT to the value of the invariant times the number of tokens. This makes BPT supply more\n        // consistent in Pools with similar compositions but different number of tokens.\n        uint256 bptAmountOut = Math.mul(invariantAfterJoin, 2);\n\n        _lastInvariant = invariantAfterJoin;\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    /**\n     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).\n     *\n     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of\n     * tokens to pay in protocol swap fees.\n     *\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\n     *\n     * Minted BPT will be sent to `recipient`.\n     *\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\n     * be downscaled (rounding up) before being returned to the Vault.\n     *\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\n     */\n    function _onJoinPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    )\n        private\n        returns (\n            uint256,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256[] memory normalizedWeights = _normalizedWeights();\n\n        // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join\n        // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas\n        // computing them on each individual swap\n        uint256 invariantBeforeJoin = WeightedMath._calculateInvariant(normalizedWeights, balances);\n\n        uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\n            balances,\n            normalizedWeights,\n            _lastInvariant,\n            invariantBeforeJoin,\n            protocolSwapFeePercentage\n        );\n\n        // Update current balances by subtracting the protocol fee amounts\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n        (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, normalizedWeights, userData);\n\n        // Update the invariant with the balances the Pool will have after the join, in order to compute the\n        // protocol swap fee amounts due in future joins and exits.\n        _mutateAmounts(balances, amountsIn, FixedPoint.add);\n        _lastInvariant = WeightedMath._calculateInvariant(normalizedWeights, balances);\n\n        return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);\n    }\n\n    function _doJoin(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view returns (uint256, uint256[] memory) {\n        BaseWeightedPool.JoinKind kind = userData.joinKind();\n\n        if (kind == BaseWeightedPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == BaseWeightedPool.JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == BaseWeightedPool.JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT) {\n            return _joinAllTokensInForExactBPTOut(balances, userData);\n        } else {\n            _revert(Errors.UNHANDLED_JOIN_KIND);\n        }\n    }\n\n    function _joinExactTokensInForBPTOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view returns (uint256, uint256[] memory) {\n        (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();\n        InputHelpers.ensureInputLengthMatch(amountsIn.length, 2);\n\n        _upscaleArray(amountsIn);\n\n        (uint256 bptAmountOut, ) = WeightedMath._calcBptOutGivenExactTokensIn(\n            balances,\n            normalizedWeights,\n            amountsIn,\n            totalSupply(),\n            getSwapFeePercentage()\n        );\n\n        _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _joinTokenInForExactBPTOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view returns (uint256, uint256[] memory) {\n        (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();\n        // Note that there is no maximum amountIn parameter: this is handled by `IVault.joinPool`.\n\n        _require(tokenIndex < 2, Errors.OUT_OF_BOUNDS);\n\n        uint256[] memory amountsIn = new uint256[](2);\n        (amountsIn[tokenIndex], ) = WeightedMath._calcTokenInGivenExactBptOut(\n            balances[tokenIndex],\n            normalizedWeights[tokenIndex],\n            bptAmountOut,\n            totalSupply(),\n            getSwapFeePercentage()\n        );\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _joinAllTokensInForExactBPTOut(uint256[] memory balances, bytes memory userData)\n        private\n        view\n        returns (uint256, uint256[] memory)\n    {\n        uint256 bptAmountOut = userData.allTokensInForExactBptOut();\n        // Note that there is no maximum amountsIn parameter: this is handled by `IVault.joinPool`.\n\n        uint256[] memory amountsIn = WeightedMath._calcAllTokensInGivenExactBptOut(\n            balances,\n            bptAmountOut,\n            totalSupply()\n        );\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    // Exit Hook\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        _upscaleArray(balances);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut);\n        _downscaleDownArray(dueProtocolFeeAmounts);\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n        if (_isNotPaused()) {\n            _cacheInvariantAndSupply();\n        }\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }\n\n    /**\n     * @dev Called whenever the Pool is exited.\n     *\n     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and\n     * the number of tokens to pay in protocol swap fees.\n     *\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\n     *\n     * BPT will be burnt from `sender`.\n     *\n     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled\n     * (rounding down) before being returned to the Vault.\n     *\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\n     */\n    function _onExitPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    )\n        private\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\n        // out) remain functional.\n\n        uint256[] memory normalizedWeights = _normalizedWeights();\n\n        if (_isNotPaused()) {\n            // Update price oracle with the pre-exit balances\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n            // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous\n            // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids\n            // spending gas calculating the fees on each individual swap.\n            uint256 invariantBeforeExit = WeightedMath._calculateInvariant(normalizedWeights, balances);\n            dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\n                balances,\n                normalizedWeights,\n                _lastInvariant,\n                invariantBeforeExit,\n                protocolSwapFeePercentage\n            );\n\n            // Update current balances by subtracting the protocol fee amounts\n            _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n        } else {\n            // If the contract is paused, swap protocol fee amounts are not charged and the oracle is not updated\n            // to avoid extra calculations and reduce the potential for errors.\n            dueProtocolFeeAmounts = new uint256[](2);\n        }\n\n        (bptAmountIn, amountsOut) = _doExit(balances, normalizedWeights, userData);\n\n        // Update the invariant with the balances the Pool will have after the exit, in order to compute the\n        // protocol swap fees due in future joins and exits.\n        _mutateAmounts(balances, amountsOut, FixedPoint.sub);\n        _lastInvariant = WeightedMath._calculateInvariant(normalizedWeights, balances);\n\n        return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);\n    }\n\n    function _doExit(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view returns (uint256, uint256[] memory) {\n        BaseWeightedPool.ExitKind kind = userData.exitKind();\n\n        if (kind == BaseWeightedPool.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {\n            return _exitExactBPTInForTokenOut(balances, normalizedWeights, userData);\n        } else if (kind == BaseWeightedPool.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {\n            return _exitExactBPTInForTokensOut(balances, userData);\n        } else if (kind == BaseWeightedPool.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {\n            return _exitBPTInForExactTokensOut(balances, normalizedWeights, userData);\n        } else {\n            _revert(Errors.UNHANDLED_EXIT_KIND);\n        }\n    }\n\n    function _exitExactBPTInForTokenOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view whenNotPaused returns (uint256, uint256[] memory) {\n        // This exit function is disabled if the contract is paused.\n\n        (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\n\n        _require(tokenIndex < 2, Errors.OUT_OF_BOUNDS);\n\n        // We exit in a single token, so we initialize amountsOut with zeros\n        uint256[] memory amountsOut = new uint256[](2);\n\n        // And then assign the result to the selected token\n        (amountsOut[tokenIndex], ) = WeightedMath._calcTokenOutGivenExactBptIn(\n            balances[tokenIndex],\n            normalizedWeights[tokenIndex],\n            bptAmountIn,\n            totalSupply(),\n            getSwapFeePercentage()\n        );\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)\n        private\n        view\n        returns (uint256, uint256[] memory)\n    {\n        // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted\n        // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.\n        // This particular exit function is the only one that remains available because it is the simplest one, and\n        // therefore the one with the lowest likelihood of errors.\n\n        uint256 bptAmountIn = userData.exactBptInForTokensOut();\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\n\n        uint256[] memory amountsOut = WeightedMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _exitBPTInForExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        bytes memory userData\n    ) private view whenNotPaused returns (uint256, uint256[] memory) {\n        // This exit function is disabled if the contract is paused.\n\n        (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();\n        InputHelpers.ensureInputLengthMatch(amountsOut.length, 2);\n        _upscaleArray(amountsOut);\n\n        (uint256 bptAmountIn, ) = WeightedMath._calcBptInGivenExactTokensOut(\n            balances,\n            normalizedWeights,\n            amountsOut,\n            totalSupply(),\n            getSwapFeePercentage()\n        );\n        _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    // Oracle functions\n\n    /**\n     * @dev Updates the Price Oracle based on the Pool's current state (balances, BPT supply and invariant). Must be\n     * called on *all* state-changing functions with the balances *before* the state change happens, and with\n     * `lastChangeBlock` as the number of the block in which any of the balances last changed.\n     */\n    function _updateOracle(\n        uint256 lastChangeBlock,\n        uint256 balanceToken0,\n        uint256 balanceToken1\n    ) internal {\n        bytes32 miscData = _miscData;\n        if (miscData.oracleEnabled() && block.number > lastChangeBlock) {\n            int256 logSpotPrice = WeightedOracleMath._calcLogSpotPrice(\n                _normalizedWeight0,\n                balanceToken0,\n                _normalizedWeight1,\n                balanceToken1\n            );\n\n            int256 logBPTPrice = WeightedOracleMath._calcLogBPTPrice(\n                _normalizedWeight0,\n                balanceToken0,\n                miscData.logTotalSupply()\n            );\n\n            uint256 oracleCurrentIndex = miscData.oracleIndex();\n            uint256 oracleCurrentSampleInitialTimestamp = miscData.oracleSampleCreationTimestamp();\n            uint256 oracleUpdatedIndex = _processPriceData(\n                oracleCurrentSampleInitialTimestamp,\n                oracleCurrentIndex,\n                logSpotPrice,\n                logBPTPrice,\n                miscData.logInvariant()\n            );\n\n            if (oracleCurrentIndex != oracleUpdatedIndex) {\n                // solhint-disable not-rely-on-time\n                miscData = miscData.setOracleIndex(oracleUpdatedIndex);\n                miscData = miscData.setOracleSampleCreationTimestamp(block.timestamp);\n                _miscData = miscData;\n            }\n        }\n    }\n\n    /**\n     * @dev Stores the logarithm of the invariant and BPT total supply, to be later used in each oracle update. Because\n     * it is stored in miscData, which is read in all operations (including swaps), this saves gas by not requiring to\n     * compute or read these values when updating the oracle.\n     *\n     * This function must be called by all actions that update the invariant and BPT supply (joins and exits). Swaps\n     * also alter the invariant due to collected swap fees, but this growth is considered negligible and not accounted\n     * for.\n     */\n    function _cacheInvariantAndSupply() internal {\n        bytes32 miscData = _miscData;\n        if (miscData.oracleEnabled()) {\n            miscData = miscData.setLogInvariant(LogCompression.toLowResLog(_lastInvariant));\n            miscData = miscData.setLogTotalSupply(LogCompression.toLowResLog(totalSupply()));\n            _miscData = miscData;\n        }\n    }\n\n    function _getOracleIndex() internal view override returns (uint256) {\n        return _miscData.oracleIndex();\n    }\n\n    // Query functions\n\n    /**\n     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }\n\n    /**\n     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }\n\n    // Helpers\n\n    function _getDueProtocolFeeAmounts(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256 previousInvariant,\n        uint256 currentInvariant,\n        uint256 protocolSwapFeePercentage\n    ) private view returns (uint256[] memory) {\n        // Initialize with zeros\n        uint256[] memory dueProtocolFeeAmounts = new uint256[](2);\n\n        // Early return if the protocol swap fee percentage is zero, saving gas.\n        if (protocolSwapFeePercentage == 0) {\n            return dueProtocolFeeAmounts;\n        }\n\n        // The protocol swap fees are always paid using the token with the largest weight in the Pool. As this is the\n        // token that is expected to have the largest balance, using it to pay fees should not unbalance the Pool.\n        dueProtocolFeeAmounts[_maxWeightTokenIndex] = WeightedMath._calcDueTokenProtocolSwapFeeAmount(\n            balances[_maxWeightTokenIndex],\n            normalizedWeights[_maxWeightTokenIndex],\n            previousInvariant,\n            currentInvariant,\n            protocolSwapFeePercentage\n        );\n\n        return dueProtocolFeeAmounts;\n    }\n\n    /**\n     * @dev Mutates `amounts` by applying `mutation` with each entry in `arguments`.\n     *\n     * Equivalent to `amounts = amounts.map(mutation)`.\n     */\n    function _mutateAmounts(\n        uint256[] memory toMutate,\n        uint256[] memory arguments,\n        function(uint256, uint256) pure returns (uint256) mutation\n    ) private pure {\n        toMutate[0] = mutation(toMutate[0], arguments[0]);\n        toMutate[1] = mutation(toMutate[1], arguments[1]);\n    }\n\n    /**\n     * @dev This function returns the appreciation of one BPT relative to the\n     * underlying tokens. This starts at 1 when the pool is created and grows over time\n     */\n    function getRate() public view returns (uint256) {\n        // The initial BPT supply is equal to the invariant times the number of tokens.\n        return Math.mul(getInvariant(), 2).divDown(totalSupply());\n    }\n\n    // Scaling\n\n    /**\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n     * it had 18 decimals.\n     */\n    function _computeScalingFactor(IERC20 token) private view returns (uint256) {\n        // Tokens that don't implement the `decimals` method are not supported.\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\n\n        // Tokens with more than 18 decimals are not supported.\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\n        return 10**decimalsDifference;\n    }\n\n    /**\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\n     * Pool.\n     */\n    function _scalingFactor(bool token0) internal view returns (uint256) {\n        return token0 ? _scalingFactor0 : _scalingFactor1;\n    }\n\n    /**\n     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\n     * scaling or not.\n     */\n    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        return Math.mul(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_upscale`, but for an entire array (of two elements). This function does not return anything, but\n     * instead *mutates* the `amounts` array.\n     */\n    function _upscaleArray(uint256[] memory amounts) internal view {\n        amounts[0] = Math.mul(amounts[0], _scalingFactor(true));\n        amounts[1] = Math.mul(amounts[1], _scalingFactor(false));\n    }\n\n    /**\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n     * whether it needed scaling or not. The result is rounded down.\n     */\n    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        return Math.divDown(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_downscaleDown`, but for an entire array (of two elements). This function does not return anything,\n     * but instead *mutates* the `amounts` array.\n     */\n    function _downscaleDownArray(uint256[] memory amounts) internal view {\n        amounts[0] = Math.divDown(amounts[0], _scalingFactor(true));\n        amounts[1] = Math.divDown(amounts[1], _scalingFactor(false));\n    }\n\n    /**\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n     * whether it needed scaling or not. The result is rounded up.\n     */\n    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\n        return Math.divUp(amount, scalingFactor);\n    }\n\n    /**\n     * @dev Same as `_downscaleUp`, but for an entire array (of two elements). This function does not return anything,\n     * but instead *mutates* the `amounts` array.\n     */\n    function _downscaleUpArray(uint256[] memory amounts) internal view {\n        amounts[0] = Math.divUp(amounts[0], _scalingFactor(true));\n        amounts[1] = Math.divUp(amounts[1], _scalingFactor(false));\n    }\n\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\n        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which\n        // accounts can call permissioned functions: for example, to perform emergency pauses.\n        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under\n        // Governance control.\n        return getVault().getAuthorizer();\n    }\n\n    function _queryAction(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        function(bytes32, address, address, uint256[] memory, uint256, uint256, bytes memory)\n            internal\n            returns (uint256, uint256[] memory, uint256[] memory) _action,\n        function(uint256[] memory) internal view _downscaleArray\n    ) private {\n        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed\n        // explanation.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the bpt and token amounts from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of the\n                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded\n                        // representation of these.\n                        // An ABI-encoded response will include one additional field to indicate the starting offset of\n                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the\n                        // returndata.\n                        //\n                        // In returndata:\n                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]\n                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]\n                        //\n                        // We now need to return (ABI-encoded values):\n                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]\n                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]\n\n                        // We copy 32 bytes for the `bptAmount` from returndata into memory.\n                        // Note that we skip the first 4 bytes for the error signature\n                        returndatacopy(0, 0x04, 32)\n\n                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after\n                        // the initial 64 bytes.\n                        mstore(0x20, 64)\n\n                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.\n                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also\n                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.\n                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))\n\n                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to\n                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the\n                        // error signature.\n                        return(0, add(returndatasize(), 28))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn't happen\n                        invalid()\n                    }\n            }\n        } else {\n            _upscaleArray(balances);\n\n            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                userData\n            );\n\n            _downscaleArray(tokenAmounts);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of\n                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values\n                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32\n                let size := mul(mload(tokenAmounts), 32)\n\n                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there\n                // will be at least one available slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                let start := sub(tokenAmounts, 0x20)\n                mstore(start, bptAmount)\n\n                // We send one extra value for the error signature \"QueryError(uint256,uint256[])\" which is 0x43adbafb\n                // We use the previous slot to `bptAmount`.\n                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)\n                start := sub(start, 0x04)\n\n                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return\n                // the `bptAmount`, the array length, and the error signature.\n                revert(start, add(size, 68))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/LogCompression.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./math/LogExpMath.sol\";\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n */\nlibrary LogCompression {\n    int256 private constant _LOG_COMPRESSION_FACTOR = 1e14;\n    int256 private constant _HALF_LOG_COMPRESSION_FACTOR = 0.5e14;\n\n    /**\n     * @dev Returns the natural logarithm of `value`, dropping most of the decimal places to arrive at a value that,\n     * when passed to `fromLowResLog`, will have a maximum relative error of ~0.05% compared to `value`.\n     *\n     * Values returned from this function should not be mixed with other fixed-point values (as they have a different\n     * number of digits), but can be added or subtracted. Use `fromLowResLog` to undo this process and return to an\n     * 18 decimal places fixed point value.\n     *\n     * Because so much precision is lost, the logarithmic values can be stored using much fewer bits than the original\n     * value required.\n     */\n    function toLowResLog(uint256 value) internal pure returns (int256) {\n        int256 ln = LogExpMath.ln(int256(value));\n\n        // Rounding division for signed numerator\n        int256 lnWithError = (ln > 0 ? ln + _HALF_LOG_COMPRESSION_FACTOR : ln - _HALF_LOG_COMPRESSION_FACTOR);\n        return lnWithError / _LOG_COMPRESSION_FACTOR;\n    }\n\n    /**\n     * @dev Restores `value` from logarithmic space. `value` is expected to be the result of a call to `toLowResLog`,\n     * any other function that returns 4 decimals fixed point logarithms, or the sum of such values.\n     */\n    function fromLowResLog(int256 value) internal pure returns (uint256) {\n        return uint256(LogExpMath.exp(value * _LOG_COMPRESSION_FACTOR));\n    }\n}\n"
    },
    "contracts/libraries/oracle/PoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\nimport \"../../interfaces/oracle/IPoolPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\nimport \"./QueryProcessor.sol\";\n\n/**\n * @dev This module allows Pools to access historical pricing information.\n *\n * It uses a 1024 long circular buffer to store past data, where the data within each sample is the result of\n * accumulating live data for no more than two minutes. Therefore, assuming the worst case scenario where new data is\n * updated in every single block, the oldest samples in the buffer (and therefore largest queryable period) will\n * be slightly over 34 hours old.\n *\n * Usage of this module requires the caller to keep track of two variables: the latest circular buffer index, and the\n * timestamp when the index last changed. Aditionally, access to the latest circular buffer index must be exposed by\n * implementing `_getOracleIndex`.\n *\n * This contract relies on the `QueryProcessor` linked library to reduce bytecode size.\n */\nabstract contract PoolPriceOracle is IPoolPriceOracle, IPriceOracle {\n    using Buffer for uint256;\n    using Samples for bytes32;\n\n    // Each sample in the buffer accumulates information for up to 2 minutes. This is simply to reduce the size of the\n    // buffer: small time deviations will not have any significant effect.\n    // solhint-disable not-rely-on-time\n    uint256 private constant _MAX_SAMPLE_DURATION = 2 minutes;\n\n    // We use a mapping to simulate an array: the buffer won't grow or shrink, and since we will always use valid\n    // indexes using a mapping saves gas by skipping the bounds checks.\n    mapping(uint256 => bytes32) internal _samples;\n\n    // IPoolPriceOracle\n\n    function getSample(uint256 index)\n        external\n        view\n        override\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        )\n    {\n        require(index < Buffer.SIZE, \"ORACLE_INVALID_INDEX\");\n\n        bytes32 sample = _getSample(index);\n        return sample.unpack();\n    }\n\n    function getTotalSamples() external pure override returns (uint256) {\n        return Buffer.SIZE;\n    }\n\n    /**\n     * @dev Manually dirty oracle sample storage slots with dummy data, to reduce the gas cost of the future swaps\n     * that will initialize them. This function is only useful before the oracle has been fully initialized.\n     *\n     * `endIndex` is non-inclusive.\n     */\n    function dirtyUninitializedOracleSamples(uint256 startIndex, uint256 endIndex) external {\n        require(startIndex < endIndex && endIndex <= Buffer.SIZE, \"OUT_OF_BOUNDS\");\n\n        // Uninitialized samples are identified by a zero timestamp -- all other fields are ignored,\n        // so any non-zero value with a zero timestamp suffices.\n        bytes32 initSample = Samples.pack(1, 0, 0, 0, 0, 0, 0);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            if (_samples[i].timestamp() == 0) {\n                _samples[i] = initSample;\n            }\n        }\n    }\n\n    // IPriceOracle\n\n    function getLargestSafeQueryWindow() external pure override returns (uint256) {\n        return 34 hours;\n    }\n\n    function getLatest(Variable variable) external view override returns (uint256) {\n        return QueryProcessor.getInstantValue(_samples, variable, _getOracleIndex());\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        override\n        returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i], latestIndex);\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        override\n        returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, latestIndex, query.ago);\n        }\n    }\n\n    // Internal functions\n\n    /**\n     * @dev Processes new price and invariant data, updating the latest sample or creating a new one.\n     *\n     * Receives the new logarithms of values to store: `logPairPrice`, `logBptPrice` and `logInvariant`, as well the\n     * index of the latest sample and the timestamp of its creation.\n     *\n     * Returns the index of the latest sample. If different from `latestIndex`, the caller should also store the\n     * timestamp, and pass it on future calls to this function.\n     */\n    function _processPriceData(\n        uint256 latestSampleCreationTimestamp,\n        uint256 latestIndex,\n        int256 logPairPrice,\n        int256 logBptPrice,\n        int256 logInvariant\n    ) internal returns (uint256) {\n        // Read latest sample, and compute the next one by updating it with the newly received data.\n        bytes32 sample = _getSample(latestIndex).update(logPairPrice, logBptPrice, logInvariant, block.timestamp);\n\n        // We create a new sample if more than _MAX_SAMPLE_DURATION seconds have elapsed since the creation of the\n        // latest one. In other words, no sample accumulates data over a period larger than _MAX_SAMPLE_DURATION.\n        bool newSample = block.timestamp - latestSampleCreationTimestamp >= _MAX_SAMPLE_DURATION;\n        latestIndex = newSample ? latestIndex.next() : latestIndex;\n\n        // Store the updated or new sample.\n        _samples[latestIndex] = sample;\n\n        return latestIndex;\n    }\n\n    function _getPastAccumulator(\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) internal view returns (int256) {\n        return QueryProcessor.getPastAccumulator(_samples, variable, latestIndex, ago);\n    }\n\n    function _findNearestSample(\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) internal view returns (bytes32 prev, bytes32 next) {\n        return QueryProcessor.findNearestSample(_samples, lookUpDate, offset, length);\n    }\n\n    /**\n     * @dev Returns the sample that corresponds to a given `index`.\n     *\n     * Using this function instead of accessing storage directly results in denser bytecode (since the storage slot is\n     * only computed here).\n     */\n    function _getSample(uint256 index) internal view returns (bytes32) {\n        return _samples[index];\n    }\n\n    /**\n     * @dev Virtual function to be implemented by derived contracts. Must return the current index of the oracle\n     * circular buffer.\n     */\n    function _getOracleIndex() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/libraries/oracle/Buffer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nlibrary Buffer {\n    // The buffer is a circular storage structure with 1024 slots.\n    // solhint-disable-next-line private-vars-leading-underscore\n    uint256 internal constant SIZE = 1024;\n\n    /**\n     * @dev Returns the index of the element before the one pointed by `index`.\n     */\n    function prev(uint256 index) internal pure returns (uint256) {\n        return sub(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of the element after the one pointed by `index`.\n     */\n    function next(uint256 index) internal pure returns (uint256) {\n        return add(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots after the one pointed by `index`.\n     */\n    function add(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + offset) % SIZE;\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots before the one pointed by `index`.\n     */\n    function sub(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + SIZE - offset) % SIZE;\n    }\n}\n"
    },
    "contracts/libraries/weighted/WeightedOracleMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../math/FixedPoint.sol\";\nimport \"../LogCompression.sol\";\n\ncontract WeightedOracleMath {\n    using FixedPoint for uint256;\n\n    /**\n     * @dev Calculates the logarithm of the spot price of token B in token A.\n     *\n     * The return value is a 4 decimal fixed-point number: use `LogCompression.fromLowResLog`\n     * to recover the original value.\n     */\n    function _calcLogSpotPrice(\n        uint256 normalizedWeightA,\n        uint256 balanceA,\n        uint256 normalizedWeightB,\n        uint256 balanceB\n    ) internal pure returns (int256) {\n        // Max balances are 2^112 and min weights are 0.01, so the division never overflows.\n\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n        // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\n        uint256 spotPrice = balanceA.divUp(normalizedWeightA).divUp(balanceB.divUp(normalizedWeightB));\n        return LogCompression.toLowResLog(spotPrice);\n    }\n\n    /**\n     * @dev Calculates the price of BPT in a token. `logBptTotalSupply` should be the result of calling `toLowResLog`\n     * with the current BPT supply.\n     *\n     * The return value is a 4 decimal fixed-point number: use `LogCompression.fromLowResLog`\n     * to recover the original value.\n     */\n    function _calcLogBPTPrice(\n        uint256 normalizedWeight,\n        uint256 balance,\n        int256 logBptTotalSupply\n    ) internal pure returns (int256) {\n        // BPT price = (balance / weight) / total supply\n        // Since we already have ln(total supply) and want to compute ln(BPT price), we perform the computation in log\n        // space directly: ln(BPT price) = ln(balance / weight) - ln(total supply)\n\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n        // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\n        uint256 balanceOverWeight = balance.divUp(normalizedWeight);\n        int256 logBalanceOverWeight = LogCompression.toLowResLog(balanceOverWeight);\n\n        // Because we're subtracting two values in log space, this value has a larger error (+-0.0001 instead of\n        // +-0.00005), which results in a final larger relative error of around 0.1%.\n        return logBalanceOverWeight - logBptTotalSupply;\n    }\n}\n"
    },
    "contracts/libraries/weighted/WeightedPool2TokensMiscData.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../helpers/WordCodec.sol\";\n\n/**\n * @dev This module provides an interface to store seemingly unrelated pieces of information, in particular used by\n * pools with a price oracle.\n *\n * These pieces of information are all kept together in a single storage slot to reduce the number of storage reads. In\n * particular, we not only store configuration values (such as the swap fee percentage), but also cache\n * reduced-precision versions of the total BPT supply and invariant, which lets us not access nor compute these values\n * when producing oracle updates during a swap.\n *\n * Data is stored with the following structure:\n *\n * [ swap fee pct | oracle enabled | oracle index | oracle sample initial timestamp | log supply | log invariant ]\n * [    uint64    |      bool      |    uint10    |              uint31             |    int22   |     int22     ]\n *\n * Note that we are not using the most-significant 106 bits.\n */\nlibrary WeightedPool2TokensMiscData {\n    using WordCodec for bytes32;\n    using WordCodec for uint256;\n\n    uint256 private constant _LOG_INVARIANT_OFFSET = 0;\n    uint256 private constant _LOG_TOTAL_SUPPLY_OFFSET = 22;\n    uint256 private constant _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET = 44;\n    uint256 private constant _ORACLE_INDEX_OFFSET = 75;\n    uint256 private constant _ORACLE_ENABLED_OFFSET = 85;\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 86;\n\n    /**\n     * @dev Returns the cached logarithm of the invariant.\n     */\n    function logInvariant(bytes32 data) internal pure returns (int256) {\n        return data.decodeInt22(_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns the cached logarithm of the total supply.\n     */\n    function logTotalSupply(bytes32 data) internal pure returns (int256) {\n        return data.decodeInt22(_LOG_TOTAL_SUPPLY_OFFSET);\n    }\n\n    /**\n     * @dev Returns the timestamp of the creation of the oracle's latest sample.\n     */\n    function oracleSampleCreationTimestamp(bytes32 data) internal pure returns (uint256) {\n        return data.decodeUint31(_ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Returns the index of the oracle's latest sample.\n     */\n    function oracleIndex(bytes32 data) internal pure returns (uint256) {\n        return data.decodeUint10(_ORACLE_INDEX_OFFSET);\n    }\n\n    /**\n     * @dev Returns true if the oracle is enabled.\n     */\n    function oracleEnabled(bytes32 data) internal pure returns (bool) {\n        return data.decodeBool(_ORACLE_ENABLED_OFFSET);\n    }\n\n    /**\n     * @dev Returns the swap fee percentage.\n     */\n    function swapFeePercentage(bytes32 data) internal pure returns (uint256) {\n        return data.decodeUint64(_SWAP_FEE_PERCENTAGE_OFFSET);\n    }\n\n    /**\n     * @dev Sets the logarithm of the invariant in `data`, returning the updated value.\n     */\n    function setLogInvariant(bytes32 data, int256 _logInvariant) internal pure returns (bytes32) {\n        return data.insertInt22(_logInvariant, _LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Sets the logarithm of the total supply in `data`, returning the updated value.\n     */\n    function setLogTotalSupply(bytes32 data, int256 _logTotalSupply) internal pure returns (bytes32) {\n        return data.insertInt22(_logTotalSupply, _LOG_TOTAL_SUPPLY_OFFSET);\n    }\n\n    /**\n     * @dev Sets the timestamp of the creation of the oracle's latest sample in `data`, returning the updated value.\n     */\n    function setOracleSampleCreationTimestamp(bytes32 data, uint256 _initialTimestamp) internal pure returns (bytes32) {\n        return data.insertUint31(_initialTimestamp, _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Sets the index of the  oracle's latest sample in `data`, returning the updated value.\n     */\n    function setOracleIndex(bytes32 data, uint256 _oracleIndex) internal pure returns (bytes32) {\n        return data.insertUint10(_oracleIndex, _ORACLE_INDEX_OFFSET);\n    }\n\n    /**\n     * @dev Enables or disables the oracle in `data`, returning the updated value.\n     */\n    function setOracleEnabled(bytes32 data, bool _oracleEnabled) internal pure returns (bytes32) {\n        return data.insertBool(_oracleEnabled, _ORACLE_ENABLED_OFFSET);\n    }\n\n    /**\n     * @dev Sets the swap fee percentage in `data`, returning the updated value.\n     */\n    function setSwapFeePercentage(bytes32 data, uint256 _swapFeePercentage) internal pure returns (bytes32) {\n        return data.insertUint64(_swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET);\n    }\n}\n"
    },
    "contracts/interfaces/oracle/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\n *\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\n * can be used to compare two different price sources, and choose the most liquid one.\n *\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\n * is not older than the largest safe query window.\n */\ninterface IPriceOracle {\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(Variable variable) external view returns (uint256);\n\n    /**\n     * @dev Information for a Time Weighted Average query.\n     *\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n     */\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\n     * able to produce a result and not revert.\n     *\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\n     * value for 'safe' queries.\n     */\n    function getLargestSafeQueryWindow() external view returns (uint256);\n\n    /**\n     * @dev Returns the accumulators corresponding to each of `queries`.\n     */\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        returns (int256[] memory results);\n\n    /**\n     * @dev Information for an Accumulator query.\n     *\n     * Each query estimates the accumulator at a time `ago` seconds ago.\n     */\n    struct OracleAccumulatorQuery {\n        Variable variable;\n        uint256 ago;\n    }\n}\n"
    },
    "contracts/interfaces/oracle/IPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\ninterface IPoolPriceOracle {\n    /**\n     * @dev Returns the raw data of the sample at `index`.\n     */\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    /**\n     * @dev Returns the total number of samples.\n     */\n    function getTotalSamples() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/oracle/Samples.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../helpers/WordCodec.sol\";\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\n\n/**\n * @dev This library provides functions to help manipulating samples for Pool Price Oracles. It handles updates,\n * encoding, and decoding of samples.\n *\n * Each sample holds the timestamp of its last update, plus information about three pieces of data: the price pair, the\n * price of BPT (the associated Pool token), and the invariant.\n *\n * Prices and invariant are not stored directly: instead, we store their logarithm. These are known as the 'instant'\n * values: the exact value at that timestamp.\n *\n * Additionally, for each value we keep an accumulator with the sum of all past values, each weighted by the time\n * elapsed since the previous update. This lets us later subtract accumulators at different points in time and divide by\n * the time elapsed between them, arriving at the geometric mean of the values (also known as log-average).\n *\n * All samples are stored in a single 256 bit word with the following structure:\n *\n * [    log pair price     |        bpt price      |       invariant       |  timestamp ]\n * [ instant | accumulator | instant | accumulator | instant | accumulator |            ]\n * [  int22  |    int53    |  int22  |    int53    |  int22  |    int53    |    uint31  ]\n * MSB                                                                                LSB\n *\n * Assuming the timestamp doesn't overflow (which holds until the year 2038), the largest elapsed time is 2^31, which\n * means the largest possible accumulator value is 2^21 * 2^31, which can be represented using a signed 53 bit integer.\n */\nlibrary Samples {\n    using WordCodec for int256;\n    using WordCodec for uint256;\n    using WordCodec for bytes32;\n\n    uint256 internal constant _TIMESTAMP_OFFSET = 0;\n    uint256 internal constant _ACC_LOG_INVARIANT_OFFSET = 31;\n    uint256 internal constant _INST_LOG_INVARIANT_OFFSET = 84;\n    uint256 internal constant _ACC_LOG_BPT_PRICE_OFFSET = 106;\n    uint256 internal constant _INST_LOG_BPT_PRICE_OFFSET = 159;\n    uint256 internal constant _ACC_LOG_PAIR_PRICE_OFFSET = 181;\n    uint256 internal constant _INST_LOG_PAIR_PRICE_OFFSET = 234;\n\n    /**\n     * @dev Updates a sample, accumulating the new data based on the elapsed time since the previous update. Returns the\n     * updated sample.\n     *\n     * IMPORTANT: This function does not perform any arithmetic checks. In particular, it assumes the caller will never\n     * pass values that cannot be represented as 22 bit signed integers. Additionally, it also assumes\n     * `currentTimestamp` is greater than `sample`'s timestamp.\n     */\n    function update(\n        bytes32 sample,\n        int256 instLogPairPrice,\n        int256 instLogBptPrice,\n        int256 instLogInvariant,\n        uint256 currentTimestamp\n    ) internal pure returns (bytes32) {\n        // Because elapsed can be represented as a 31 bit unsigned integer, and the received values can be represented\n        // as 22 bit signed integers, we don't need to perform checked arithmetic.\n\n        int256 elapsed = int256(currentTimestamp - timestamp(sample));\n        int256 accLogPairPrice = _accLogPairPrice(sample) + instLogPairPrice * elapsed;\n        int256 accLogBptPrice = _accLogBptPrice(sample) + instLogBptPrice * elapsed;\n        int256 accLogInvariant = _accLogInvariant(sample) + instLogInvariant * elapsed;\n\n        return\n            pack(\n                instLogPairPrice,\n                accLogPairPrice,\n                instLogBptPrice,\n                accLogBptPrice,\n                instLogInvariant,\n                accLogInvariant,\n                currentTimestamp\n            );\n    }\n\n    /**\n     * @dev Returns the instant value stored in `sample` for `variable`.\n     */\n    function instant(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _instLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _instLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _instLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns the accumulator value stored in `sample` for `variable`.\n     */\n    function accumulator(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _accLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _accLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _accLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns `sample`'s timestamp.\n     */\n    function timestamp(bytes32 sample) internal pure returns (uint256) {\n        return sample.decodeUint31(_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the pair price.\n     */\n    function _instLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the pair price.\n     */\n    function _accLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the BPT price.\n     */\n    function _instLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the BPT price.\n     */\n    function _accLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the invariant.\n     */\n    function _instLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the invariant.\n     */\n    function _accLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns a sample created by packing together its components.\n     */\n    function pack(\n        int256 instLogPairPrice,\n        int256 accLogPairPrice,\n        int256 instLogBptPrice,\n        int256 accLogBptPrice,\n        int256 instLogInvariant,\n        int256 accLogInvariant,\n        uint256 _timestamp\n    ) internal pure returns (bytes32) {\n        return\n            instLogPairPrice.encodeInt22(_INST_LOG_PAIR_PRICE_OFFSET) |\n            accLogPairPrice.encodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET) |\n            instLogBptPrice.encodeInt22(_INST_LOG_BPT_PRICE_OFFSET) |\n            accLogBptPrice.encodeInt53(_ACC_LOG_BPT_PRICE_OFFSET) |\n            instLogInvariant.encodeInt22(_INST_LOG_INVARIANT_OFFSET) |\n            accLogInvariant.encodeInt53(_ACC_LOG_INVARIANT_OFFSET) |\n            _timestamp.encodeUint(_TIMESTAMP_OFFSET); // Using 31 bits\n    }\n\n    /**\n     * @dev Unpacks a sample into its components.\n     */\n    function unpack(bytes32 sample)\n        internal\n        pure\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 _timestamp\n        )\n    {\n        logPairPrice = _instLogPairPrice(sample);\n        accLogPairPrice = _accLogPairPrice(sample);\n        logBptPrice = _instLogBptPrice(sample);\n        accLogBptPrice = _accLogBptPrice(sample);\n        logInvariant = _instLogInvariant(sample);\n        accLogInvariant = _accLogInvariant(sample);\n        _timestamp = timestamp(sample);\n    }\n}\n"
    },
    "contracts/libraries/oracle/QueryProcessor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../LogCompression.sol\";\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\n\n/**\n * @dev Auxiliary library for PoolPriceOracle, offloading most of the query code to reduce bytecode size by using this\n * as a linked library. The downside is an extra DELEGATECALL is added (2600 gas as of the Berlin hardfork), but the\n * bytecode size gains are so big (specially of the oracle contract does not use `LogCompression.fromLowResLog`) that\n * it is worth it.\n */\nlibrary QueryProcessor {\n    using Buffer for uint256;\n    using Samples for bytes32;\n    using LogCompression for int256;\n\n    /**\n     * @dev Returns the value for `variable` at the indexed sample.\n     */\n    function getInstantValue(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 index\n    ) external view returns (uint256) {\n        bytes32 sample = samples[index];\n        require(sample.timestamp() > 0, \"ORACLE_NOT_INITIALIZED\");\n\n        int256 rawInstantValue = sample.instant(variable);\n        return LogCompression.fromLowResLog(rawInstantValue);\n    }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to `query`.\n     */\n    function getTimeWeightedAverage(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.OracleAverageQuery memory query,\n        uint256 latestIndex\n    ) external view returns (uint256) {\n        require(query.secs != 0, \"ORACLE_BAD_SECS\");\n\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int256(query.secs));\n    }\n\n    /**\n     * @dev Returns the value of the accumulator for `variable` `ago` seconds ago. `latestIndex` must be the index of\n     * the latest sample in the buffer.\n     *\n     * Reverts under the following conditions:\n     *  - if the buffer is empty.\n     *  - if querying past information and the buffer has not been fully initialized.\n     *  - if querying older information than available in the buffer. Note that a full buffer guarantees queries for the\n     *    past 34 hours will not revert.\n     *\n     * If requesting information for a timestamp later than the latest one, it is extrapolated using the latest\n     * available data.\n     *\n     * When no exact information is available for the requested past timestamp (as usually happens, since at most one\n     * timestamp is stored every two minutes), it is estimated by performing linear interpolation using the closest\n     * values. This process is guaranteed to complete performing at most 10 storage reads.\n     */\n    function getPastAccumulator(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) public view returns (int256) {\n        // solhint-disable not-rely-on-time\n        // `ago` must not be before the epoch.\n        require(block.timestamp >= ago, \"ORACLE_INVALID_SECONDS_QUERY\");\n        uint256 lookUpTime = block.timestamp - ago;\n\n        bytes32 latestSample = samples[latestIndex];\n        uint256 latestTimestamp = latestSample.timestamp();\n\n        // The latest sample only has a non-zero timestamp if no data was ever processed and stored in the buffer.\n        require(latestTimestamp > 0, \"ORACLE_NOT_INITIALIZED\");\n\n        if (latestTimestamp <= lookUpTime) {\n            // The accumulator at times ahead of the latest one are computed by extrapolating the latest data. This is\n            // equivalent to the instant value not changing between the last timestamp and the look up time.\n\n            // We can use unchecked arithmetic since the accumulator can be represented in 53 bits, timestamps in 31\n            // bits, and the instant value in 22 bits.\n            uint256 elapsed = lookUpTime - latestTimestamp;\n            return latestSample.accumulator(variable) + (latestSample.instant(variable) * int256(elapsed));\n        } else {\n            // The look up time is before the latest sample, but we need to make sure that it is not before the oldest\n            // sample as well.\n\n            // Since we use a circular buffer, the oldest sample is simply the next one.\n            uint256 bufferLength;\n            uint256 oldestIndex = latestIndex.next();\n            {\n                // Local scope used to prevent stack-too-deep \"\n                bytes32 oldestSample = samples[oldestIndex];\n                uint256 oldestTimestamp = oldestSample.timestamp();\n\n                if (oldestTimestamp > 0) {\n                    // If the oldest timestamp is not zero, it means the buffer was fully initialized.\n                    bufferLength = Buffer.SIZE;\n                } else {\n                    // If the buffer was not fully initialized, we haven't wrapped around it yet,\n                    // and can treat it as a regular array where the oldest index is the first one,\n                    // and the length the number of samples.\n                    bufferLength = oldestIndex; // Equal to latestIndex.next()\n                    oldestIndex = 0;\n                    oldestTimestamp = samples[0].timestamp();\n                }\n\n                // Finally check that the look up time is not previous to the oldest timestamp.\n                require(oldestTimestamp <= lookUpTime, \"ORACLE_QUERY_TOO_OLD\");\n            }\n\n            // Perform binary search to find nearest samples to the desired timestamp.\n            (bytes32 prev, bytes32 next) = findNearestSample(samples, lookUpTime, oldestIndex, bufferLength);\n\n            // `next`'s timestamp is guaranteed to be larger than `prev`'s, so we can skip checked arithmetic.\n            uint256 samplesTimeDiff = next.timestamp() - prev.timestamp();\n\n            if (samplesTimeDiff > 0) {\n                // We estimate the accumulator at the requested look up time by interpolating linearly between the\n                // previous and next accumulators.\n\n                // We can use unchecked arithmetic since the accumulators can be represented in 53 bits, and timestamps\n                // in 31 bits.\n                int256 samplesAccDiff = next.accumulator(variable) - prev.accumulator(variable);\n                uint256 elapsed = lookUpTime - prev.timestamp();\n                return prev.accumulator(variable) + ((samplesAccDiff * int256(elapsed)) / int256(samplesTimeDiff));\n            } else {\n                // Rarely, one of the samples will have the exact requested look up time, which is indicated by `prev`\n                // and `next` being the same. In this case, we simply return the accumulator at that point in time.\n                return prev.accumulator(variable);\n            }\n        }\n    }\n\n    /**\n     * @dev Finds the two samples with timestamps before and after `lookUpDate`. If one of the samples matches exactly,\n     * both `prev` and `next` will be it. `offset` is the index of the oldest sample in the buffer. `length` is the size\n     * of the samples list.\n     *\n     * Assumes `lookUpDate` is greater or equal than the timestamp of the oldest sample, and less or equal than the\n     * timestamp of the latest sample.\n     */\n    function findNearestSample(\n        mapping(uint256 => bytes32) storage samples,\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) public view returns (bytes32 prev, bytes32 next) {\n        // We're going to perform a binary search in the circular buffer, which requires it to be sorted. To achieve\n        // this, we offset all buffer accesses by `offset`, making the first element the oldest one.\n\n        // Auxiliary variables in a typical binary search: we will look at some value `mid` between `low` and `high`,\n        // periodically increasing `low` or decreasing `high` until we either find a match or determine the element is\n        // not in the array.\n        uint256 low = 0;\n        uint256 high = length - 1;\n        uint256 mid;\n\n        // If the search fails and no sample has a timestamp of `lookUpDate` (as is the most common scenario), `sample`\n        // will be either the sample with the largest timestamp smaller than `lookUpDate`, or the one with the smallest\n        // timestamp larger than `lookUpDate`.\n        bytes32 sample;\n        uint256 sampleTimestamp;\n\n        while (low <= high) {\n            // Mid is the floor of the average.\n            uint256 midWithoutOffset = (high + low) / 2;\n\n            // Recall that the buffer is not actually sorted: we need to apply the offset to access it in a sorted way.\n            mid = midWithoutOffset.add(offset);\n            sample = samples[mid];\n            sampleTimestamp = sample.timestamp();\n\n            if (sampleTimestamp < lookUpDate) {\n                // If the mid sample is bellow the look up date, then increase the low index to start from there.\n                low = midWithoutOffset + 1;\n            } else if (sampleTimestamp > lookUpDate) {\n                // If the mid sample is above the look up date, then decrease the high index to start from there.\n\n                // We can skip checked arithmetic: it is impossible for `high` to ever be 0, as a scenario where `low`\n                // equals 0 and `high` equals 1 would result in `low` increasing to 1 in the previous `if` clause.\n                high = midWithoutOffset - 1;\n            } else {\n                // sampleTimestamp == lookUpDate\n                // If we have an exact match, return the sample as both `prev` and `next`.\n                return (sample, sample);\n            }\n        }\n\n        // In case we reach here, it means we didn't find exactly the sample we where looking for.\n        return sampleTimestamp < lookUpDate ? (sample, samples[mid.next()]) : (samples[mid.prev()], sample);\n    }\n}\n"
    },
    "contracts/libraries/smart/ManagedPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../EnumerableMap.sol\";\nimport \"../ReentrancyGuard.sol\";\nimport \"../helpers/ERC20Helpers.sol\";\nimport \"../helpers/WordCodec.sol\";\n\nimport \"../../BaseWeightedPool.sol\";\nimport \"../weighted/WeightedPoolUserDataHelpers.sol\";\nimport \"./WeightCompression.sol\";\n\n/**\n * @dev Weighted Pool with mutable tokens and weights, designed to be used in conjunction with a pool controller\n * contract (as the owner, containing any specific business logic). Since the pool itself permits \"dangerous\"\n * operations, it should never be deployed with an EOA as the owner.\n *\n * Pool controllers can add functionality: for example, allow the effective \"owner\" to be transferred to another\n * address. (The actual pool owner is still immutable, set to the pool controller contract.) Another pool owner\n * might allow fine-grained permissioning of protected operations: perhaps a multisig can add/remove tokens, but\n * a third-party EOA is allowed to set the swap fees.\n *\n * Pool controllers might also impose limits on functionality so that operations that might endanger LPs can be\n * performed more safely. For instance, the pool by itself places no restrictions on the duration of a gradual\n * weight change, but a pool controller might restrict this in various ways, from a simple minimum duration,\n * to a more complex rate limit.\n *\n * Pool controllers can also serve as intermediate contracts to hold tokens, deploy timelocks, consult with other\n * protocols or on-chain oracles, or bundle several operations into one transaction that re-entrancy protection\n * would prevent initiating from the pool contract.\n *\n * Managed Pools and their controllers are designed to support many asset management use cases, including: large\n * token counts, rebalancing through token changes, gradual weight or fee updates, circuit breakers for\n * IL-protection, and more.\n */\ncontract ManagedPool is BaseWeightedPool, ReentrancyGuard {\n    // solhint-disable not-rely-on-time\n\n    using FixedPoint for uint256;\n    using WordCodec for bytes32;\n    using WeightCompression for uint256;\n    using WeightedPoolUserDataHelpers for bytes;\n    using EnumerableMap for EnumerableMap.IERC20ToUint256Map;\n\n    // State variables\n\n    // The upper bound is WeightedMath.MAX_WEIGHTED_TOKENS, but this is constrained by other factors, such as Pool\n    // creation gas consumption.\n    uint256 private constant _MAX_MANAGED_TOKENS = 50;\n\n    // Percentage of swap fees that are allocated to the Pool owner.\n    uint256 private immutable _managementSwapFeePercentage;\n    uint256 private constant _MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 1e18; // 100%\n\n    // Use the _miscData slot in BasePool\n    // First 64 bits are reserved for the swap fee\n    //\n    // Store non-token-based values:\n    // Start/end timestamps for gradual weight update\n    // Cache total tokens\n    // [ 64 bits  |  120 bits |  32 bits  |   32 bits  |    7 bits    |    1 bit     ]\n    // [ reserved |  unused   | end time  | start time | total tokens |   swap flag  ]\n    // |MSB                                                                       LSB|\n    uint256 private constant _SWAP_ENABLED_OFFSET = 0;\n    uint256 private constant _TOTAL_TOKENS_OFFSET = 1;\n    uint256 private constant _START_TIME_OFFSET = 8;\n    uint256 private constant _END_TIME_OFFSET = 40;\n    // 7 bits is enough for the token count, since _MAX_MANAGED_TOKENS is 50\n\n    // Store scaling factor and start/end weights for each token\n    // Mapping should be more efficient than trying to compress it further\n    // [ 155 bits|   5 bits |  32 bits   |   64 bits    |\n    // [ unused  | decimals | end weight | start weight |\n    // |MSB                                          LSB|\n    mapping(IERC20 => bytes32) private _tokenState;\n\n    EnumerableMap.IERC20ToUint256Map private _tokenCollectedManagementFees;\n\n    uint256 private constant _START_WEIGHT_OFFSET = 0;\n    uint256 private constant _END_WEIGHT_OFFSET = 64;\n    uint256 private constant _DECIMAL_DIFF_OFFSET = 96;\n\n    // Event declarations\n\n    event GradualWeightUpdateScheduled(uint256 startTime, uint256 endTime, uint256[] startWeights, uint256[] endWeights);\n    event SwapEnabledSet(bool swapEnabled);\n    event ManagementFeePercentageChanged(uint256 managementFeePercentage);\n    event ManagementFeesCollected(IERC20[] tokens, uint256[] amounts);\n\n    struct NewPoolParams {\n        IVault vault;\n        string name;\n        string symbol;\n        IERC20[] tokens;\n        uint256[] normalizedWeights;\n        address[] assetManagers;\n        uint256 swapFeePercentage;\n        uint256 pauseWindowDuration;\n        uint256 bufferPeriodDuration;\n        address owner;\n        bool swapEnabledOnStart;\n        uint256 managementSwapFeePercentage;\n    }\n\n    constructor(NewPoolParams memory params)\n        BaseWeightedPool(params.vault, params.name, params.symbol, params.tokens, params.assetManagers, params.swapFeePercentage, params.pauseWindowDuration, params.bufferPeriodDuration, params.owner)\n    {\n        uint256 totalTokens = params.tokens.length;\n        InputHelpers.ensureInputLengthMatch(totalTokens, params.normalizedWeights.length, params.assetManagers.length);\n\n        _setMiscData(_getMiscData().insertUint7(totalTokens, _TOTAL_TOKENS_OFFSET));\n        // Double check it fits in 7 bits\n        _require(_getTotalTokens() == totalTokens, Errors.MAX_TOKENS);\n\n        uint256 currentTime = block.timestamp;\n        _startGradualWeightChange(currentTime, currentTime, params.normalizedWeights, params.normalizedWeights, params.tokens);\n\n        // Initialize the accrued management fees map with the Pool's tokens and zero collected fees.\n        for (uint256 i = 0; i < totalTokens; ++i) {\n            _tokenCollectedManagementFees.set(params.tokens[i], 0);\n        }\n\n        // If false, the pool will start in the disabled state (prevents front-running the enable swaps transaction)\n        _setSwapEnabled(params.swapEnabledOnStart);\n\n        // This must be inlined in the constructor as we're setting an immutable variable.\n        _require(params.managementSwapFeePercentage <= _MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE, Errors.MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE);\n        _managementSwapFeePercentage = params.managementSwapFeePercentage;\n\n        emit ManagementFeePercentageChanged(params.managementSwapFeePercentage);\n    }\n\n    /**\n     * @dev Returns true if swaps are enabled.\n     */\n    function getSwapEnabled() public view returns (bool) {\n        return _getMiscData().decodeBool(_SWAP_ENABLED_OFFSET);\n    }\n\n    /**\n     * @dev Returns the management swap fee percentage as a 18-decimals fixed point number.\n     */\n    function getManagementSwapFeePercentage() public view returns (uint256) {\n        return _managementSwapFeePercentage;\n    }\n\n    /**\n     * @dev Return start time, end time, and endWeights as an array.\n     * Current weights should be retrieved via `getNormalizedWeights()`.\n     */\n    function getGradualWeightUpdateParams()\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 endTime,\n            uint256[] memory endWeights\n        )\n    {\n        // Load current pool state from storage\n        bytes32 poolState = _getMiscData();\n\n        startTime = poolState.decodeUint32(_START_TIME_OFFSET);\n        endTime = poolState.decodeUint32(_END_TIME_OFFSET);\n\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\n        uint256 totalTokens = tokens.length;\n\n        endWeights = new uint256[](totalTokens);\n\n        for (uint256 i = 0; i < totalTokens; i++) {\n            endWeights[i] = _tokenState[tokens[i]].decodeUint32(_END_WEIGHT_OFFSET).uncompress32();\n        }\n    }\n\n    function _getMaxTokens() internal pure virtual override returns (uint256) {\n        return _MAX_MANAGED_TOKENS;\n    }\n\n    function _getTotalTokens() internal view virtual override returns (uint256) {\n        return _getMiscData().decodeUint7(_TOTAL_TOKENS_OFFSET);\n    }\n\n    /**\n     * @dev Schedule a gradual weight change, from the current weights to the given endWeights,\n     * over startTime to endTime.\n     */\n    function updateWeightsGradually(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory endWeights\n    ) external authenticate whenNotPaused nonReentrant {\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), endWeights.length);\n\n        // If the start time is in the past, \"fast forward\" to start now\n        // This avoids discontinuities in the weight curve. Otherwise, if you set the start/end times with\n        // only 10% of the period in the future, the weights would immediately jump 90%\n        uint256 currentTime = block.timestamp;\n        startTime = Math.max(currentTime, startTime);\n\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL);\n\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\n\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights, tokens);\n    }\n\n    function getCollectedManagementFees() public view returns (IERC20[] memory tokens, uint256[] memory collectedFees) {\n        tokens = new IERC20[](_getTotalTokens());\n        collectedFees = new uint256[](_getTotalTokens());\n\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            // We can use unchecked getters as we know the map has the same size (and order!) as the Pool's tokens.\n            (IERC20 token, uint256 fees) = _tokenCollectedManagementFees.unchecked_at(i);\n            tokens[i] = token;\n            collectedFees[i] = fees;\n        }\n\n        _downscaleDownArray(collectedFees, _scalingFactors());\n    }\n\n    function withdrawCollectedManagementFees(address recipient) external authenticate whenNotPaused nonReentrant {\n        (IERC20[] memory tokens, uint256[] memory collectedFees) = getCollectedManagementFees();\n\n        getVault().exitPool(\n            getPoolId(),\n            address(this),\n            payable(recipient),\n            IVault.ExitPoolRequest({assets: _asIAsset(tokens), minAmountsOut: collectedFees, userData: abi.encode(BaseWeightedPool.ExitKind.MANAGEMENT_FEE_TOKENS_OUT), toInternalBalance: false})\n        );\n\n        // Technically collectedFees is the minimum amount, not the actual amount. However, since no fees will be\n        // collected during the exit, it will also be the actual amount.\n        emit ManagementFeesCollected(tokens, collectedFees);\n    }\n\n    /*\n     * @dev Can enable/disable trading\n     */\n    function setSwapEnabled(bool swapEnabled) external authenticate whenNotPaused nonReentrant {\n        _setSwapEnabled(swapEnabled);\n    }\n\n    function _setSwapEnabled(bool swapEnabled) private {\n        _setMiscData(_getMiscData().insertBool(swapEnabled, _SWAP_ENABLED_OFFSET));\n\n        emit SwapEnabledSet(swapEnabled);\n    }\n\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\n        return _readScalingFactor(_getTokenData(token));\n    }\n\n    function _scalingFactors() internal view virtual override returns (uint256[] memory scalingFactors) {\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\n        uint256 numTokens = tokens.length;\n\n        scalingFactors = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            scalingFactors[i] = _readScalingFactor(_tokenState[tokens[i]]);\n        }\n    }\n\n    function _getNormalizedWeight(IERC20 token) internal view override returns (uint256) {\n        uint256 pctProgress = _calculateWeightChangeProgress();\n        bytes32 tokenData = _getTokenData(token);\n\n        return _interpolateWeight(tokenData, pctProgress);\n    }\n\n    function _getNormalizedWeights() internal view override returns (uint256[] memory normalizedWeights) {\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\n        uint256 numTokens = tokens.length;\n\n        normalizedWeights = new uint256[](numTokens);\n\n        uint256 pctProgress = _calculateWeightChangeProgress();\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            bytes32 tokenData = _tokenState[tokens[i]];\n\n            normalizedWeights[i] = _interpolateWeight(tokenData, pctProgress);\n        }\n    }\n\n    function _getNormalizedWeightsAndMaxWeightIndex() internal view override returns (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex) {\n        normalizedWeights = _getNormalizedWeights();\n\n        maxWeightTokenIndex = 0;\n        uint256 maxNormalizedWeight = normalizedWeights[0];\n\n        for (uint256 i = 1; i < normalizedWeights.length; i++) {\n            if (normalizedWeights[i] > maxNormalizedWeight) {\n                maxWeightTokenIndex = i;\n                maxNormalizedWeight = normalizedWeights[i];\n            }\n        }\n    }\n\n    // Swap overrides - revert unless swaps are enabled\n\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view override returns (uint256) {\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\n\n        return super._onSwapGivenIn(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view override returns (uint256) {\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\n\n        return super._onSwapGivenOut(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    /**\n     * @dev Used to adjust balances by subtracting all collected fees from them, as if they had been withdrawn from the\n     * Vault.\n     */\n    function _subtractCollectedFees(uint256[] memory balances) private view {\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            // We can use unchecked getters as we know the map has the same size (and order!) as the Pool's tokens.\n            balances[i] = balances[i].sub(_tokenCollectedManagementFees.unchecked_valueAt(i));\n        }\n    }\n\n    // We override _onJoinPool and _onExitPool as we need to not compute the current invariant and calculate protocol\n    // fees, since that mechanism does not work for Pools in which the weights change over time. Instead, this Pool\n    // always pays zero protocol fees.\n    // Additionally, we also check that only non-swap join and exit kinds are allowed while swaps are disabled.\n\n    function getLastInvariant() public pure override returns (uint256) {\n        _revert(Errors.UNHANDLED_BY_MANAGED_POOL);\n    }\n\n    function _onJoinPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        override\n        whenNotPaused // All joins are disabled while the contract is paused.\n        returns (\n            uint256 bptAmountOut,\n            uint256[] memory amountsIn,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        _subtractCollectedFees(balances);\n\n        // If swaps are disabled, the only join kind that is allowed is the proportional one, as all others involve\n        // implicit swaps and alter token prices.\n        _require(getSwapEnabled() || userData.joinKind() == JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT, Errors.INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED);\n\n        (bptAmountOut, amountsIn) = _doJoin(balances, _getNormalizedWeights(), scalingFactors, userData);\n        dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\n    }\n\n    function _onExitPool(\n        bytes32,\n        address sender,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        virtual\n        override\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        _subtractCollectedFees(balances);\n\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\n        // out) remain functional.\n\n        // If swaps are disabled, the only exit kind that is allowed is the proportional one (as all others involve\n        // implicit swaps and alter token prices) and management fee collection (as there's no point in restricting\n        // that).\n        ExitKind kind = userData.exitKind();\n        _require(getSwapEnabled() || kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT || kind == ExitKind.MANAGEMENT_FEE_TOKENS_OUT, Errors.INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED);\n\n        (bptAmountIn, amountsOut) = _doManagedPoolExit(sender, balances, _getNormalizedWeights(), scalingFactors, userData);\n        dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\n    }\n\n    function _doManagedPoolExit(\n        address sender,\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal returns (uint256, uint256[] memory) {\n        ExitKind kind = userData.exitKind();\n\n        if (kind == ExitKind.MANAGEMENT_FEE_TOKENS_OUT) {\n            return _exitManagerFeeTokensOut(sender);\n        } else {\n            return _doExit(balances, normalizedWeights, scalingFactors, userData);\n        }\n    }\n\n    function _exitManagerFeeTokensOut(address sender) private whenNotPaused returns (uint256 bptAmountIn, uint256[] memory amountsOut) {\n        // This exit function is disabled if the contract is paused.\n\n        // This exit function can only be called by the Pool itself - the authorization logic that governs when that\n        // call can be made resides in withdrawCollectedManagementFees.\n        _require(sender == address(this), Errors.UNAUTHORIZED_EXIT);\n\n        // Since what we're doing is sending out collected management fees, we don't require any BPT in exchange: we\n        // simply send those funds over.\n        bptAmountIn = 0;\n\n        amountsOut = new uint256[](_getTotalTokens());\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\n            // We can use unchecked getters and setters as we know the map has the same size (and order!) as the Pool's\n            // tokens.\n            amountsOut[i] = _tokenCollectedManagementFees.unchecked_valueAt(i);\n            _tokenCollectedManagementFees.unchecked_setAt(i, 0);\n        }\n    }\n\n    function _tokenAddressToIndex(IERC20 token) internal view override returns (uint256) {\n        return _tokenCollectedManagementFees.indexOf(token, Errors.INVALID_TOKEN);\n    }\n\n    function _processSwapFeeAmount(uint256 index, uint256 amount) internal virtual override {\n        if (amount > 0) {\n            uint256 managementFeeAmount = amount.mulDown(_managementSwapFeePercentage);\n\n            uint256 previousCollectedFees = _tokenCollectedManagementFees.unchecked_valueAt(index);\n            _tokenCollectedManagementFees.unchecked_setAt(index, previousCollectedFees.add(managementFeeAmount));\n        }\n\n        super._processSwapFeeAmount(index, amount);\n    }\n\n    // Pool swap hook override - subtract collected fees from all token amounts. We do this here as the original\n    // `onSwap` does quite a bit of work, including computing swap fees, so we need to intercept that.\n\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) public override returns (uint256) {\n        uint256 tokenInUpscaledCollectedFees = _tokenCollectedManagementFees.get(swapRequest.tokenIn, Errors.INVALID_TOKEN);\n        uint256 adjustedBalanceTokenIn = currentBalanceTokenIn.sub(_downscaleDown(tokenInUpscaledCollectedFees, _scalingFactor(swapRequest.tokenIn)));\n\n        uint256 tokenOutUpscaledCollectedFees = _tokenCollectedManagementFees.get(swapRequest.tokenOut, Errors.INVALID_TOKEN);\n        uint256 adjustedBalanceTokenOut = currentBalanceTokenOut.sub(_downscaleDown(tokenOutUpscaledCollectedFees, _scalingFactor(swapRequest.tokenOut)));\n\n        return super.onSwap(swapRequest, adjustedBalanceTokenIn, adjustedBalanceTokenOut);\n    }\n\n    /**\n     * @dev When calling updateWeightsGradually again during an update, reset the start weights to the current weights,\n     * if necessary. Time travel elements commented out.\n     */\n    function _startGradualWeightChange(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory startWeights,\n        uint256[] memory endWeights,\n        IERC20[] memory tokens\n    ) internal virtual {\n        uint256 normalizedSum = 0;\n        bytes32 tokenState;\n\n        for (uint256 i = 0; i < endWeights.length; i++) {\n            uint256 endWeight = endWeights[i];\n            _require(endWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n\n            IERC20 token = tokens[i];\n\n            // Tokens with more than 18 decimals are not supported\n            // Scaling calculations must be exact/lossless\n            // Store decimal difference instead of actual scaling factor\n            _tokenState[token] = tokenState.insertUint64(startWeights[i].compress64(), _START_WEIGHT_OFFSET).insertUint32(endWeight.compress32(), _END_WEIGHT_OFFSET).insertUint5(\n                uint256(18).sub(ERC20(address(token)).decimals()),\n                _DECIMAL_DIFF_OFFSET\n            );\n\n            normalizedSum = normalizedSum.add(endWeight);\n        }\n        // Ensure that the normalized weights sum to ONE\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\n\n        _setMiscData(_getMiscData().insertUint32(startTime, _START_TIME_OFFSET).insertUint32(endTime, _END_TIME_OFFSET));\n\n        emit GradualWeightUpdateScheduled(startTime, endTime, startWeights, endWeights);\n    }\n\n    function _readScalingFactor(bytes32 tokenState) private pure returns (uint256) {\n        uint256 decimalsDifference = tokenState.decodeUint5(_DECIMAL_DIFF_OFFSET);\n\n        return FixedPoint.ONE * 10**decimalsDifference;\n    }\n\n    /**\n     * @dev Extend ownerOnly functions to include the Managed Pool control functions.\n     */\n    function _isOwnerOnlyAction(bytes32 actionId) internal view override returns (bool) {\n        return\n            (actionId == getActionId(ManagedPool.updateWeightsGradually.selector)) ||\n            (actionId == getActionId(ManagedPool.setSwapEnabled.selector)) ||\n            (actionId == getActionId(ManagedPool.withdrawCollectedManagementFees.selector)) ||\n            super._isOwnerOnlyAction(actionId);\n    }\n\n    /**\n     * @dev Returns a fixed-point number representing how far along the current weight change is, where 0 means the\n     * change has not yet started, and FixedPoint.ONE means it has fully completed.\n     */\n    function _calculateWeightChangeProgress() private view returns (uint256) {\n        uint256 currentTime = block.timestamp;\n        bytes32 poolState = _getMiscData();\n\n        uint256 startTime = poolState.decodeUint32(_START_TIME_OFFSET);\n        uint256 endTime = poolState.decodeUint32(_END_TIME_OFFSET);\n\n        if (currentTime >= endTime) {\n            return FixedPoint.ONE;\n        } else if (currentTime <= startTime) {\n            return 0;\n        }\n\n        uint256 totalSeconds = endTime - startTime;\n        uint256 secondsElapsed = currentTime - startTime;\n\n        // In the degenerate case of a zero duration change, consider it completed (and avoid division by zero)\n        return secondsElapsed.divDown(totalSeconds);\n    }\n\n    function _interpolateWeight(bytes32 tokenData, uint256 pctProgress) private pure returns (uint256 finalWeight) {\n        uint256 startWeight = tokenData.decodeUint64(_START_WEIGHT_OFFSET).uncompress64();\n        uint256 endWeight = tokenData.decodeUint32(_END_WEIGHT_OFFSET).uncompress32();\n\n        if (pctProgress == 0 || startWeight == endWeight) return startWeight;\n        if (pctProgress >= FixedPoint.ONE) return endWeight;\n\n        if (startWeight > endWeight) {\n            uint256 weightDelta = pctProgress.mulDown(startWeight - endWeight);\n            return startWeight - weightDelta;\n        } else {\n            uint256 weightDelta = pctProgress.mulDown(endWeight - startWeight);\n            return startWeight + weightDelta;\n        }\n    }\n\n    function _getTokenData(IERC20 token) private view returns (bytes32 tokenData) {\n        tokenData = _tokenState[token];\n\n        // A valid token can't be zero (must have non-zero weights)\n        _require(tokenData != 0, Errors.INVALID_TOKEN);\n    }\n}\n"
    },
    "contracts/libraries/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the EnumerableMap library from OpenZeppelin Contracts, altered to include the following:\n//  * a map from IERC20 to bytes32\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\n//  * unchecked_at and unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\n//  * indexOf, unchecked_indexOf and unchecked_setAt, which allow for more gas efficient data writes in some scenarios\n//\n// Additionally, the base private functions that work on bytes32 were removed and replaced with a native implementation\n// for IERC20 keys, to reduce bytecode size and runtime costs.\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n */\nlibrary EnumerableMap {\n    // The original OpenZeppelin implementation uses a generic Map type with bytes32 keys: this was replaced with\n    // IERC20ToBytes32Map and IERC20ToUint256Map, resulting in more dense bytecode (as long as each contract only uses\n    // one of these - there'll otherwise be duplicated code).\n\n    // IERC20ToBytes32Map\n\n    struct IERC20ToBytes32MapEntry {\n        IERC20 _key;\n        bytes32 _value;\n    }\n\n    struct IERC20ToBytes32Map {\n        // Number of entries in the map\n        uint256 _length;\n        // Storage of map keys and values\n        mapping(uint256 => IERC20ToBytes32MapEntry) _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(IERC20 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        bytes32 value\n    ) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to !contains(map, key)\n        if (keyIndex == 0) {\n            uint256 previousLength = map._length;\n            map._entries[previousLength] = IERC20ToBytes32MapEntry({ _key: key, _value: value });\n            map._length = previousLength + 1;\n\n            // The entry is stored at previousLength, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = previousLength + 1;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\n     *\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_setAt(\n        IERC20ToBytes32Map storage map,\n        uint256 index,\n        bytes32 value\n    ) internal {\n        map._entries[index]._value = value;\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to contains(map, key)\n        if (keyIndex != 0) {\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the pseudo-array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                IERC20ToBytes32MapEntry storage lastEntry = map._entries[lastIndex];\n\n                // Move the last entry to the index where the entry to delete is\n                map._entries[toDeleteIndex] = lastEntry;\n                // Update the index for the moved entry\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved entry was stored\n            delete map._entries[lastIndex];\n            map._length = lastIndex;\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\n        return map._length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(map, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        IERC20ToBytes32MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\n     * read). O(1).\n     */\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\n        return map._entries[index]._value;\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\n     */\n    function get(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (bytes32) {\n        uint256 index = map._indexes[key];\n        _require(index > 0, errorCode);\n        return unchecked_valueAt(map, index - 1);\n    }\n\n    /**\n     * @dev Returns the index for `key`.\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function indexOf(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\n        _require(uncheckedIndex != 0, errorCode);\n        return uncheckedIndex - 1;\n    }\n\n    /**\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\n     * instead.\n     */\n    function unchecked_indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\n        return map._indexes[key];\n    }\n\n    // IERC20ToUint256Map\n\n    struct IERC20ToUint256MapEntry {\n        IERC20 _key;\n        uint256 _value;\n    }\n\n    struct IERC20ToUint256Map {\n        // Number of entries in the map\n        uint256 _length;\n        // Storage of map keys and values\n        mapping(uint256 => IERC20ToUint256MapEntry) _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(IERC20 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 value\n    ) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to !contains(map, key)\n        if (keyIndex == 0) {\n            uint256 previousLength = map._length;\n            map._entries[previousLength] = IERC20ToUint256MapEntry({ _key: key, _value: value });\n            map._length = previousLength + 1;\n\n            // The entry is stored at previousLength, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = previousLength + 1;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\n     *\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_setAt(\n        IERC20ToUint256Map storage map,\n        uint256 index,\n        uint256 value\n    ) internal {\n        map._entries[index]._value = value;\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(IERC20ToUint256Map storage map, IERC20 key) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to contains(map, key)\n        if (keyIndex != 0) {\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the pseudo-array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                IERC20ToUint256MapEntry storage lastEntry = map._entries[lastIndex];\n\n                // Move the last entry to the index where the entry to delete is\n                map._entries[toDeleteIndex] = lastEntry;\n                // Update the index for the moved entry\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved entry was stored\n            delete map._entries[lastIndex];\n            map._length = lastIndex;\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(IERC20ToUint256Map storage map, IERC20 key) internal view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(IERC20ToUint256Map storage map) internal view returns (uint256) {\n        return map._length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(map, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\n        IERC20ToUint256MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\n     * read). O(1).\n     */\n    function unchecked_valueAt(IERC20ToUint256Map storage map, uint256 index) internal view returns (uint256) {\n        return map._entries[index]._value;\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\n     */\n    function get(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 index = map._indexes[key];\n        _require(index > 0, errorCode);\n        return unchecked_valueAt(map, index - 1);\n    }\n\n    /**\n     * @dev Returns the index for `key`.\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function indexOf(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\n        _require(uncheckedIndex != 0, errorCode);\n        return uncheckedIndex - 1;\n    }\n\n    /**\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\n     * instead.\n     */\n    function unchecked_indexOf(IERC20ToUint256Map storage map, IERC20 key) internal view returns (uint256) {\n        return map._indexes[key];\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/helpers/ERC20Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/IAsset.sol\";\n\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\n// solhint-disable\n\nfunction _asIAsset(IERC20[] memory tokens) pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        assets := tokens\n    }\n}\n\nfunction _sortTokens(\n    IERC20 tokenA,\n    IERC20 tokenB,\n    IERC20 tokenC\n) pure returns (IERC20[] memory tokens) {\n    (uint256 indexTokenA, uint256 indexTokenB, uint256 indexTokenC) = _getSortedTokenIndexes(tokenA, tokenB, tokenC);\n    tokens = new IERC20[](3);\n    tokens[indexTokenA] = tokenA;\n    tokens[indexTokenB] = tokenB;\n    tokens[indexTokenC] = tokenC;\n}\n\nfunction _insertSorted(IERC20[] memory tokens, IERC20 token) pure returns (IERC20[] memory sorted) {\n    sorted = new IERC20[](tokens.length + 1);\n\n    if (tokens.length == 0) {\n        sorted[0] = token;\n        return sorted;\n    }\n\n    uint256 i;\n    for (i = tokens.length; i > 0 && tokens[i - 1] > token; i--) sorted[i] = tokens[i - 1];\n    for (uint256 j = 0; j < i; j++) sorted[j] = tokens[j];\n    sorted[i] = token;\n}\n\nfunction _getSortedTokenIndexes(\n    IERC20 tokenA,\n    IERC20 tokenB,\n    IERC20 tokenC\n)\n    pure\n    returns (\n        uint256 indexTokenA,\n        uint256 indexTokenB,\n        uint256 indexTokenC\n    )\n{\n    if (tokenA < tokenB) {\n        if (tokenB < tokenC) {\n            // (tokenA, tokenB, tokenC)\n            return (0, 1, 2);\n        } else if (tokenA < tokenC) {\n            // (tokenA, tokenC, tokenB)\n            return (0, 2, 1);\n        } else {\n            // (tokenC, tokenA, tokenB)\n            return (1, 2, 0);\n        }\n    } else {\n        // tokenB < tokenA\n        if (tokenC < tokenB) {\n            // (tokenC, tokenB, tokenA)\n            return (2, 1, 0);\n        } else if (tokenC < tokenA) {\n            // (tokenB, tokenC, tokenA)\n            return (2, 0, 1);\n        } else {\n            // (tokenB, tokenA, tokenC)\n            return (1, 0, 2);\n        }\n    }\n}\n"
    },
    "contracts/libraries/smart/WeightCompression.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../math/FixedPoint.sol\";\n\n/**\n * @dev Library for compressing and uncompresing numbers by using smaller types.\n * All values are 18 decimal fixed-point numbers in the [0.0, 1.0] range,\n * so heavier compression (fewer bits) results in fewer decimals.\n */\nlibrary WeightCompression {\n    uint256 private constant _UINT31_MAX = 2**(31) - 1;\n\n    using FixedPoint for uint256;\n\n    /**\n     * @dev Convert a 16-bit value to full FixedPoint\n     */\n    function uncompress16(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint16).max);\n    }\n\n    /**\n     * @dev Compress a FixedPoint value to 16 bits\n     */\n    function compress16(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(type(uint16).max).divUp(FixedPoint.ONE);\n    }\n\n    /**\n     * @dev Convert a 31-bit value to full FixedPoint\n     */\n    function uncompress31(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(FixedPoint.ONE).divUp(_UINT31_MAX);\n    }\n\n    /**\n     * @dev Compress a FixedPoint value to 31 bits\n     */\n    function compress31(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(_UINT31_MAX).divUp(FixedPoint.ONE);\n    }\n\n    /**\n     * @dev Convert a 32-bit value to full FixedPoint\n     */\n    function uncompress32(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint32).max);\n    }\n\n    /**\n     * @dev Compress a FixedPoint value to 32 bits\n     */\n    function compress32(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(type(uint32).max).divUp(FixedPoint.ONE);\n    }\n\n    /**\n     * @dev Convert a 64-bit value to full FixedPoint\n     */\n    function uncompress64(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint64).max);\n    }\n\n    /**\n     * @dev Compress a FixedPoint value to 64 bits\n     */\n    function compress64(uint256 value) internal pure returns (uint256) {\n        return value.mulUp(type(uint64).max).divUp(FixedPoint.ONE);\n    }\n}\n"
    },
    "contracts/libraries/smart/ManagedPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IVault.sol\";\n\nimport \"../factories/BasePoolSplitCodeFactory.sol\";\nimport \"../factories/FactoryWidePauseWindow.sol\";\n\nimport \"./ManagedPool.sol\";\n\ncontract ManagedPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(ManagedPool).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `ManagedPool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner,\n        bool swapEnabledOnStart,\n        uint256 managementSwapFeePercentage\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n            _create(\n                abi.encode(\n                    ManagedPool.NewPoolParams({\n                        vault: getVault(),\n                        name: name,\n                        symbol: symbol,\n                        tokens: tokens,\n                        normalizedWeights: weights,\n                        assetManagers: new address[](tokens.length),\n                        swapFeePercentage: swapFeePercentage,\n                        pauseWindowDuration: pauseWindowDuration,\n                        bufferPeriodDuration: bufferPeriodDuration,\n                        owner: owner,\n                        swapEnabledOnStart: swapEnabledOnStart,\n                        managementSwapFeePercentage: managementSwapFeePercentage\n                    })\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/smart/LiquidityBootstrappingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IVault.sol\";\n\nimport \"../factories/BasePoolSplitCodeFactory.sol\";\nimport \"../factories/FactoryWidePauseWindow.sol\";\n\nimport \"./LiquidityBootstrappingPool.sol\";\n\ncontract LiquidityBootstrappingPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(LiquidityBootstrappingPool).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `LiquidityBootstrappingPool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner,\n        bool swapEnabledOnStart\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n            _create(\n                abi.encode(\n                    getVault(),\n                    name,\n                    symbol,\n                    tokens,\n                    weights,\n                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner,\n                    swapEnabledOnStart\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/smart/LiquidityBootstrappingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../ReentrancyGuard.sol\";\nimport \"../helpers/WordCodec.sol\";\nimport \"../math/Math.sol\";\n\nimport \"../../BaseWeightedPool.sol\";\nimport \"./WeightCompression.sol\";\n\n/**\n * @dev Weighted Pool with mutable weights, designed to support V2 Liquidity Bootstrapping\n */\ncontract LiquidityBootstrappingPool is BaseWeightedPool, ReentrancyGuard {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    using FixedPoint for uint256;\n    using WordCodec for bytes32;\n    using WeightCompression for uint256;\n\n    // LBPs often involve only two tokens - we support up to four since we're able to pack the entire config in a single\n    // storage slot.\n    uint256 private constant _MAX_LBP_TOKENS = 4;\n\n    // State variables\n\n    uint256 private immutable _totalTokens;\n\n    IERC20 internal immutable _token0;\n    IERC20 internal immutable _token1;\n    IERC20 internal immutable _token2;\n    IERC20 internal immutable _token3;\n\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\n\n    uint256 internal immutable _scalingFactor0;\n    uint256 internal immutable _scalingFactor1;\n    uint256 internal immutable _scalingFactor2;\n    uint256 internal immutable _scalingFactor3;\n\n    // For gas optimization, store start/end weights and timestamps in one bytes32\n    // Start weights need to be high precision, since restarting the update resets them to \"spot\"\n    // values. Target end weights do not need as much precision.\n    // [     32 bits   |     32 bits     |      64 bits     |      124 bits      |    3 bits    |     1 bit    ]\n    // [ end timestamp | start timestamp | 4x16 end weights | 4x31 start weights |   not used   | swap enabled ]\n    // |MSB                                                                                                 LSB|\n\n    bytes32 private _poolState;\n\n    // Offsets for data elements in _poolState\n    uint256 private constant _SWAP_ENABLED_OFFSET = 0;\n    uint256 private constant _START_WEIGHT_OFFSET = 4;\n    uint256 private constant _END_WEIGHT_OFFSET = 128;\n    uint256 private constant _START_TIME_OFFSET = 192;\n    uint256 private constant _END_TIME_OFFSET = 224;\n\n    // Event declarations\n\n    event SwapEnabledSet(bool swapEnabled);\n    event GradualWeightUpdateScheduled(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] startWeights,\n        uint256[] endWeights\n    );\n\n    constructor(\n        IVault vault,\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory normalizedWeights,\n        uint256 swapFeePercentage,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner,\n        bool swapEnabledOnStart\n    )\n        BaseWeightedPool(\n            vault,\n            name,\n            symbol,\n            tokens,\n            new address[](tokens.length), // Pass the zero address: LBPs can't have asset managers\n            swapFeePercentage,\n            pauseWindowDuration,\n            bufferPeriodDuration,\n            owner\n        )\n    {\n        uint256 totalTokens = tokens.length;\n        InputHelpers.ensureInputLengthMatch(totalTokens, normalizedWeights.length);\n\n        _totalTokens = totalTokens;\n\n        // Immutable variables cannot be initialized inside an if statement, so we must do conditional assignments\n        _token0 = tokens[0];\n        _token1 = tokens[1];\n        _token2 = totalTokens > 2 ? tokens[2] : IERC20(address(0));\n        _token3 = totalTokens > 3 ? tokens[3] : IERC20(address(0));\n\n        _scalingFactor0 = _computeScalingFactor(tokens[0]);\n        _scalingFactor1 = _computeScalingFactor(tokens[1]);\n        _scalingFactor2 = totalTokens > 2 ? _computeScalingFactor(tokens[2]) : 0;\n        _scalingFactor3 = totalTokens > 3 ? _computeScalingFactor(tokens[3]) : 0;\n\n        uint256 currentTime = block.timestamp;\n\n        _startGradualWeightChange(currentTime, currentTime, normalizedWeights, normalizedWeights);\n\n        // If false, the pool will start in the disabled state (prevents front-running the enable swaps transaction)\n        _setSwapEnabled(swapEnabledOnStart);\n    }\n\n    // External functions\n\n    /**\n     * @dev Tells whether swaps are enabled or not for the given pool.\n     */\n    function getSwapEnabled() public view returns (bool) {\n        return _poolState.decodeBool(_SWAP_ENABLED_OFFSET);\n    }\n\n    /**\n     * @dev Return start time, end time, and endWeights as an array.\n     * Current weights should be retrieved via `getNormalizedWeights()`.\n     */\n    function getGradualWeightUpdateParams()\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 endTime,\n            uint256[] memory endWeights\n        )\n    {\n        // Load current pool state from storage\n        bytes32 poolState = _poolState;\n\n        startTime = poolState.decodeUint32(_START_TIME_OFFSET);\n        endTime = poolState.decodeUint32(_END_TIME_OFFSET);\n        uint256 totalTokens = _getTotalTokens();\n        endWeights = new uint256[](totalTokens);\n\n        for (uint256 i = 0; i < totalTokens; i++) {\n            endWeights[i] = poolState.decodeUint16(_END_WEIGHT_OFFSET + i * 16).uncompress16();\n        }\n    }\n\n    /**\n     * @dev Can pause/unpause trading\n     */\n    function setSwapEnabled(bool swapEnabled) external authenticate whenNotPaused nonReentrant {\n        _setSwapEnabled(swapEnabled);\n    }\n\n    /**\n     * @dev Schedule a gradual weight change, from the current weights to the given endWeights,\n     * over startTime to endTime\n     */\n    function updateWeightsGradually(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory endWeights\n    ) external authenticate whenNotPaused nonReentrant {\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), endWeights.length);\n\n        // If the start time is in the past, \"fast forward\" to start now\n        // This avoids discontinuities in the weight curve. Otherwise, if you set the start/end times with\n        // only 10% of the period in the future, the weights would immediately jump 90%\n        uint256 currentTime = block.timestamp;\n        startTime = Math.max(currentTime, startTime);\n\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL);\n\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights);\n    }\n\n    // Internal functions\n\n    function _getNormalizedWeight(IERC20 token) internal view override returns (uint256) {\n        uint256 i;\n\n        // First, convert token address to a token index\n\n        // prettier-ignore\n        if (token == _token0) { i = 0; }\n        else if (token == _token1) { i = 1; }\n        else if (token == _token2) { i = 2; }\n        else if (token == _token3) { i = 3; }\n        else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n\n        return _getNormalizedWeightByIndex(i, _poolState);\n    }\n\n    function _getNormalizedWeightByIndex(uint256 i, bytes32 poolState) internal view returns (uint256) {\n        uint256 startWeight = poolState.decodeUint31(_START_WEIGHT_OFFSET + i * 31).uncompress31();\n        uint256 endWeight = poolState.decodeUint16(_END_WEIGHT_OFFSET + i * 16).uncompress16();\n\n        uint256 pctProgress = _calculateWeightChangeProgress(poolState);\n\n        return _interpolateWeight(startWeight, endWeight, pctProgress);\n    }\n\n    function _getNormalizedWeights() internal view override returns (uint256[] memory) {\n        uint256 totalTokens = _getTotalTokens();\n        uint256[] memory normalizedWeights = new uint256[](totalTokens);\n\n        bytes32 poolState = _poolState;\n\n        // prettier-ignore\n        {\n            normalizedWeights[0] = _getNormalizedWeightByIndex(0, poolState);\n            normalizedWeights[1] = _getNormalizedWeightByIndex(1, poolState);\n            if (totalTokens == 2) return normalizedWeights;\n            normalizedWeights[2] = _getNormalizedWeightByIndex(2, poolState);\n            if (totalTokens == 3) return normalizedWeights;\n            normalizedWeights[3] = _getNormalizedWeightByIndex(3, poolState);\n        }\n\n        return normalizedWeights;\n    }\n\n    function _getNormalizedWeightsAndMaxWeightIndex()\n        internal\n        view\n        override\n        returns (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex)\n    {\n        normalizedWeights = _getNormalizedWeights();\n\n        maxWeightTokenIndex = 0;\n        uint256 maxNormalizedWeight = normalizedWeights[0];\n\n        for (uint256 i = 1; i < normalizedWeights.length; i++) {\n            if (normalizedWeights[i] > maxNormalizedWeight) {\n                maxWeightTokenIndex = i;\n                maxNormalizedWeight = normalizedWeights[i];\n            }\n        }\n    }\n\n    // Pool callback functions\n\n    // Prevent any account other than the owner from joining the pool\n\n    function _onInitializePool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal override returns (uint256, uint256[] memory) {\n        // Only the owner can initialize the pool\n        _require(sender == getOwner(), Errors.CALLER_IS_NOT_LBP_OWNER);\n\n        return super._onInitializePool(poolId, sender, recipient, scalingFactors, userData);\n    }\n\n    function _onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    )\n        internal\n        override\n        returns (\n            uint256,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        // Only the owner can add liquidity; block public LPs\n        _require(sender == getOwner(), Errors.CALLER_IS_NOT_LBP_OWNER);\n\n        return\n            super._onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n    }\n\n    // Swap overrides - revert unless swaps are enabled\n\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view override returns (uint256) {\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\n\n        return super._onSwapGivenIn(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal view override returns (uint256) {\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\n\n        return super._onSwapGivenOut(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    /**\n     * @dev Extend ownerOnly functions to include the LBP control functions\n     */\n    function _isOwnerOnlyAction(bytes32 actionId) internal view override returns (bool) {\n        return\n            (actionId == getActionId(LiquidityBootstrappingPool.setSwapEnabled.selector)) ||\n            (actionId == getActionId(LiquidityBootstrappingPool.updateWeightsGradually.selector)) ||\n            super._isOwnerOnlyAction(actionId);\n    }\n\n    // Private functions\n\n    /**\n     * @dev Returns a fixed-point number representing how far along the current weight change is, where 0 means the\n     * change has not yet started, and FixedPoint.ONE means it has fully completed.\n     */\n    function _calculateWeightChangeProgress(bytes32 poolState) private view returns (uint256) {\n        uint256 currentTime = block.timestamp;\n        uint256 startTime = poolState.decodeUint32(_START_TIME_OFFSET);\n        uint256 endTime = poolState.decodeUint32(_END_TIME_OFFSET);\n\n        if (currentTime > endTime) {\n            return FixedPoint.ONE;\n        } else if (currentTime < startTime) {\n            return 0;\n        }\n\n        // No need for SafeMath as it was checked right above: endTime >= currentTime >= startTime\n        uint256 totalSeconds = endTime - startTime;\n        uint256 secondsElapsed = currentTime - startTime;\n\n        // In the degenerate case of a zero duration change, consider it completed (and avoid division by zero)\n        return totalSeconds == 0 ? FixedPoint.ONE : secondsElapsed.divDown(totalSeconds);\n    }\n\n    /**\n     * @dev When calling updateWeightsGradually again during an update, reset the start weights to the current weights,\n     * if necessary.\n     */\n    function _startGradualWeightChange(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory startWeights,\n        uint256[] memory endWeights\n    ) internal virtual {\n        bytes32 newPoolState = _poolState;\n\n        uint256 normalizedSum = 0;\n        for (uint256 i = 0; i < endWeights.length; i++) {\n            uint256 endWeight = endWeights[i];\n            _require(endWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n\n            newPoolState = newPoolState\n                .insertUint31(startWeights[i].compress31(), _START_WEIGHT_OFFSET + i * 31)\n                .insertUint16(endWeight.compress16(), _END_WEIGHT_OFFSET + i * 16);\n\n            normalizedSum = normalizedSum.add(endWeight);\n        }\n        // Ensure that the normalized weights sum to ONE\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\n\n        _poolState = newPoolState.insertUint32(startTime, _START_TIME_OFFSET).insertUint32(endTime, _END_TIME_OFFSET);\n\n        emit GradualWeightUpdateScheduled(startTime, endTime, startWeights, endWeights);\n    }\n\n    function _interpolateWeight(\n        uint256 startWeight,\n        uint256 endWeight,\n        uint256 pctProgress\n    ) private pure returns (uint256) {\n        if (pctProgress == 0 || startWeight == endWeight) return startWeight;\n        if (pctProgress >= FixedPoint.ONE) return endWeight;\n\n        if (startWeight > endWeight) {\n            uint256 weightDelta = pctProgress.mulDown(startWeight - endWeight);\n            return startWeight.sub(weightDelta);\n        } else {\n            uint256 weightDelta = pctProgress.mulDown(endWeight - startWeight);\n            return startWeight.add(weightDelta);\n        }\n    }\n\n    function _setSwapEnabled(bool swapEnabled) private {\n        _poolState = _poolState.insertBool(swapEnabled, _SWAP_ENABLED_OFFSET);\n        emit SwapEnabledSet(swapEnabled);\n    }\n\n    function _getMaxTokens() internal pure override returns (uint256) {\n        return _MAX_LBP_TOKENS;\n    }\n\n    function _getTotalTokens() internal view virtual override returns (uint256) {\n        return _totalTokens;\n    }\n\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\n        // prettier-ignore\n        if (token == _token0) { return _scalingFactor0; }\n        else if (token == _token1) { return _scalingFactor1; }\n        else if (token == _token2) { return _scalingFactor2; }\n        else if (token == _token3) { return _scalingFactor3; }\n        else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    function _scalingFactors() internal view virtual override returns (uint256[] memory) {\n        uint256 totalTokens = _getTotalTokens();\n        uint256[] memory scalingFactors = new uint256[](totalTokens);\n\n        // prettier-ignore\n        {\n            scalingFactors[0] = _scalingFactor0;\n            scalingFactors[1] = _scalingFactor1;\n            if (totalTokens > 2) { scalingFactors[2] = _scalingFactor2; } else { return scalingFactors; }\n            if (totalTokens > 3) { scalingFactors[3] = _scalingFactor3; } else { return scalingFactors; }\n        }\n\n        return scalingFactors;\n    }\n}\n"
    },
    "contracts/test/vault/MockPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/math/FixedPoint.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IVault.sol\";\nimport \"../../interfaces/IGeneralPool.sol\";\nimport \"../../interfaces/IMinimalSwapInfoPool.sol\";\n\ncontract MockPool is IGeneralPool, IMinimalSwapInfoPool {\n    using FixedPoint for uint256;\n\n    IVault private immutable _vault;\n    bytes32 private immutable _poolId;\n\n    constructor(IVault vault, IVault.PoolSpecialization specialization) {\n        _poolId = vault.registerPool(specialization);\n        _vault = vault;\n    }\n\n    function getVault() external view returns (IVault) {\n        return _vault;\n    }\n\n    function getPoolId() public view override returns (bytes32) {\n        return _poolId;\n    }\n\n    function registerTokens(IERC20[] memory tokens, address[] memory assetManagers) external {\n        _vault.registerTokens(_poolId, tokens, assetManagers);\n    }\n\n    function deregisterTokens(IERC20[] memory tokens) external {\n        _vault.deregisterTokens(_poolId, tokens);\n    }\n\n    event OnJoinPoolCalled(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] currentBalances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes userData\n    );\n\n    event OnExitPoolCalled(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] currentBalances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes userData\n    );\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory currentBalances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {\n        emit OnJoinPoolCalled(\n            poolId,\n            sender,\n            recipient,\n            currentBalances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        (amountsIn, dueProtocolFeeAmounts) = abi.decode(userData, (uint256[], uint256[]));\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory currentBalances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {\n        emit OnExitPoolCalled(\n            poolId,\n            sender,\n            recipient,\n            currentBalances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        (amountsOut, dueProtocolFeeAmounts) = abi.decode(userData, (uint256[], uint256[]));\n    }\n\n    // Amounts in are multiplied by the multiplier, amounts out are divided by it\n    uint256 private _multiplier = FixedPoint.ONE;\n\n    function setMultiplier(uint256 newMultiplier) external {\n        _multiplier = newMultiplier;\n    }\n\n    // IGeneralPool\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256[] memory,\n        uint256,\n        uint256\n    ) external view override returns (uint256 amount) {\n        return\n            swapRequest.kind == IVault.SwapKind.GIVEN_IN\n                ? swapRequest.amount.mulDown(_multiplier)\n                : swapRequest.amount.divDown(_multiplier);\n    }\n\n    // IMinimalSwapInfoPool\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256,\n        uint256\n    ) external view override returns (uint256) {\n        return\n            swapRequest.kind == IVault.SwapKind.GIVEN_IN\n                ? swapRequest.amount.mulDown(_multiplier)\n                : swapRequest.amount.divDown(_multiplier);\n    }\n}\n"
    },
    "contracts/interfaces/IGeneralPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IBasePool.sol\";\n\n/**\n * @dev IPools with the General specialization setting should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will\n * grant to the pool in a 'given out' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IGeneralPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/Swaps.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./libraries//EnumerableMap.sol\";\nimport \"./libraries//EnumerableSet.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./PoolBalances.sol\";\nimport \"./interfaces/IPoolSwapStructs.sol\";\nimport \"./interfaces/IGeneralPool.sol\";\nimport \"./interfaces/IMinimalSwapInfoPool.sol\";\nimport \"./libraries/balances/BalanceAllocation.sol\";\n\n/**\n * Implements the Vault's high-level swap functionality.\n *\n * Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. They need not trust the Pool\n * contracts to do this: all security checks are made by the Vault.\n *\n * The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n * In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n * and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n * More complex swaps, such as one 'token in' to multiple tokens out can be achieved by batching together\n * individual swaps.\n */\nabstract contract Swaps is ReentrancyGuard, PoolBalances {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\n\n    using Math for int256;\n    using Math for uint256;\n    using SafeCast for uint256;\n    using BalanceAllocation for bytes32;\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPausedVault\n        authenticateFor(funds.sender)\n        returns (uint256 amountCalculated)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        // This revert reason is for consistency with `batchSwap`: an equivalent `swap` performed using that function\n        // would result in this error.\n        _require(singleSwap.amount > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n\n        IERC20 tokenIn = _translateToIERC20(singleSwap.assetIn);\n        IERC20 tokenOut = _translateToIERC20(singleSwap.assetOut);\n        _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n        // Initializing each struct field one-by-one uses less gas than setting all at once.\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n        poolRequest.poolId = singleSwap.poolId;\n        poolRequest.kind = singleSwap.kind;\n        poolRequest.tokenIn = tokenIn;\n        poolRequest.tokenOut = tokenOut;\n        poolRequest.amount = singleSwap.amount;\n        poolRequest.userData = singleSwap.userData;\n        poolRequest.from = funds.sender;\n        poolRequest.to = funds.recipient;\n        // The lastChangeBlock field is left uninitialized.\n\n        uint256 amountIn;\n        uint256 amountOut;\n\n        (amountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n        _require(singleSwap.kind == SwapKind.GIVEN_IN ? amountOut >= limit : amountIn <= limit, Errors.SWAP_LIMIT);\n\n        _receiveAsset(singleSwap.assetIn, amountIn, funds.sender, funds.fromInternalBalance);\n        _sendAsset(singleSwap.assetOut, amountOut, funds.recipient, funds.toInternalBalance);\n\n        // If the asset in is ETH, then `amountIn` ETH was wrapped into WETH.\n        _handleRemainingEth(_isETH(singleSwap.assetIn) ? amountIn : 0);\n    }\n\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPausedVault\n        authenticateFor(funds.sender)\n        returns (int256[] memory assetDeltas)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        InputHelpers.ensureInputLengthMatch(assets.length, limits.length);\n\n        // Perform the swaps, updating the Pool token balances and computing the net Vault asset deltas.\n        assetDeltas = _swapWithPools(swaps, assets, funds, kind);\n\n        // Process asset deltas, by either transferring assets from the sender (for positive deltas) or to the recipient\n        // (for negative deltas).\n        uint256 wrappedEth = 0;\n        for (uint256 i = 0; i < assets.length; ++i) {\n            IAsset asset = assets[i];\n            int256 delta = assetDeltas[i];\n            _require(delta <= limits[i], Errors.SWAP_LIMIT);\n\n            if (delta > 0) {\n                uint256 toReceive = uint256(delta);\n                _receiveAsset(asset, toReceive, funds.sender, funds.fromInternalBalance);\n\n                if (_isETH(asset)) {\n                    wrappedEth = wrappedEth.add(toReceive);\n                }\n            } else if (delta < 0) {\n                uint256 toSend = uint256(-delta);\n                _sendAsset(asset, toSend, funds.recipient, funds.toInternalBalance);\n            }\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }\n\n    // For `_swapWithPools` to handle both 'given in' and 'given out' swaps, it internally tracks the 'given' amount\n    // (supplied by the caller), and the 'calculated' amount (returned by the Pool in response to the swap request).\n\n    /**\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'given' token (the token whose\n     * amount is supplied by the caller).\n     */\n    function _tokenGiven(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenIn : tokenOut;\n    }\n\n    /**\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'calculated' token (the token whose\n     * amount is calculated by the Pool).\n     */\n    function _tokenCalculated(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenOut : tokenIn;\n    }\n\n    /**\n     * @dev Returns an ordered pair (amountIn, amountOut) given the 'given' and 'calculated' amounts, and the swap kind.\n     */\n    function _getAmounts(\n        SwapKind kind,\n        uint256 amountGiven,\n        uint256 amountCalculated\n    ) private pure returns (uint256 amountIn, uint256 amountOut) {\n        if (kind == SwapKind.GIVEN_IN) {\n            (amountIn, amountOut) = (amountGiven, amountCalculated);\n        } else {\n            // SwapKind.GIVEN_OUT\n            (amountIn, amountOut) = (amountCalculated, amountGiven);\n        }\n    }\n\n    /**\n     * @dev Performs all `swaps`, calling swap hooks on the Pool contracts and updating their balances. Does not cause\n     * any transfer of tokens - instead it returns the net Vault token deltas: positive if the Vault should receive\n     * tokens, and negative if it should send them.\n     */\n    function _swapWithPools(\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        SwapKind kind\n    ) private returns (int256[] memory assetDeltas) {\n        assetDeltas = new int256[](assets.length);\n\n        // These variables could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        BatchSwapStep memory batchSwapStep;\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n\n        // These store data about the previous swap here to implement multihop logic across swaps.\n        IERC20 previousTokenCalculated;\n        uint256 previousAmountCalculated;\n\n        for (uint256 i = 0; i < swaps.length; ++i) {\n            batchSwapStep = swaps[i];\n\n            bool withinBounds = batchSwapStep.assetInIndex < assets.length &&\n                batchSwapStep.assetOutIndex < assets.length;\n            _require(withinBounds, Errors.OUT_OF_BOUNDS);\n\n            IERC20 tokenIn = _translateToIERC20(assets[batchSwapStep.assetInIndex]);\n            IERC20 tokenOut = _translateToIERC20(assets[batchSwapStep.assetOutIndex]);\n            _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n            // Sentinel value for multihop logic\n            if (batchSwapStep.amount == 0) {\n                // When the amount given is zero, we use the calculated amount for the previous swap, as long as the\n                // current swap's given token is the previous calculated token. This makes it possible to swap a\n                // given amount of token A for token B, and then use the resulting token B amount to swap for token C.\n                _require(i > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n                bool usingPreviousToken = previousTokenCalculated == _tokenGiven(kind, tokenIn, tokenOut);\n                _require(usingPreviousToken, Errors.MALCONSTRUCTED_MULTIHOP_SWAP);\n                batchSwapStep.amount = previousAmountCalculated;\n            }\n\n            // Initializing each struct field one-by-one uses less gas than setting all at once\n            poolRequest.poolId = batchSwapStep.poolId;\n            poolRequest.kind = kind;\n            poolRequest.tokenIn = tokenIn;\n            poolRequest.tokenOut = tokenOut;\n            poolRequest.amount = batchSwapStep.amount;\n            poolRequest.userData = batchSwapStep.userData;\n            poolRequest.from = funds.sender;\n            poolRequest.to = funds.recipient;\n            // The lastChangeBlock field is left uninitialized\n\n            uint256 amountIn;\n            uint256 amountOut;\n            (previousAmountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n\n            previousTokenCalculated = _tokenCalculated(kind, tokenIn, tokenOut);\n\n            // Accumulate Vault deltas across swaps\n            assetDeltas[batchSwapStep.assetInIndex] = assetDeltas[batchSwapStep.assetInIndex].add(amountIn.toInt256());\n            assetDeltas[batchSwapStep.assetOutIndex] = assetDeltas[batchSwapStep.assetOutIndex].sub(\n                amountOut.toInt256()\n            );\n        }\n    }\n\n    /**\n     * @dev Performs a swap according to the parameters specified in `request`, calling the Pool's contract hook and\n     * updating the Pool's balance.\n     *\n     * Returns the amount of tokens going into or out of the Vault as a result of this swap, depending on the swap kind.\n     */\n    function _swapWithPool(IPoolSwapStructs.SwapRequest memory request)\n        private\n        returns (\n            uint256 amountCalculated,\n            uint256 amountIn,\n            uint256 amountOut\n        )\n    {\n        // Get the calculated amount from the Pool and update its balances\n        address pool = _getPoolAddress(request.poolId);\n        PoolSpecialization specialization = _getPoolSpecialization(request.poolId);\n\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            amountCalculated = _processTwoTokenPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            amountCalculated = _processMinimalSwapInfoPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\n        } else {\n            // PoolSpecialization.GENERAL\n            amountCalculated = _processGeneralPoolSwapRequest(request, IGeneralPool(pool));\n        }\n\n        (amountIn, amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n        emit Swap(request.poolId, request.tokenIn, request.tokenOut, amountIn, amountOut);\n    }\n\n    function _processTwoTokenPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IMinimalSwapInfoPool pool)\n        private\n        returns (uint256 amountCalculated)\n    {\n        // For gas efficiency reasons, this function uses low-level knowledge of how Two Token Pool balances are\n        // stored internally, instead of using getters and setters for all operations.\n\n        (\n            bytes32 tokenABalance,\n            bytes32 tokenBBalance,\n            TwoTokenPoolBalances storage poolBalances\n        ) = _getTwoTokenPoolSharedBalances(request.poolId, request.tokenIn, request.tokenOut);\n\n        // We have the two Pool balances, but we don't know which one is 'token in' or 'token out'.\n        bytes32 tokenInBalance;\n        bytes32 tokenOutBalance;\n\n        // In Two Token Pools, token A has a smaller address than token B\n        if (request.tokenIn < request.tokenOut) {\n            // in is A, out is B\n            tokenInBalance = tokenABalance;\n            tokenOutBalance = tokenBBalance;\n        } else {\n            // in is B, out is A\n            tokenOutBalance = tokenABalance;\n            tokenInBalance = tokenBBalance;\n        }\n\n        // Perform the swap request and compute the new balances for 'token in' and 'token out' after the swap\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\n            request,\n            pool,\n            tokenInBalance,\n            tokenOutBalance\n        );\n\n        // We check the token ordering again to create the new shared cash packed struct\n        poolBalances.sharedCash = request.tokenIn < request.tokenOut\n            ? BalanceAllocation.toSharedCash(tokenInBalance, tokenOutBalance) // in is A, out is B\n            : BalanceAllocation.toSharedCash(tokenOutBalance, tokenInBalance); // in is B, out is A\n    }\n\n    function _processMinimalSwapInfoPoolSwapRequest(\n        IPoolSwapStructs.SwapRequest memory request,\n        IMinimalSwapInfoPool pool\n    ) private returns (uint256 amountCalculated) {\n        bytes32 tokenInBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenIn);\n        bytes32 tokenOutBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenOut);\n\n        // Perform the swap request and compute the new balances for 'token in' and 'token out' after the swap\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\n            request,\n            pool,\n            tokenInBalance,\n            tokenOutBalance\n        );\n\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenIn] = tokenInBalance;\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenOut] = tokenOutBalance;\n    }\n\n    /**\n     * @dev Calls the onSwap hook for a Pool that implements IMinimalSwapInfoPool: both Minimal Swap Info and Two Token\n     * Pools do this.\n     */\n    function _callMinimalSwapInfoPoolOnSwapHook(\n        IPoolSwapStructs.SwapRequest memory request,\n        IMinimalSwapInfoPool pool,\n        bytes32 tokenInBalance,\n        bytes32 tokenOutBalance\n    )\n        internal\n        returns (\n            bytes32 newTokenInBalance,\n            bytes32 newTokenOutBalance,\n            uint256 amountCalculated\n        )\n    {\n        uint256 tokenInTotal = tokenInBalance.total();\n        uint256 tokenOutTotal = tokenOutBalance.total();\n        request.lastChangeBlock = Math.max(tokenInBalance.lastChangeBlock(), tokenOutBalance.lastChangeBlock());\n\n        // Perform the swap request callback, and compute the new balances for 'token in' and 'token out' after the swap\n        amountCalculated = pool.onSwap(request, tokenInTotal, tokenOutTotal);\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n\n        newTokenInBalance = tokenInBalance.increaseCash(amountIn);\n        newTokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\n    }\n\n    function _processGeneralPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IGeneralPool pool)\n        private\n        returns (uint256 amountCalculated)\n    {\n        bytes32 tokenInBalance;\n        bytes32 tokenOutBalance;\n\n        // We access both token indexes without checking existence, because we will do it manually immediately after.\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[request.poolId];\n        uint256 indexIn = poolBalances.unchecked_indexOf(request.tokenIn);\n        uint256 indexOut = poolBalances.unchecked_indexOf(request.tokenOut);\n\n        if (indexIn == 0 || indexOut == 0) {\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(request.poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        // EnumerableMap stores indices *plus one* to use the zero index as a sentinel value - because these are valid,\n        // we can undo this.\n        indexIn -= 1;\n        indexOut -= 1;\n\n        uint256 tokenAmount = poolBalances.length();\n        uint256[] memory currentBalances = new uint256[](tokenAmount);\n\n        request.lastChangeBlock = 0;\n        for (uint256 i = 0; i < tokenAmount; i++) {\n            // Because the iteration is bounded by `tokenAmount`, and no tokens are registered or deregistered here, we\n            // know `i` is a valid token index and can use `unchecked_valueAt` to save storage reads.\n            bytes32 balance = poolBalances.unchecked_valueAt(i);\n\n            currentBalances[i] = balance.total();\n            request.lastChangeBlock = Math.max(request.lastChangeBlock, balance.lastChangeBlock());\n\n            if (i == indexIn) {\n                tokenInBalance = balance;\n            } else if (i == indexOut) {\n                tokenOutBalance = balance;\n            }\n        }\n\n        // Perform the swap request callback and compute the new balances for 'token in' and 'token out' after the swap\n        amountCalculated = pool.onSwap(request, currentBalances, indexIn, indexOut);\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n        tokenInBalance = tokenInBalance.increaseCash(amountIn);\n        tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\n\n        // Because no tokens were registered or deregistered between now or when we retrieved the indexes for\n        // 'token in' and 'token out', we can use `unchecked_setAt` to save storage reads.\n        poolBalances.unchecked_setAt(indexIn, tokenInBalance);\n        poolBalances.unchecked_setAt(indexOut, tokenOutBalance);\n    }\n\n    // This function is not marked as `nonReentrant` because the underlying mechanism relies on reentrancy\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external override returns (int256[] memory) {\n        // In order to accurately 'simulate' swaps, this function actually does perform the swaps, including calling the\n        // Pool hooks and updating balances in storage. However, once it computes the final Vault Deltas, it\n        // reverts unconditionally, returning this array as the revert data.\n        //\n        // By wrapping this reverting call, we can decode the deltas 'returned' and return them as a normal Solidity\n        // function would. The only caveat is the function becomes non-view, but off-chain clients can still call it\n        // via eth_call to get the expected result.\n        //\n        // This technique was inspired by the work from the Gnosis team in the Gnosis Safe contract:\n        // https://github.com/gnosis/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L265\n        //\n        // Most of this function is implemented using inline assembly, as the actual work it needs to do is not\n        // significant, and Solidity is not particularly well-suited to generate this behavior, resulting in a large\n        // amount of generated bytecode.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the actual asset deltas from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0xfa61cc1200000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of an array:\n                        // length + data. We need to return an ABI-encoded representation of this array.\n                        // An ABI-encoded array contains an additional field when compared to its raw memory\n                        // representation: an offset to the location of the length. The offset itself is 32 bytes long,\n                        // so the smallest value we  can use is 32 for the data to be located immediately after it.\n                        mstore(0, 32)\n\n                        // We now copy the raw memory array from returndata into memory. Since the offset takes up 32\n                        // bytes, we start copying at address 0x20. We also get rid of the error signature, which takes\n                        // the first four bytes of returndata.\n                        let size := sub(returndatasize(), 0x04)\n                        returndatacopy(0x20, 0x04, size)\n\n                        // We finally return the ABI-encoded array, which has a total length equal to that of the array\n                        // (returndata), plus the 32 bytes for the offset.\n                        return(0, add(size, 32))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn't happen\n                        invalid()\n                    }\n            }\n        } else {\n            int256[] memory deltas = _swapWithPools(swaps, assets, funds, kind);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of the array in memory, which is composed of a 32 byte length,\n                // followed by the 32 byte int256 values. Because revert expects a size in bytes, we multiply the array\n                // length (stored at `deltas`) by 32.\n                let size := mul(mload(deltas), 32)\n\n                // We send one extra value for the error signature \"QueryError(int256[])\" which is 0xfa61cc12.\n                // We store it in the previous slot to the `deltas` array. We know there will be at least one available\n                // slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                mstore(sub(deltas, 0x20), 0x00000000000000000000000000000000000000000000000000000000fa61cc12)\n                let start := sub(deltas, 0x04)\n\n                // When copying from `deltas` into returndata, we copy an additional 36 bytes to also return the array's\n                // length and the error signature.\n                revert(start, add(size, 36))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        _require(value < 2**255, Errors.SAFE_CAST_VALUE_CANT_FIT_INT256);\n        return int256(value);\n    }\n}\n"
    },
    "contracts/PoolBalances.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./Fees.sol\";\nimport \"./PoolTokens.sol\";\nimport \"./UserBalance.sol\";\nimport \"./interfaces/IBasePool.sol\";\n\n/**\n * @dev Stores the Asset Managers (by Pool and token), and implements the top level Asset Manager and Pool interfaces,\n * such as registering and deregistering tokens, joining and exiting Pools, and informational functions like `getPool`\n * and `getPoolTokens`, delegating to specialization-specific functions as needed.\n *\n * `managePoolBalance` handles all Asset Manager interactions.\n */\nabstract contract PoolBalances is Fees, ReentrancyGuard, PoolTokens, UserBalance {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n    using BalanceAllocation for bytes32;\n    using BalanceAllocation for bytes32[];\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPausedVault {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request));\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external override {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n        _joinOrExit(PoolBalanceChangeKind.EXIT, poolId, sender, recipient, _toPoolBalanceChange(request));\n    }\n\n    // This has the exact same layout as JoinPoolRequest and ExitPoolRequest, except the `maxAmountsIn` and\n    // `minAmountsOut` are called `limits`. Internally we use this struct for both since these two functions are quite\n    // similar, but expose the others to callers for clarity.\n    struct PoolBalanceChange {\n        IAsset[] assets;\n        uint256[] limits;\n        bytes userData;\n        bool useInternalBalance;\n    }\n\n    /**\n     * @dev Converts a JoinPoolRequest into a PoolBalanceChange, with no runtime cost.\n     */\n    function _toPoolBalanceChange(JoinPoolRequest memory request)\n        private\n        pure\n        returns (PoolBalanceChange memory change)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    /**\n     * @dev Converts an ExitPoolRequest into a PoolBalanceChange, with no runtime cost.\n     */\n    function _toPoolBalanceChange(ExitPoolRequest memory request)\n        private\n        pure\n        returns (PoolBalanceChange memory change)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    /**\n     * @dev Implements both `joinPool` and `exitPool`, based on `kind`.\n     */\n    function _joinOrExit(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change\n    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) {\n        // This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,\n        // etc.), which leads to 'stack too deep' issues. It relies on private functions with seemingly arbitrary\n        // interfaces to work around this limitation.\n\n        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);\n\n        // We first check that the caller passed the Pool's registered tokens in the correct order, and retrieve the\n        // current balance for each.\n        IERC20[] memory tokens = _translateToIERC20(change.assets);\n        bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, its final balances are computed,\n        // assets are transferred, and fees are paid.\n        (\n            bytes32[] memory finalBalances,\n            uint256[] memory amountsInOrOut,\n            uint256[] memory paidProtocolSwapFeeAmounts\n        ) = _callPoolBalanceChange(kind, poolId, sender, recipient, change, balances);\n\n        // All that remains is storing the new Pool balances.\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _setTwoTokenPoolCashBalances(poolId, tokens[0], finalBalances[0], tokens[1], finalBalances[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _setMinimalSwapInfoPoolBalances(poolId, tokens, finalBalances);\n        } else {\n            // PoolSpecialization.GENERAL\n            _setGeneralPoolBalances(poolId, finalBalances);\n        }\n\n        bool positive = kind == PoolBalanceChangeKind.JOIN; // Amounts in are positive, out are negative\n        emit PoolBalanceChanged(\n            poolId,\n            sender,\n            tokens,\n            // We can unsafely cast to int256 because balances are actually stored as uint112\n            _unsafeCastToInt256(amountsInOrOut, positive),\n            paidProtocolSwapFeeAmounts\n        );\n    }\n\n    /**\n     * @dev Calls the corresponding Pool hook to get the amounts in/out plus protocol fee amounts, and performs the\n     * associated token transfers and fee payments, returning the Pool's final balances.\n     */\n    function _callPoolBalanceChange(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances\n    )\n        private\n        returns (\n            bytes32[] memory finalBalances,\n            uint256[] memory amountsInOrOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        (uint256[] memory totalBalances, uint256 lastChangeBlock) = balances.totalsAndLastChangeBlock();\n\n        IBasePool pool = IBasePool(_getPoolAddress(poolId));\n        (amountsInOrOut, dueProtocolFeeAmounts) = kind == PoolBalanceChangeKind.JOIN\n            ? pool.onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                totalBalances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData\n            )\n            : pool.onExitPool(\n                poolId,\n                sender,\n                recipient,\n                totalBalances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData\n            );\n\n        InputHelpers.ensureInputLengthMatch(balances.length, amountsInOrOut.length, dueProtocolFeeAmounts.length);\n\n        // The Vault ignores the `recipient` in joins and the `sender` in exits: it is up to the Pool to keep track of\n        // their participation.\n        finalBalances = kind == PoolBalanceChangeKind.JOIN\n            ? _processJoinPoolTransfers(sender, change, balances, amountsInOrOut, dueProtocolFeeAmounts)\n            : _processExitPoolTransfers(recipient, change, balances, amountsInOrOut, dueProtocolFeeAmounts);\n    }\n\n    /**\n     * @dev Transfers `amountsIn` from `sender`, checking that they are within their accepted limits, and pays\n     * accumulated protocol swap fees.\n     *\n     * Returns the Pool's final balances, which are the current balances plus `amountsIn` minus accumulated protocol\n     * swap fees.\n     */\n    function _processJoinPoolTransfers(\n        address sender,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances,\n        uint256[] memory amountsIn,\n        uint256[] memory dueProtocolFeeAmounts\n    ) private returns (bytes32[] memory finalBalances) {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 wrappedEth = 0;\n\n        finalBalances = new bytes32[](balances.length);\n        for (uint256 i = 0; i < change.assets.length; ++i) {\n            uint256 amountIn = amountsIn[i];\n            _require(amountIn <= change.limits[i], Errors.JOIN_ABOVE_MAX);\n\n            // Receive assets from the sender - possibly from Internal Balance.\n            IAsset asset = change.assets[i];\n            _receiveAsset(asset, amountIn, sender, change.useInternalBalance);\n\n            if (_isETH(asset)) {\n                wrappedEth = wrappedEth.add(amountIn);\n            }\n\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\n\n            // Compute the new Pool balances. Note that the fee amount might be larger than `amountIn`,\n            // resulting in an overall decrease of the Pool's balance for a token.\n            finalBalances[i] = (amountIn >= feeAmount) // This lets us skip checked arithmetic\n                ? balances[i].increaseCash(amountIn - feeAmount)\n                : balances[i].decreaseCash(feeAmount - amountIn);\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }\n\n    /**\n     * @dev Transfers `amountsOut` to `recipient`, checking that they are within their accepted limits, and pays\n     * accumulated protocol swap fees from the Pool.\n     *\n     * Returns the Pool's final balances, which are the current `balances` minus `amountsOut` and fees paid\n     * (`dueProtocolFeeAmounts`).\n     */\n    function _processExitPoolTransfers(\n        address payable recipient,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances,\n        uint256[] memory amountsOut,\n        uint256[] memory dueProtocolFeeAmounts\n    ) private returns (bytes32[] memory finalBalances) {\n        finalBalances = new bytes32[](balances.length);\n        for (uint256 i = 0; i < change.assets.length; ++i) {\n            uint256 amountOut = amountsOut[i];\n            _require(amountOut >= change.limits[i], Errors.EXIT_BELOW_MIN);\n\n            // Send tokens to the recipient - possibly to Internal Balance\n            IAsset asset = change.assets[i];\n            _sendAsset(asset, amountOut, recipient, change.useInternalBalance);\n\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\n\n            // Compute the new Pool balances. A Pool's token balance always decreases after an exit (potentially by 0).\n            finalBalances[i] = balances[i].decreaseCash(amountOut.add(feeAmount));\n        }\n    }\n\n    /**\n     * @dev Returns the total balance for `poolId`'s `expectedTokens`.\n     *\n     * `expectedTokens` must exactly equal the token array returned by `getPoolTokens`: both arrays must have the same\n     * length, elements and order. Additionally, the Pool must have at least one registered token.\n     */\n    function _validateTokensAndGetBalances(bytes32 poolId, IERC20[] memory expectedTokens)\n        private\n        view\n        returns (bytes32[] memory)\n    {\n        (IERC20[] memory actualTokens, bytes32[] memory balances) = _getPoolTokens(poolId);\n        InputHelpers.ensureInputLengthMatch(actualTokens.length, expectedTokens.length);\n        _require(actualTokens.length > 0, Errors.POOL_NO_TOKENS);\n\n        for (uint256 i = 0; i < actualTokens.length; ++i) {\n            _require(actualTokens[i] == expectedTokens[i], Errors.TOKENS_MISMATCH);\n        }\n\n        return balances;\n    }\n\n    /**\n     * @dev Casts an array of uint256 to int256, setting the sign of the result according to the `positive` flag,\n     * without checking whether the values fit in the signed 256 bit range.\n     */\n    function _unsafeCastToInt256(uint256[] memory values, bool positive)\n        private\n        pure\n        returns (int256[] memory signedValues)\n    {\n        signedValues = new int256[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            signedValues[i] = positive ? int256(values[i]) : -int256(values[i]);\n        }\n    }\n}\n"
    },
    "contracts/libraries/balances/BalanceAllocation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../math/Math.sol\";\n\n// This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many\n// tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the\n// Pool's Asset Manager. 'total' is the sum of these two, and represents the Pool's total token balance, including\n// tokens that are *not* inside of the Vault.\n//\n// 'cash' is updated whenever tokens enter and exit the Vault, while 'managed' is only updated if the reason tokens are\n// moving is due to an Asset Manager action. This is reflected in the different methods available: 'increaseCash'\n// and 'decreaseCash' for swaps and add/remove liquidity events, and 'cashToManaged' and 'managedToCash' for events\n// transferring funds to and from the Asset Manager.\n//\n// The Vault disallows the Pool's 'cash' from becoming negative. In other words, it can never use any tokens that are\n// not inside the Vault.\n//\n// One of the goals of this library is to store the entire token balance in a single storage slot, which is why we use\n// 112 bit unsigned integers for 'cash' and 'managed'. For consistency, we also disallow any combination of 'cash' and\n// 'managed' that yields a 'total' that doesn't fit in 112 bits.\n//\n// The remaining 32 bits of the slot are used to store the most recent block when the total balance changed. This\n// can be used to implement price oracles that are resilient to 'sandwich' attacks.\n//\n// We could use a Solidity struct to pack these three values together in a single storage slot, but unfortunately\n// Solidity only allows for structs to live in either storage, calldata or memory. Because a memory struct still takes\n// up a slot in the stack (to store its memory location), and because the entire balance fits in a single stack slot\n// (two 112 bit values plus the 32 bit block), using memory is strictly less gas performant. Therefore, we do manual\n// packing and unpacking.\n//\n// Since we cannot define new types, we rely on bytes32 to represent these values instead, as it doesn't have any\n// associated arithmetic operations and therefore reduces the chance of misuse.\nlibrary BalanceAllocation {\n    using Math for uint256;\n\n    // The 'cash' portion of the balance is stored in the least significant 112 bits of a 256 bit word, while the\n    // 'managed' part uses the following 112 bits. The most significant 32 bits are used to store the block\n\n    /**\n     * @dev Returns the total amount of Pool tokens, including those that are not currently in the Vault ('managed').\n     */\n    function total(bytes32 balance) internal pure returns (uint256) {\n        // Since 'cash' and 'managed' are 112 bit values, we don't need checked arithmetic. Additionally, `toBalance`\n        // ensures that 'total' always fits in 112 bits.\n        return cash(balance) + managed(balance);\n    }\n\n    /**\n     * @dev Returns the amount of Pool tokens currently in the Vault.\n     */\n    function cash(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(balance) & mask;\n    }\n\n    /**\n     * @dev Returns the amount of Pool tokens that are being managed by an Asset Manager.\n     */\n    function managed(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(balance >> 112) & mask;\n    }\n\n    /**\n     * @dev Returns the last block when the total balance changed.\n     */\n    function lastChangeBlock(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(32) - 1;\n        return uint256(balance >> 224) & mask;\n    }\n\n    /**\n     * @dev Returns the difference in 'managed' between two balances.\n     */\n    function managedDelta(bytes32 newBalance, bytes32 oldBalance) internal pure returns (int256) {\n        // Because `managed` is a 112 bit value, we can safely perform unchecked arithmetic in 256 bits.\n        return int256(managed(newBalance)) - int256(managed(oldBalance));\n    }\n\n    /**\n     * @dev Returns the total balance for each entry in `balances`, as well as the latest block when the total\n     * balance of *any* of them last changed.\n     */\n    function totalsAndLastChangeBlock(bytes32[] memory balances)\n        internal\n        pure\n        returns (\n            uint256[] memory results,\n            uint256 lastChangeBlock_ // Avoid shadowing\n        )\n    {\n        results = new uint256[](balances.length);\n        lastChangeBlock_ = 0;\n\n        for (uint256 i = 0; i < results.length; i++) {\n            bytes32 balance = balances[i];\n            results[i] = total(balance);\n            lastChangeBlock_ = Math.max(lastChangeBlock_, lastChangeBlock(balance));\n        }\n    }\n\n    /**\n     * @dev Returns true if `balance`'s 'total' balance is zero. Costs less gas than computing 'total' and comparing\n     * with zero.\n     */\n    function isZero(bytes32 balance) internal pure returns (bool) {\n        // We simply need to check the least significant 224 bytes of the word: the block does not affect this.\n        uint256 mask = 2**(224) - 1;\n        return (uint256(balance) & mask) == 0;\n    }\n\n    /**\n     * @dev Returns true if `balance`'s 'total' balance is not zero. Costs less gas than computing 'total' and comparing\n     * with zero.\n     */\n    function isNotZero(bytes32 balance) internal pure returns (bool) {\n        return !isZero(balance);\n    }\n\n    /**\n     * @dev Packs together `cash` and `managed` amounts with a block to create a balance value.\n     *\n     * For consistency, this also checks that the sum of `cash` and `managed` (`total`) fits in 112 bits.\n     */\n    function toBalance(\n        uint256 _cash,\n        uint256 _managed,\n        uint256 _blockNumber\n    ) internal pure returns (bytes32) {\n        uint256 _total = _cash + _managed;\n\n        // Since both 'cash' and 'managed' are positive integers, by checking that their sum ('total') fits in 112 bits\n        // we are also indirectly checking that both 'cash' and 'managed' themselves fit in 112 bits.\n        require(_total >= _cash && _total < 2**112, \"BALANCE_TOTAL_OVERFLOW\");\n\n        // We assume the block fits in 32 bits - this is expected to hold for at least a few decades.\n        return _pack(_cash, _managed, _blockNumber);\n    }\n\n    /**\n     * @dev Increases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent to the Vault (except\n     * for Asset Manager deposits).\n     *\n     * Updates the last total balance change block, even if `amount` is zero.\n     */\n    function increaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\n        uint256 newCash = cash(balance).add(amount);\n        uint256 currentManaged = managed(balance);\n        uint256 newLastChangeBlock = block.number;\n\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\n    }\n\n    /**\n     * @dev Decreases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent from the Vault\n     * (except for Asset Manager withdrawals).\n     *\n     * Updates the last total balance change block, even if `amount` is zero.\n     */\n    function decreaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\n        uint256 newCash = cash(balance).sub(amount);\n        uint256 currentManaged = managed(balance);\n        uint256 newLastChangeBlock = block.number;\n\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\n    }\n\n    /**\n     * @dev Moves 'cash' into 'managed', leaving 'total' unchanged. Called when an Asset Manager withdraws Pool tokens\n     * from the Vault.\n     */\n    function cashToManaged(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\n        uint256 newCash = cash(balance).sub(amount);\n        uint256 newManaged = managed(balance).add(amount);\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\n\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\n    }\n\n    /**\n     * @dev Moves 'managed' into 'cash', leaving 'total' unchanged. Called when an Asset Manager deposits Pool tokens\n     * into the Vault.\n     */\n    function managedToCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\n        uint256 newCash = cash(balance).add(amount);\n        uint256 newManaged = managed(balance).sub(amount);\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\n\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\n    }\n\n    /**\n     * @dev Sets 'managed' balance to an arbitrary value, changing 'total'. Called when the Asset Manager reports\n     * profits or losses. It's the Manager's responsibility to provide a meaningful value.\n     *\n     * Updates the last total balance change block, even if `newManaged` is equal to the current 'managed' value.\n     */\n    function setManaged(bytes32 balance, uint256 newManaged) internal view returns (bytes32) {\n        uint256 currentCash = cash(balance);\n        uint256 newLastChangeBlock = block.number;\n        return toBalance(currentCash, newManaged, newLastChangeBlock);\n    }\n\n    // Alternative mode for Pools with the Two Token specialization setting\n\n    // Instead of storing cash and external for each 'token in' a single storage slot, Two Token Pools store the cash\n    // for both tokens in the same slot, and the managed for both in another one. This reduces the gas cost for swaps,\n    // because the only slot that needs to be updated is the one with the cash. However, it also means that managing\n    // balances is more cumbersome, as both tokens need to be read/written at the same time.\n    //\n    // The field with both cash balances packed is called sharedCash, and the one with external amounts is called\n    // sharedManaged. These two are collectively called the 'shared' balance fields. In both of these, the portion\n    // that corresponds to token A is stored in the least significant 112 bits of a 256 bit word, while token B's part\n    // uses the next least significant 112 bits.\n    //\n    // Because only cash is written to during a swap, we store the last total balance change block with the\n    // packed cash fields. Typically Pools have a distinct block per token: in the case of Two Token Pools they\n    // are the same.\n\n    /**\n     * @dev Extracts the part of the balance that corresponds to token A. This function can be used to decode both\n     * shared cash and managed balances.\n     */\n    function _decodeBalanceA(bytes32 sharedBalance) private pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(sharedBalance) & mask;\n    }\n\n    /**\n     * @dev Extracts the part of the balance that corresponds to token B. This function can be used to decode both\n     * shared cash and managed balances.\n     */\n    function _decodeBalanceB(bytes32 sharedBalance) private pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(sharedBalance >> 112) & mask;\n    }\n\n    // To decode the last balance change block, we can simply use the `blockNumber` function.\n\n    /**\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token A.\n     */\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\n        // Both token A and token B use the same block\n        return toBalance(_decodeBalanceA(sharedCash), _decodeBalanceA(sharedManaged), lastChangeBlock(sharedCash));\n    }\n\n    /**\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token B.\n     */\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\n        // Both token A and token B use the same block\n        return toBalance(_decodeBalanceB(sharedCash), _decodeBalanceB(sharedManaged), lastChangeBlock(sharedCash));\n    }\n\n    /**\n     * @dev Returns the sharedCash shared field, given the current balances for token A and token B.\n     */\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\n        // Both balances are assigned the same block  Since it is possible a single one of them has changed (for\n        // example, in an Asset Manager update), we keep the latest (largest) one.\n        uint32 newLastChangeBlock = uint32(Math.max(lastChangeBlock(tokenABalance), lastChangeBlock(tokenBBalance)));\n\n        return _pack(cash(tokenABalance), cash(tokenBBalance), newLastChangeBlock);\n    }\n\n    /**\n     * @dev Returns the sharedManaged shared field, given the current balances for token A and token B.\n     */\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\n        // We don't bother storing a last change block, as it is read from the shared cash field.\n        return _pack(managed(tokenABalance), managed(tokenBBalance), 0);\n    }\n\n    // Shared functions\n\n    /**\n     * @dev Packs together two uint112 and one uint32 into a bytes32\n     */\n    function _pack(\n        uint256 _leastSignificant,\n        uint256 _midSignificant,\n        uint256 _mostSignificant\n    ) private pure returns (bytes32) {\n        return bytes32((_mostSignificant << 224) + (_midSignificant << 112) + _leastSignificant);\n    }\n}\n"
    },
    "contracts/Fees.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./ProtocolFeesCollector.sol\";\nimport \"./VaultAuthorization.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @dev To reduce the bytecode size of the Vault, most of the protocol fee logic is not here, but in the\n * ProtocolFeesCollector contract.\n */\nabstract contract Fees is IVault {\n    using SafeERC20 for IERC20;\n\n    ProtocolFeesCollector private immutable _protocolFeesCollector;\n\n    constructor() {\n        _protocolFeesCollector = new ProtocolFeesCollector(IVault(this));\n    }\n\n    function getProtocolFeesCollector() public view override returns (IProtocolFeesCollector) {\n        return _protocolFeesCollector;\n    }\n\n    /**\n     * @dev Returns the protocol swap fee percentage.\n     */\n    function _getProtocolSwapFeePercentage() internal view returns (uint256) {\n        return getProtocolFeesCollector().getSwapFeePercentage();\n    }\n\n    /**\n     * @dev Returns the protocol fee amount to charge for a flash loan of `amount`.\n     */\n    function _calculateFlashLoanFeeAmount(uint256 amount) internal view returns (uint256) {\n        // Fixed point multiplication introduces error: we round up, which means in certain scenarios the charged\n        // percentage can be slightly higher than intended.\n        uint256 percentage = getProtocolFeesCollector().getFlashLoanFeePercentage();\n        return FixedPoint.mulUp(amount, percentage);\n    }\n\n    function _payFeeAmount(IERC20 token, uint256 amount) internal {\n        if (amount > 0) {\n            token.safeTransfer(address(getProtocolFeesCollector()), amount);\n        }\n    }\n}\n"
    },
    "contracts/PoolTokens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\n\nimport \"./AssetManagers.sol\";\nimport \"./PoolRegistry.sol\";\nimport \"./libraries/balances/BalanceAllocation.sol\";\n\nabstract contract PoolTokens is ReentrancyGuard, PoolRegistry, AssetManagers {\n    using BalanceAllocation for bytes32;\n    using BalanceAllocation for bytes32[];\n\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external override nonReentrant whenNotPausedVault onlyPool(poolId) {\n        InputHelpers.ensureInputLengthMatch(tokens.length, assetManagers.length);\n\n        // Validates token addresses and assigns Asset Managers\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(token != IERC20(address(0)), Errors.INVALID_TOKEN);\n\n            _poolAssetManagers[poolId][token] = assetManagers[i];\n        }\n\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _registerGeneralPoolTokens(poolId, tokens);\n        }\n\n        emit TokensRegistered(poolId, tokens, assetManagers);\n    }\n\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external override nonReentrant whenNotPausedVault onlyPool(poolId) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _deregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _deregisterMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _deregisterGeneralPoolTokens(poolId, tokens);\n        }\n\n        // The deregister calls above ensure the total token balance is zero. Therefore it is now safe to remove any\n        // associated Asset Managers, since they hold no Pool balance.\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            delete _poolAssetManagers[poolId][tokens[i]];\n        }\n\n        emit TokensDeregistered(poolId, tokens);\n    }\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        )\n    {\n        bytes32[] memory rawBalances;\n        (tokens, rawBalances) = _getPoolTokens(poolId);\n        (balances, lastChangeBlock) = rawBalances.totalsAndLastChangeBlock();\n    }\n\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        )\n    {\n        bytes32 balance;\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            balance = _getTwoTokenPoolBalance(poolId, token);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            balance = _getMinimalSwapInfoPoolBalance(poolId, token);\n        } else {\n            // PoolSpecialization.GENERAL\n            balance = _getGeneralPoolBalance(poolId, token);\n        }\n\n        cash = balance.cash();\n        managed = balance.managed();\n        lastChangeBlock = balance.lastChangeBlock();\n        assetManager = _poolAssetManagers[poolId][token];\n    }\n\n    /**\n     * @dev Returns all of `poolId`'s registered tokens, along with their raw balances.\n     */\n    function _getPoolTokens(bytes32 poolId) internal view returns (IERC20[] memory tokens, bytes32[] memory balances) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            return _getTwoTokenPoolTokens(poolId);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            return _getMinimalSwapInfoPoolTokens(poolId);\n        } else {\n            // PoolSpecialization.GENERAL\n            return _getGeneralPoolTokens(poolId);\n        }\n    }\n}\n"
    },
    "contracts/UserBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/math/Math.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./AssetTransfersHandler.sol\";\nimport \"./VaultAuthorization.sol\";\n\n/**\n * Implement User Balance interactions, which combine Internal Balance and using the Vault's ERC20 allowance.\n *\n * Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n * transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n * when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n * gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n *\n * Internal Balance management features batching, which means a single contract call can be used to perform multiple\n * operations of different kinds, with different senders and recipients, at once.\n */\nabstract contract UserBalance is ReentrancyGuard, AssetTransfersHandler, VaultAuthorization {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    // Internal Balance for each token, for each account.\n    mapping(address => mapping(IERC20 => uint256)) private _internalTokenBalance;\n\n    function getInternalBalance(address user, IERC20[] memory tokens)\n        external\n        view\n        override\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            balances[i] = _getInternalBalance(user, tokens[i]);\n        }\n    }\n\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable override nonReentrant {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 ethWrapped = 0;\n\n        // Cache for these checks so we only perform them once (if at all).\n        bool checkedCallerIsRelayer = false;\n        bool checkedNotPaused = false;\n\n        for (uint256 i = 0; i < ops.length; i++) {\n            UserBalanceOpKind kind;\n            IAsset asset;\n            uint256 amount;\n            address sender;\n            address payable recipient;\n\n            // This destructuring by calling `_validateUserBalanceOp` seems odd, but results in reduced bytecode size.\n            (kind, asset, amount, sender, recipient, checkedCallerIsRelayer) = _validateUserBalanceOp(\n                ops[i],\n                checkedCallerIsRelayer\n            );\n\n            if (kind == UserBalanceOpKind.WITHDRAW_INTERNAL) {\n                // Internal Balance withdrawals can always be performed by an authorized account.\n                _withdrawFromInternalBalance(asset, sender, recipient, amount);\n            } else {\n                // All other operations are blocked if the contract is paused.\n\n                // We cache the result of the pause check and skip it for other operations in this same transaction\n                // (if any).\n                if (!checkedNotPaused) {\n                    _ensureNotPausedVault();\n                    checkedNotPaused = true;\n                }\n\n                if (kind == UserBalanceOpKind.DEPOSIT_INTERNAL) {\n                    _depositToInternalBalance(asset, sender, recipient, amount);\n\n                    // Keep track of all ETH wrapped into WETH as part of a deposit.\n                    if (_isETH(asset)) {\n                        ethWrapped = ethWrapped.add(amount);\n                    }\n                } else {\n                    // Transfers don't support ETH.\n                    _require(!_isETH(asset), Errors.CANNOT_USE_ETH_SENTINEL);\n                    IERC20 token = _asIERC20(asset);\n\n                    if (kind == UserBalanceOpKind.TRANSFER_INTERNAL) {\n                        _transferInternalBalance(token, sender, recipient, amount);\n                    } else {\n                        // TRANSFER_EXTERNAL\n                        _transferToExternalBalance(token, sender, recipient, amount);\n                    }\n                }\n            }\n        }\n\n        // Handle any remaining ETH.\n        _handleRemainingEth(ethWrapped);\n    }\n\n    function _depositToInternalBalance(\n        IAsset asset,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        _increaseInternalBalance(recipient, _translateToIERC20(asset), amount);\n        _receiveAsset(asset, amount, sender, false);\n    }\n\n    function _withdrawFromInternalBalance(\n        IAsset asset,\n        address sender,\n        address payable recipient,\n        uint256 amount\n    ) private {\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\n        _decreaseInternalBalance(sender, _translateToIERC20(asset), amount, false);\n        _sendAsset(asset, amount, recipient, false);\n    }\n\n    function _transferInternalBalance(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\n        _decreaseInternalBalance(sender, token, amount, false);\n        _increaseInternalBalance(recipient, token, amount);\n    }\n\n    function _transferToExternalBalance(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (amount > 0) {\n            token.safeTransferFrom(sender, recipient, amount);\n            emit ExternalBalanceTransfer(token, sender, recipient, amount);\n        }\n    }\n\n    /**\n     * @dev Increases `account`'s Internal Balance for `token` by `amount`.\n     */\n    function _increaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) internal override {\n        uint256 currentBalance = _getInternalBalance(account, token);\n        uint256 newBalance = currentBalance.add(amount);\n        _setInternalBalance(account, token, newBalance, amount.toInt256());\n    }\n\n    /**\n     * @dev Decreases `account`'s Internal Balance for `token` by `amount`. If `allowPartial` is true, this function\n     * doesn't revert if `account` doesn't have enough balance, and sets it to zero and returns the deducted amount\n     * instead.\n     */\n    function _decreaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount,\n        bool allowPartial\n    ) internal override returns (uint256 deducted) {\n        uint256 currentBalance = _getInternalBalance(account, token);\n        _require(allowPartial || (currentBalance >= amount), Errors.INSUFFICIENT_INTERNAL_BALANCE);\n\n        deducted = Math.min(currentBalance, amount);\n        // By construction, `deducted` is lower or equal to `currentBalance`, so we don't need to use checked\n        // arithmetic.\n        uint256 newBalance = currentBalance - deducted;\n        _setInternalBalance(account, token, newBalance, -(deducted.toInt256()));\n    }\n\n    /**\n     * @dev Sets `account`'s Internal Balance for `token` to `newBalance`.\n     *\n     * Emits an `InternalBalanceChanged` event. This event includes `delta`, which is the amount the balance increased\n     * (if positive) or decreased (if negative). To avoid reading the current balance in order to compute the delta,\n     * this function relies on the caller providing it directly.\n     */\n    function _setInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 newBalance,\n        int256 delta\n    ) private {\n        _internalTokenBalance[account][token] = newBalance;\n        emit InternalBalanceChanged(account, token, delta);\n    }\n\n    /**\n     * @dev Returns `account`'s Internal Balance for `token`.\n     */\n    function _getInternalBalance(address account, IERC20 token) internal view returns (uint256) {\n        return _internalTokenBalance[account][token];\n    }\n\n    /**\n     * @dev Destructures a User Balance operation, validating that the contract caller is allowed to perform it.\n     */\n    function _validateUserBalanceOp(UserBalanceOp memory op, bool checkedCallerIsRelayer)\n        private\n        view\n        returns (\n            UserBalanceOpKind,\n            IAsset,\n            uint256,\n            address,\n            address payable,\n            bool\n        )\n    {\n        // The only argument we need to validate is `sender`, which can only be either the contract caller, or a\n        // relayer approved by `sender`.\n        address sender = op.sender;\n\n        if (sender != msg.sender) {\n            // We need to check both that the contract caller is a relayer, and that `sender` approved them.\n\n            // Because the relayer check is global (i.e. independent of `sender`), we cache that result and skip it for\n            // other operations in this same transaction (if any).\n            if (!checkedCallerIsRelayer) {\n                _authenticateCaller();\n                checkedCallerIsRelayer = true;\n            }\n\n            _require(_hasApprovedRelayer(sender, msg.sender), Errors.USER_DOESNT_ALLOW_RELAYER);\n        }\n\n        return (op.kind, op.asset, op.amount, sender, op.recipient, checkedCallerIsRelayer);\n    }\n}\n"
    },
    "contracts/ProtocolFeesCollector.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./libraries/helpers/Authentication.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IProtocolFeesCollector.sol\";\n\n/**\n * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the\n * Vault performs to reduce its overall bytecode size.\n *\n * The current values for all protocol fee percentages are stored here, and any tokens charged as protocol fees are\n * sent to this contract, where they may be withdrawn by authorized entities. All authorization tasks are delegated\n * to the Vault's own authorizer.\n */\ncontract ProtocolFeesCollector is IProtocolFeesCollector, Authentication, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).\n    uint256 private constant _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE = 50e16; // 50%\n    uint256 private constant _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE = 1e16; // 1%\n\n    IVault public immutable override vault;\n\n    // All fee percentages are 18-decimal fixed point numbers.\n\n    // The swap fee is charged whenever a swap occurs, as a percentage of the fee charged by the Pool. These are not\n    // actually charged on each individual swap: the `Vault` relies on the Pools being honest and reporting fees due\n    // when users join and exit them.\n    uint256 private _swapFeePercentage;\n\n    // The flash loan fee is charged whenever a flash loan occurs, as a percentage of the tokens lent.\n    uint256 private _flashLoanFeePercentage;\n\n    constructor(IVault _vault)\n        // The ProtocolFeesCollector is a singleton, so it simply uses its own address to disambiguate action\n        // identifiers.\n        Authentication(bytes32(uint256(uint160(address(this))) << 96))\n    {\n        vault = _vault;\n    }\n\n    function withdrawCollectedFees(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external override nonReentrant authenticate {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n            token.safeTransfer(recipient, amount);\n        }\n    }\n\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external override authenticate {\n        _require(newSwapFeePercentage <= _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE, Errors.SWAP_FEE_PERCENTAGE_TOO_HIGH);\n        _swapFeePercentage = newSwapFeePercentage;\n        emit SwapFeePercentageChanged(newSwapFeePercentage);\n    }\n\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external override authenticate {\n        _require(\n            newFlashLoanFeePercentage <= _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE,\n            Errors.FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH\n        );\n        _flashLoanFeePercentage = newFlashLoanFeePercentage;\n        emit FlashLoanFeePercentageChanged(newFlashLoanFeePercentage);\n    }\n\n    function getSwapFeePercentage() external view override returns (uint256) {\n        return _swapFeePercentage;\n    }\n\n    function getFlashLoanFeePercentage() external view override returns (uint256) {\n        return _flashLoanFeePercentage;\n    }\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens)\n        external\n        view\n        override\n        returns (uint256[] memory feeAmounts)\n    {\n        feeAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            feeAmounts[i] = tokens[i].balanceOf(address(this));\n        }\n    }\n\n    function getAuthorizer() external view override returns (IAuthorizer) {\n        return _getAuthorizer();\n    }\n\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\n        return _getAuthorizer().canPerform(actionId, account, address(this));\n    }\n\n    function _getAuthorizer() internal view returns (IAuthorizer) {\n        return vault.getAuthorizer();\n    }\n}\n"
    },
    "contracts/VaultAuthorization.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/helpers/Authentication.sol\";\nimport \"./libraries/helpers/TemporarilyPausableVault.sol\";\nimport \"./libraries/helpers/SignaturesValidatorVault.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IAuthorizer.sol\";\n\n/**\n * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.\n *\n * Additionally handles relayer access and approval.\n */\nabstract contract VaultAuthorization is\n    IVault,\n    ReentrancyGuard,\n    Authentication,\n    SignaturesValidatorVault,\n    TemporarilyPausableVault\n{\n    // Ideally, we'd store the type hashes as immutable state variables to avoid computing the hash at runtime, but\n    // unfortunately immutable variables cannot be used in assembly, so we just keep the precomputed hashes instead.\n\n    // _JOIN_TYPE_HASH = keccak256(\"JoinPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _JOIN_TYPE_HASH = 0x3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58;\n\n    // _EXIT_TYPE_HASH = keccak256(\"ExitPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _EXIT_TYPE_HASH = 0x8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353;\n\n    // _SWAP_TYPE_HASH = keccak256(\"Swap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _SWAP_TYPE_HASH = 0xe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe;\n\n    // _BATCH_SWAP_TYPE_HASH = keccak256(\"BatchSwap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _BATCH_SWAP_TYPE_HASH = 0x9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a;\n\n    // _SET_RELAYER_TYPE_HASH =\n    //     keccak256(\"SetRelayerApproval(bytes calldata,address sender,uint256 nonce,uint256 deadline)\");\n    bytes32\n        private constant _SET_RELAYER_TYPE_HASH = 0xa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a;\n\n    IAuthorizer private _authorizer;\n    mapping(address => mapping(address => bool)) private _approvedRelayers;\n\n    /**\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call this function (that\n     * is, it is a relayer for that function), and either:\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\n     *  b) a valid signature from them was appended to the calldata.\n     *\n     * Should only be applied to external functions.\n     */\n    modifier authenticateFor(address user) {\n        _authenticateFor(user);\n        _;\n    }\n\n    constructor(IAuthorizer authorizer)\n        // The Vault is a singleton, so it simply uses its own address to disambiguate action identifiers.\n        Authentication(bytes32(uint256(uint160(address(this))) << 96))\n        SignaturesValidatorVault(\"Requiem V2 Vault\")\n    {\n        _setAuthorizer(authorizer);\n    }\n\n    function setAuthorizer(IAuthorizer newAuthorizer) external override nonReentrant authenticate {\n        _setAuthorizer(newAuthorizer);\n    }\n\n    function _setAuthorizer(IAuthorizer newAuthorizer) private {\n        emit AuthorizerChanged(newAuthorizer);\n        _authorizer = newAuthorizer;\n    }\n\n    function getAuthorizer() external view override returns (IAuthorizer) {\n        return _authorizer;\n    }\n\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external override nonReentrant whenNotPausedVault authenticateFor(sender) {\n        _approvedRelayers[sender][relayer] = approved;\n        emit RelayerApprovalChanged(relayer, sender, approved);\n    }\n\n    function hasApprovedRelayer(address user, address relayer) external view override returns (bool) {\n        return _hasApprovedRelayer(user, relayer);\n    }\n\n    /**\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call the entry point\n     * function (that is, it is a relayer for that function) and either:\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\n     *  b) a valid signature from them was appended to the calldata.\n     */\n    function _authenticateFor(address user) internal {\n        if (msg.sender != user) {\n            // In this context, 'permission to call a function' means 'being a relayer for a function'.\n            _authenticateCaller();\n\n            // Being a relayer is not sufficient: `user` must have also approved the caller either via\n            // `setRelayerApproval`, or by providing a signature appended to the calldata.\n            if (!_hasApprovedRelayer(user, msg.sender)) {\n                _validateSignature(user, Errors.USER_DOESNT_ALLOW_RELAYER);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns true if `user` approved `relayer` to act as a relayer for them.\n     */\n    function _hasApprovedRelayer(address user, address relayer) internal view returns (bool) {\n        return _approvedRelayers[user][relayer];\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        // Access control is delegated to the Authorizer.\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    function _typeHash() internal pure override returns (bytes32 hash) {\n        // This is a simple switch-case statement, trivially written in Solidity by chaining else-if statements, but the\n        // assembly implementation results in much denser bytecode.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The function selector is located at the first 4 bytes of calldata. We copy the first full calldata\n            // 256 word, and then perform a logical shift to the right, moving the selector to the least significant\n            // 4 bytes.\n            let selector := shr(224, calldataload(0))\n\n            // With the selector in the least significant 4 bytes, we can use 4 byte literals with leading zeros,\n            // resulting in dense bytecode (PUSH4 opcodes).\n            switch selector\n                case 0xb95cac28 {\n                    hash := _JOIN_TYPE_HASH\n                }\n                case 0x8bdb3913 {\n                    hash := _EXIT_TYPE_HASH\n                }\n                case 0x52bbbe29 {\n                    hash := _SWAP_TYPE_HASH\n                }\n                case 0x945bcec9 {\n                    hash := _BATCH_SWAP_TYPE_HASH\n                }\n                case 0xfa6e671d {\n                    hash := _SET_RELAYER_TYPE_HASH\n                }\n                default {\n                    hash := 0x0000000000000000000000000000000000000000000000000000000000000000\n                }\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/TemporarilyPausableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ITemporarilyPausableVault.sol\";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausableVault is ITemporarilyPausableVault {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, \"MAX_PAUSE_WINDOW_DURATION\");\n        require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, \"MAX_BUFFER_PERIOD_DURATION\");\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPausedVault() {\n        _ensureNotPausedVault();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedStateVault()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPausedVault();\n        pauseWindowEndTime = _getPauseWindowEndTimeVault();\n        bufferPeriodEndTime = _getBufferPeriodEndTimeVault();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPausedVault(bool paused) internal {\n        if (paused) {\n            require(block.timestamp < _getPauseWindowEndTimeVault(), \"PAUSE_WINDOW_EXPIRED\");\n        } else {\n            require(block.timestamp < _getBufferPeriodEndTimeVault(), \"BUFFER_PERIOD_EXPIRED\");\n        }\n\n        _paused = paused;\n        emit PausedStateChangedVault(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPausedVault() internal view {\n        require(_isNotPausedVault(), \"PAUSED\");\n    }\n\n    /**\n     * @dev Reverts if the contract is not paused.\n     */\n    function _ensurePausedVault() internal view {\n        require(!_isNotPausedVault(), \"NOT_PAUSED\");\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPausedVault() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTimeVault() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTimeVault() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTimeVault() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n"
    },
    "contracts/libraries/helpers/SignaturesValidatorVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"../../interfaces/ISignaturesValidatorVault.sol\";\nimport \"../EIP712.sol\";\n\n/**\n * @dev Utility for signing Solidity function calls.\n *\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\n *\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\n */\nabstract contract SignaturesValidatorVault is ISignaturesValidatorVault, EIP712 {\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\n    // for each of these values, even if 'v' is typically an 8 bit value.\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\n\n    // Replay attack prevention for each user.\n    mapping(address => uint256) internal _nextNonce;\n\n    constructor(string memory name) EIP712(name, \"1\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function getDomainSeparator() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getNextNonce(address user) external view override returns (uint256) {\n        return _nextNonce[user];\n    }\n\n    /**\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\n     */\n    function _validateSignature(address user, uint256 errorCode) internal {\n        uint256 nextNonce = _nextNonce[user]++;\n        _require(_isSignatureValid(user, nextNonce), errorCode);\n    }\n\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\n        uint256 deadline = _deadline();\n\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (deadline < block.timestamp) {\n            return false;\n        }\n\n        bytes32 typeHash = _typeHash();\n        if (typeHash == bytes32(0)) {\n            // Prevent accidental signature validation for functions that don't have an associated type hash.\n            return false;\n        }\n\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\n        return recoveredAddress != address(0) && recoveredAddress == user;\n    }\n\n    /**\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\n     * selector (available as `msg.sig`).\n     *\n     * The type hash must conform to the following format:\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\n     *\n     * If 0x00, all signatures will be considered invalid.\n     */\n    function _typeHash() internal view virtual returns (bytes32);\n\n    /**\n     * @dev Extracts the signature deadline from extra calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _deadline() internal pure returns (uint256) {\n        // The deadline is the first extra argument at the end of the original calldata.\n        return uint256(_decodeExtraCalldataWord(0));\n    }\n\n    /**\n     * @dev Extracts the signature parameters from extra calldata.\n     *\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\n     * be considered a valid signature in the first place.\n     */\n    function _signature()\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // v, r and s are appended after the signature deadline, in that order.\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\n        r = _decodeExtraCalldataWord(0x40);\n        s = _decodeExtraCalldataWord(0x60);\n    }\n\n    /**\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _calldata() internal pure returns (bytes memory result) {\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We simply overwrite the array length with the reduced one.\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\n            }\n        }\n    }\n\n    /**\n     * @dev Returns a 256 bit word from 'extra' calldata, at some offset from the expected end of the original calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\n        }\n    }\n}\n"
    },
    "contracts/AssetManagers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\n\nimport \"./UserBalance.sol\";\nimport \"./libraries/balances/BalanceAllocation.sol\";\nimport \"./libraries/balances/GeneralPoolsBalance.sol\";\nimport \"./libraries/balances/MinimalSwapInfoPoolsBalance.sol\";\nimport \"./libraries/balances/TwoTokenPoolsBalance.sol\";\n\nabstract contract AssetManagers is\n    ReentrancyGuard,\n    GeneralPoolsBalance,\n    MinimalSwapInfoPoolsBalance,\n    TwoTokenPoolsBalance\n{\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    // Stores the Asset Manager for each token of each Pool.\n    mapping(bytes32 => mapping(IERC20 => address)) internal _poolAssetManagers;\n\n    function managePoolBalance(PoolBalanceOp[] memory ops) external override nonReentrant whenNotPausedVault {\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        PoolBalanceOp memory op;\n\n        for (uint256 i = 0; i < ops.length; ++i) {\n            // By indexing the array only once, we don't spend extra gas in the same bounds check.\n            op = ops[i];\n\n            bytes32 poolId = op.poolId;\n            _ensureRegisteredPool(poolId);\n\n            IERC20 token = op.token;\n            _require(_isTokenRegistered(poolId, token), Errors.TOKEN_NOT_REGISTERED);\n            _require(_poolAssetManagers[poolId][token] == msg.sender, Errors.SENDER_NOT_ASSET_MANAGER);\n\n            PoolBalanceOpKind kind = op.kind;\n            uint256 amount = op.amount;\n            (int256 cashDelta, int256 managedDelta) = _performPoolManagementOperation(kind, poolId, token, amount);\n\n            emit PoolBalanceManaged(poolId, msg.sender, token, cashDelta, managedDelta);\n        }\n    }\n\n    /**\n     * @dev Performs the `kind` Asset Manager operation on a Pool.\n     *\n     * Withdrawals will transfer `amount` tokens to the caller, deposits will transfer `amount` tokens from the caller,\n     * and updates will set the managed balance to `amount`.\n     *\n     * Returns a tuple with the 'cash' and 'managed' balance deltas as a result of this call.\n     */\n    function _performPoolManagementOperation(\n        PoolBalanceOpKind kind,\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256, int256) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n\n        if (kind == PoolBalanceOpKind.WITHDRAW) {\n            return _withdrawPoolBalance(poolId, specialization, token, amount);\n        } else if (kind == PoolBalanceOpKind.DEPOSIT) {\n            return _depositPoolBalance(poolId, specialization, token, amount);\n        } else {\n            // PoolBalanceOpKind.UPDATE\n            return _updateManagedBalance(poolId, specialization, token, amount);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` tokens from a Pool's 'cash' to 'managed' balance, and transfers them to the caller.\n     *\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call, which will be complementary.\n     */\n    function _withdrawPoolBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _twoTokenPoolCashToManaged(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _minimalSwapInfoPoolCashToManaged(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            _generalPoolCashToManaged(poolId, token, amount);\n        }\n\n        if (amount > 0) {\n            token.safeTransfer(msg.sender, amount);\n        }\n\n        // Since 'cash' and 'managed' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\n        // therefore always fit in a 256 bit integer.\n        cashDelta = -int256(amount);\n        managedDelta = int256(amount);\n    }\n\n    /**\n     * @dev Moves `amount` tokens from a Pool's 'managed' to 'cash' balance, and transfers them from the caller.\n     *\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call, which will be complementary.\n     */\n    function _depositPoolBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _twoTokenPoolManagedToCash(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _minimalSwapInfoPoolManagedToCash(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            _generalPoolManagedToCash(poolId, token, amount);\n        }\n\n        if (amount > 0) {\n            token.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        // Since 'cash' and 'managed' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\n        // therefore always fit in a 256 bit integer.\n        cashDelta = int256(amount);\n        managedDelta = -int256(amount);\n    }\n\n    /**\n     * @dev Sets a Pool's 'managed' balance to `amount`.\n     *\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call (the 'cash' delta will always be zero).\n     */\n    function _updateManagedBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            managedDelta = _setTwoTokenPoolManagedBalance(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            managedDelta = _setMinimalSwapInfoPoolManagedBalance(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            managedDelta = _setGeneralPoolManagedBalance(poolId, token, amount);\n        }\n\n        cashDelta = 0;\n    }\n\n    /**\n     * @dev Returns true if `token` is registered for `poolId`.\n     */\n    function _isTokenRegistered(bytes32 poolId, IERC20 token) private view returns (bool) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            return _isTwoTokenPoolTokenRegistered(poolId, token);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            return _isMinimalSwapInfoPoolTokenRegistered(poolId, token);\n        } else {\n            // PoolSpecialization.GENERAL\n            return _isGeneralPoolTokenRegistered(poolId, token);\n        }\n    }\n}\n"
    },
    "contracts/PoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\n\nimport \"./VaultAuthorization.sol\";\n\n/**\n * @dev Maintains the Pool ID data structure, implements Pool ID creation and registration, and defines useful modifiers\n * and helper functions for ensuring correct behavior when working with Pools.\n */\nabstract contract PoolRegistry is ReentrancyGuard, VaultAuthorization {\n    // Each pool is represented by their unique Pool ID. We use `bytes32` for them, for lack of a way to define new\n    // types.\n    mapping(bytes32 => bool) private _isPoolRegistered;\n\n    // We keep an increasing nonce to make Pool IDs unique. It is interpreted as a `uint80`, but storing it as a\n    // `uint256` results in reduced bytecode on reads and writes due to the lack of masking.\n    uint256 private _nextPoolNonce;\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\n     */\n    modifier withRegisteredPool(bytes32 poolId) {\n        _ensureRegisteredPool(poolId);\n        _;\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\n     */\n    modifier onlyPool(bytes32 poolId) {\n        _ensurePoolIsSender(poolId);\n        _;\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\n     */\n    function _ensureRegisteredPool(bytes32 poolId) internal view {\n        _require(_isPoolRegistered[poolId], Errors.INVALID_POOL_ID);\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\n     */\n    function _ensurePoolIsSender(bytes32 poolId) private view {\n        _ensureRegisteredPool(poolId);\n        _require(msg.sender == _getPoolAddress(poolId), Errors.CALLER_NOT_POOL);\n    }\n\n    function registerPool(PoolSpecialization specialization)\n        external\n        override\n        nonReentrant\n        whenNotPausedVault\n        returns (bytes32)\n    {\n        // Each Pool is assigned a unique ID based on an incrementing nonce. This assumes there will never be more than\n        // 2**80 Pools, and the nonce will not overflow.\n\n        bytes32 poolId = _toPoolId(msg.sender, specialization, uint80(_nextPoolNonce));\n\n        _require(!_isPoolRegistered[poolId], Errors.INVALID_POOL_ID); // Should never happen as Pool IDs are unique.\n        _isPoolRegistered[poolId] = true;\n\n        _nextPoolNonce += 1;\n\n        // Note that msg.sender is the pool's contract\n        emit PoolRegistered(poolId, msg.sender, specialization);\n        return poolId;\n    }\n\n    function getPool(bytes32 poolId)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (address, PoolSpecialization)\n    {\n        return (_getPoolAddress(poolId), _getPoolSpecialization(poolId));\n    }\n\n    /**\n     * @dev Creates a Pool ID.\n     *\n     * These are deterministically created by packing the Pool's contract address and its specialization setting into\n     * the ID. This saves gas by making this data easily retrievable from a Pool ID with no storage accesses.\n     *\n     * Since a single contract can register multiple Pools, a unique nonce must be provided to ensure Pool IDs are\n     * unique.\n     *\n     * Pool IDs have the following layout:\n     * | 20 bytes pool contract address | 2 bytes specialization setting | 10 bytes nonce |\n     * MSB                                                                              LSB\n     *\n     * 2 bytes for the specialization setting is a bit overkill: there only three of them, which means two bits would\n     * suffice. However, there's nothing else of interest to store in this extra space.\n     */\n    function _toPoolId(\n        address pool,\n        PoolSpecialization specialization,\n        uint80 nonce\n    ) internal pure returns (bytes32) {\n        bytes32 serialized;\n\n        serialized |= bytes32(uint256(nonce));\n        serialized |= bytes32(uint256(specialization)) << (10 * 8);\n        serialized |= bytes32(uint256(uint160(pool)) << 96) << (12 * 8);\n\n        return serialized;\n    }\n\n    /**\n     * @dev Returns the address of a Pool's contract.\n     *\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n     */\n    function _getPoolAddress(bytes32 poolId) internal pure returns (address) {\n        // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n        // since the logical shift already sets the upper bits to zero.\n        return address(uint160(uint256(poolId) >> (12 * 8)));\n    }\n\n    /**\n     * @dev Returns the specialization setting of a Pool.\n     *\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n     */\n    function _getPoolSpecialization(bytes32 poolId) internal pure returns (PoolSpecialization specialization) {\n        // 10 byte logical shift left to remove the nonce, followed by a 2 byte mask to remove the address.\n        uint256 value = uint256(poolId >> (10 * 8)) & (2**(2 * 8) - 1);\n\n        // Casting a value into an enum results in a runtime check that reverts unless the value is within the enum's\n        // range. Passing an invalid Pool ID to this function would then result in an obscure revert with no reason\n        // string: we instead perform the check ourselves to help in error diagnosis.\n\n        // There are three Pool specialization settings: general, minimal swap info and two tokens, which correspond to\n        // values 0, 1 and 2.\n        _require(value < 3, Errors.INVALID_POOL_ID);\n\n        // Because we have checked that `value` is within the enum range, we can use assembly to skip the runtime check.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            specialization := value\n        }\n    }\n}\n"
    },
    "contracts/libraries/balances/GeneralPoolsBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../helpers/RequiemErrors.sol\";\nimport \"../EnumerableMap.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nimport \"./BalanceAllocation.sol\";\n\nabstract contract GeneralPoolsBalance {\n    using BalanceAllocation for bytes32;\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\n\n    // Data for Pools with the General specialization setting\n    //\n    // These Pools use the IGeneralPool interface, which means the Vault must query the balance for *all* of their\n    // tokens in every swap. If we kept a mapping of token to balance plus a set (array) of tokens, it'd be very gas\n    // intensive to read all token addresses just to then do a lookup on the balance mapping.\n    //\n    // Instead, we use our customized EnumerableMap, which lets us read the N balances in N+1 storage accesses (one for\n    // each token in the Pool), access the index of any 'token in' a single read (required for the IGeneralPool call),\n    // and update an entry's value given its index.\n\n    // Map of token -> balance pairs for each Pool with this specialization. Many functions rely on storage pointers to\n    // a Pool's EnumerableMap to save gas when computing storage slots.\n    mapping(bytes32 => EnumerableMap.IERC20ToBytes32Map) internal _generalPoolsBalances;\n\n    /**\n     * @dev Registers a list of tokens in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must not be registered in the Pool\n     * - `tokens` must not contain duplicates\n     */\n    function _registerGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // EnumerableMaps require an explicit initial value when creating a key-value pair: we use zero, the same\n            // value that is found in uninitialized storage, which corresponds to an empty balance.\n            bool added = poolBalances.set(tokens[i], 0);\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Deregisters a list of tokens in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must be registered in the Pool\n     * - `tokens` must have zero balance in the Vault\n     * - `tokens` must not contain duplicates\n     */\n    function _deregisterGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\n            _require(currentBalance.isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n            // We don't need to check remove's return value, since _getGeneralPoolBalance already checks that the token\n            // was registered.\n            poolBalances.remove(token);\n        }\n    }\n\n    /**\n     * @dev Sets the balances of a General Pool's tokens to `balances`.\n     *\n     * WARNING: this assumes `balances` has the same length and order as the Pool's tokens.\n     */\n    function _setGeneralPoolBalances(bytes32 poolId, bytes32[] memory balances) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < balances.length; ++i) {\n            // Since we assume all balances are properly ordered, we can simply use `unchecked_setAt` to avoid one less\n            // storage read per token.\n            poolBalances.unchecked_setAt(i, balances[i]);\n        }\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a General Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _generalPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a General Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _generalPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s managed balance in a General Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setGeneralPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateGeneralPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s balance in a General Pool to the result of the `mutation` function when called with the\n     * current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateGeneralPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) private returns (int256) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\n\n        bytes32 newBalance = mutation(currentBalance, amount);\n        poolBalances.set(token, newBalance);\n\n        return newBalance.managedDelta(currentBalance);\n    }\n\n    /**\n     * @dev Returns an array with all the tokens and balances in a General Pool. The order may change when tokens are\n     * registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     */\n    function _getGeneralPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        tokens = new IERC20[](poolBalances.length());\n        balances = new bytes32[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableMap's length, we can use\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\n            (tokens[i], balances[i]) = poolBalances.unchecked_at(i);\n        }\n    }\n\n    /**\n     * @dev Returns the balance of a token in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `token` must be registered in the Pool\n     */\n    function _getGeneralPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        return _getGeneralPoolBalance(poolBalances, token);\n    }\n\n    /**\n     * @dev Same as `_getGeneralPoolBalance` but using a Pool's storage pointer, which saves gas in repeated reads and\n     * writes.\n     */\n    function _getGeneralPoolBalance(EnumerableMap.IERC20ToBytes32Map storage poolBalances, IERC20 token)\n        private\n        view\n        returns (bytes32)\n    {\n        return poolBalances.get(token, Errors.TOKEN_NOT_REGISTERED);\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     */\n    function _isGeneralPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        return poolBalances.contains(token);\n    }\n}\n"
    },
    "contracts/libraries/balances/MinimalSwapInfoPoolsBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../helpers/RequiemErrors.sol\";\nimport \"../EnumerableSet.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nimport \"./BalanceAllocation.sol\";\nimport \"../../PoolRegistry.sol\";\n\nabstract contract MinimalSwapInfoPoolsBalance is PoolRegistry {\n    using BalanceAllocation for bytes32;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Data for Pools with the Minimal Swap Info specialization setting\n    //\n    // These Pools use the IMinimalSwapInfoPool interface, and so the Vault must read the balance of the two tokens\n    // in the swap. The best solution is to use a mapping from token to balance, which lets us read or write any token's\n    // balance in a single storage access.\n    //\n    // We also keep a set of registered tokens. Because tokens with non-zero balance are by definition registered, in\n    // some balance getters we skip checking for token registration if a non-zero balance is found, saving gas by\n    // performing a single read instead of two.\n\n    mapping(bytes32 => mapping(IERC20 => bytes32)) internal _minimalSwapInfoPoolsBalances;\n    mapping(bytes32 => EnumerableSet.AddressSet) internal _minimalSwapInfoPoolsTokens;\n\n    /**\n     * @dev Registers a list of tokens in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must not be registered in the Pool\n     * - `tokens` must not contain duplicates\n     */\n    function _registerMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            bool added = poolTokens.add(address(tokens[i]));\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\n            // Note that we don't initialize the balance mapping: the default value of zero corresponds to an empty\n            // balance.\n        }\n    }\n\n    /**\n     * @dev Deregisters a list of tokens in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must be registered in the Pool\n     * - `tokens` must have zero balance in the Vault\n     * - `tokens` must not contain duplicates\n     */\n    function _deregisterMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(_minimalSwapInfoPoolsBalances[poolId][token].isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n            // For consistency with other Pool specialization settings, we explicitly reset the balance (which may have\n            // a non-zero last change block).\n            delete _minimalSwapInfoPoolsBalances[poolId][token];\n\n            bool removed = poolTokens.remove(address(token));\n            _require(removed, Errors.TOKEN_NOT_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Sets the balances of a Minimal Swap Info Pool's tokens to `balances`.\n     *\n     * WARNING: this assumes `balances` has the same length and order as the Pool's tokens.\n     */\n    function _setMinimalSwapInfoPoolBalances(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        bytes32[] memory balances\n    ) internal {\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            _minimalSwapInfoPoolsBalances[poolId][tokens[i]] = balances[i];\n        }\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a Minimal Swap Info Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     */\n    function _minimalSwapInfoPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a Minimal Swap Info Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     */\n    function _minimalSwapInfoPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s managed balance in a Minimal Swap Info Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setMinimalSwapInfoPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s balance in a Minimal Swap Info Pool to the result of the `mutation` function when called with\n     * the current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateMinimalSwapInfoPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) internal returns (int256) {\n        bytes32 currentBalance = _getMinimalSwapInfoPoolBalance(poolId, token);\n\n        bytes32 newBalance = mutation(currentBalance, amount);\n        _minimalSwapInfoPoolsBalances[poolId][token] = newBalance;\n\n        return newBalance.managedDelta(currentBalance);\n    }\n\n    /**\n     * @dev Returns an array with all the tokens and balances in a Minimal Swap Info Pool. The order may change when\n     * tokens are registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     */\n    function _getMinimalSwapInfoPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n        tokens = new IERC20[](poolTokens.length());\n        balances = new bytes32[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableSet's length, we can use\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\n            IERC20 token = IERC20(poolTokens.unchecked_at(i));\n            tokens[i] = token;\n            balances[i] = _minimalSwapInfoPoolsBalances[poolId][token];\n        }\n    }\n\n    /**\n     * @dev Returns the balance of a token in a Minimal Swap Info Pool.\n     *\n     * Requirements:\n     *\n     * - `poolId` must be a Minimal Swap Info Pool\n     * - `token` must be registered in the Pool\n     */\n    function _getMinimalSwapInfoPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        bytes32 balance = _minimalSwapInfoPoolsBalances[poolId][token];\n\n        // A non-zero balance guarantees that the token is registered. If zero, we manually check if the token is\n        // registered in the Pool. Token registration implies that the Pool is registered as well, which lets us save\n        // gas by not performing the check.\n        bool tokenRegistered = balance.isNotZero() || _minimalSwapInfoPoolsTokens[poolId].contains(address(token));\n\n        if (!tokenRegistered) {\n            // The token might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     */\n    function _isMinimalSwapInfoPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n        return poolTokens.contains(address(token));\n    }\n}\n"
    },
    "contracts/libraries/balances/TwoTokenPoolsBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../helpers/RequiemErrors.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nimport \"./BalanceAllocation.sol\";\nimport \"../../PoolRegistry.sol\";\n\nabstract contract TwoTokenPoolsBalance is PoolRegistry {\n    using BalanceAllocation for bytes32;\n\n    // Data for Pools with the Two Token specialization setting\n    //\n    // These are similar to the Minimal Swap Info Pool case (because the Pool only has two tokens, and therefore there\n    // are only two balances to read), but there's a key difference in how data is stored. Keeping a set makes little\n    // sense, as it will only ever hold two tokens, so we can just store those two directly.\n    //\n    // The gas savings associated with using these Pools come from how token balances are stored: cash amounts for token\n    // A and token B are packed together, as are managed amounts. Because only cash changes in a swap, there's no need\n    // to write to this second storage slot. A single last change block number for both tokens is stored with the packed\n    // cash fields.\n\n    struct TwoTokenPoolBalances {\n        bytes32 sharedCash;\n        bytes32 sharedManaged;\n    }\n\n    // We could just keep a mapping from Pool ID to TwoTokenSharedBalances, but there's an issue: we wouldn't know to\n    // which tokens those balances correspond. This would mean having to also check which are registered with the Pool.\n    //\n    // What we do instead to save those storage reads is keep a nested mapping from the token pair hash to the balances\n    // struct. The Pool only has two tokens, so only a single entry of this mapping is set (the one that corresponds to\n    // that pair's hash).\n    //\n    // This has the trade-off of making Vault code that interacts with these Pools cumbersome: both balances must be\n    // accessed at the same time by using both token addresses, and some logic is needed to determine how the pair hash\n    // is computed. We do this by sorting the tokens, calling the token with the lowest numerical address value token A,\n    // and the other one token B. In functions where the token arguments could be either A or B, we use X and Y instead.\n    //\n    // If users query a token pair containing an unregistered token, the Pool will generate a hash for a mapping entry\n    // that was not set, and return zero balances. Non-zero balances are only possible if both tokens in the pair\n    // are registered with the Pool, which means we don't have to check the TwoTokenPoolTokens struct, and can save\n    // storage reads.\n\n    struct TwoTokenPoolTokens {\n        IERC20 tokenA;\n        IERC20 tokenB;\n        mapping(bytes32 => TwoTokenPoolBalances) balances;\n    }\n\n    mapping(bytes32 => TwoTokenPoolTokens) private _twoTokenPoolTokens;\n\n    /**\n     * @dev Registers tokens in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokenX` and `tokenY` must not be the same\n     * - The tokens must be ordered: tokenX < tokenY\n     */\n    function _registerTwoTokenPoolTokens(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    ) internal {\n        // Not technically true since we didn't register yet, but this is consistent with the error messages of other\n        // specialization settings.\n        _require(tokenX != tokenY, Errors.TOKEN_ALREADY_REGISTERED);\n\n        _require(tokenX < tokenY, Errors.UNSORTED_TOKENS);\n\n        // A Two Token Pool with no registered tokens is identified by having zero addresses for tokens A and B.\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n        _require(poolTokens.tokenA == IERC20(address(0)) && poolTokens.tokenB == IERC20(address(0)), Errors.TOKENS_ALREADY_SET);\n\n        // Since tokenX < tokenY, tokenX is A and tokenY is B\n        poolTokens.tokenA = tokenX;\n        poolTokens.tokenB = tokenY;\n\n        // Note that we don't initialize the balance mapping: the default value of zero corresponds to an empty\n        // balance.\n    }\n\n    /**\n     * @dev Deregisters tokens in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokenX` and `tokenY` must be registered in the Pool\n     * - both tokens must have zero balance in the Vault\n     */\n    function _deregisterTwoTokenPoolTokens(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    ) internal {\n        (\n            bytes32 balanceA,\n            bytes32 balanceB,\n            TwoTokenPoolBalances storage poolBalances\n        ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\n\n        _require(balanceA.isZero() && balanceB.isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n        delete _twoTokenPoolTokens[poolId];\n\n        // For consistency with other Pool specialization settings, we explicitly reset the packed cash field (which may\n        // have a non-zero last change block).\n        delete poolBalances.sharedCash;\n    }\n\n    /**\n     * @dev Sets the cash balances of a Two Token Pool's tokens.\n     *\n     * WARNING: this assumes `tokenA` and `tokenB` are the Pool's two registered tokens, and are in the correct order.\n     */\n    function _setTwoTokenPoolCashBalances(\n        bytes32 poolId,\n        IERC20 tokenA,\n        bytes32 balanceA,\n        IERC20 tokenB,\n        bytes32 balanceB\n    ) internal {\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n        TwoTokenPoolBalances storage poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\n        poolBalances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a Two Token Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _twoTokenPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`'s balance in a Two Token Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _twoTokenPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s managed balance in a Two Token Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setTwoTokenPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`'s balance in a Two Token Pool to the result of the `mutation` function when called with\n     * the current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateTwoTokenPoolSharedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) private returns (int256) {\n        (\n            TwoTokenPoolBalances storage balances,\n            IERC20 tokenA,\n            bytes32 balanceA,\n            ,\n            bytes32 balanceB\n        ) = _getTwoTokenPoolBalances(poolId);\n\n        int256 delta;\n        if (token == tokenA) {\n            bytes32 newBalance = mutation(balanceA, amount);\n            delta = newBalance.managedDelta(balanceA);\n            balanceA = newBalance;\n        } else {\n            // token == tokenB\n            bytes32 newBalance = mutation(balanceB, amount);\n            delta = newBalance.managedDelta(balanceB);\n            balanceB = newBalance;\n        }\n\n        balances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\n        balances.sharedManaged = BalanceAllocation.toSharedManaged(balanceA, balanceB);\n\n        return delta;\n    }\n\n    /*\n     * @dev Returns an array with all the tokens and balances in a Two Token Pool. The order may change when\n     * tokens are registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     */\n    function _getTwoTokenPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\n\n        // Both tokens will either be zero (if unregistered) or non-zero (if registered), but we keep the full check for\n        // clarity.\n        if (tokenA == IERC20(address(0)) || tokenB == IERC20(address(0))) {\n            return (new IERC20[](0), new bytes32[](0));\n        }\n\n        // Note that functions relying on this getter expect tokens to be properly ordered, so we use the (A, B)\n        // ordering.\n\n        tokens = new IERC20[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        balances = new bytes32[](2);\n        balances[0] = balanceA;\n        balances[1] = balanceB;\n    }\n\n    /**\n     * @dev Same as `_getTwoTokenPoolTokens`, except it returns the two tokens and balances directly instead of using\n     * an array, as well as a storage pointer to the `TwoTokenPoolBalances` struct, which can be used to update it\n     * without having to recompute the pair hash and storage slot.\n     */\n    function _getTwoTokenPoolBalances(bytes32 poolId)\n        private\n        view\n        returns (\n            TwoTokenPoolBalances storage poolBalances,\n            IERC20 tokenA,\n            bytes32 balanceA,\n            IERC20 tokenB,\n            bytes32 balanceB\n        )\n    {\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n        tokenA = poolTokens.tokenA;\n        tokenB = poolTokens.tokenB;\n\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n        poolBalances = poolTokens.balances[pairHash];\n\n        bytes32 sharedCash = poolBalances.sharedCash;\n        bytes32 sharedManaged = poolBalances.sharedManaged;\n\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\n    }\n\n    /**\n     * @dev Returns the balance of a token in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * This function is convenient but not particularly gas efficient, and should be avoided during gas-sensitive\n     * operations, such as swaps. For those, _getTwoTokenPoolSharedBalances provides a more flexible interface.\n     *\n     * Requirements:\n     *\n     * - `token` must be registered in the Pool\n     */\n    function _getTwoTokenPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        // We can't just read the balance of token, because we need to know the full pair in order to compute the pair\n        // hash and access the balance mapping. We therefore rely on `_getTwoTokenPoolBalances`.\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\n\n        if (token == tokenA) {\n            return balanceA;\n        } else if (token == tokenB) {\n            return balanceB;\n        } else {\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Returns the balance of the two tokens in a Two Token Pool.\n     *\n     * The returned balances are those of token A and token B, where token A is the lowest of token X and token Y, and\n     * token B the other.\n     *\n     * This function also returns a storage pointer to the TwoTokenPoolBalances struct associated with the token pair,\n     * which can be used to update it without having to recompute the pair hash and storage slot.\n     *\n     * Requirements:\n     *\n     * - `poolId` must be a Minimal Swap Info Pool\n     * - `tokenX` and `tokenY` must be registered in the Pool\n     */\n    function _getTwoTokenPoolSharedBalances(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    )\n        internal\n        view\n        returns (\n            bytes32 balanceA,\n            bytes32 balanceB,\n            TwoTokenPoolBalances storage poolBalances\n        )\n    {\n        (IERC20 tokenA, IERC20 tokenB) = _sortTwoTokens(tokenX, tokenY);\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n\n        poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\n\n        // Because we're reading balances using the pair hash, if either token X or token Y is not registered then\n        // *both* balance entries will be zero.\n        bytes32 sharedCash = poolBalances.sharedCash;\n        bytes32 sharedManaged = poolBalances.sharedManaged;\n\n        // A non-zero balance guarantees that both tokens are registered. If zero, we manually check whether each\n        // token is registered in the Pool. Token registration implies that the Pool is registered as well, which\n        // lets us save gas by not performing the check.\n        bool tokensRegistered = sharedCash.isNotZero() ||\n            sharedManaged.isNotZero() ||\n            (_isTwoTokenPoolTokenRegistered(poolId, tokenA) && _isTwoTokenPoolTokenRegistered(poolId, tokenB));\n\n        if (!tokensRegistered) {\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     */\n    function _isTwoTokenPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n\n        // The zero address can never be a registered token.\n        return (token == poolTokens.tokenA || token == poolTokens.tokenB) && token != IERC20(address(0));\n    }\n\n    /**\n     * @dev Returns the hash associated with a given token pair.\n     */\n    function _getTwoTokenPairHash(IERC20 tokenA, IERC20 tokenB) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenA, tokenB));\n    }\n\n    /**\n     * @dev Sorts two tokens in ascending order, returning them as a (tokenA, tokenB) tuple.\n     */\n    function _sortTwoTokens(IERC20 tokenX, IERC20 tokenY) private pure returns (IERC20, IERC20) {\n        return tokenX < tokenY ? (tokenX, tokenY) : (tokenY, tokenX);\n    }\n}\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IWETH.sol\";\n\nimport \"./interfaces/IAuthorizer.sol\";\n\nimport \"./VaultAuthorization.sol\";\nimport \"./FlashLoans.sol\";\nimport \"./Swaps.sol\";\n\n/**\n * @dev The `Vault` is Balancer V2's core contract. A single instance of it exists for the entire network, and it is the\n * entity used to interact with Pools by Liquidity Providers who join and exit them, Traders who swap, and Asset\n * Managers who withdraw and deposit tokens.\n *\n * The `Vault`'s source code is split among a number of sub-contracts, with the goal of improving readability and making\n * understanding the system easier. Most sub-contracts have been marked as `abstract` to explicitly indicate that only\n * the full `Vault` is meant to be deployed.\n *\n * Roughly speaking, these are the contents of each sub-contract:\n *\n *  - `AssetManagers`: Pool token Asset Manager registry, and Asset Manager interactions.\n *  - `Fees`: set and compute protocol fees.\n *  - `FlashLoans`: flash loan transfers and fees.\n *  - `PoolBalances`: Pool joins and exits.\n *  - `PoolRegistry`: Pool registration, ID management, and basic queries.\n *  - `PoolTokens`: Pool token registration and registration, and balance queries.\n *  - `Swaps`: Pool swaps.\n *  - `UserBalance`: manage user balances (Internal Balance operations and external balance transfers)\n *  - `VaultAuthorization`: access control, relayers and signature validation.\n *\n * Additionally, the different Pool specializations are handled by the `GeneralPoolsBalance`,\n * `MinimalSwapInfoPoolsBalance` and `TwoTokenPoolsBalance` sub-contracts, which in turn make use of the\n * `BalanceAllocation` library.\n *\n * The most important goal of the `Vault` is to make token swaps use as little gas as possible. This is reflected in a\n * multitude of design decisions, from minor things like the format used to store Pool IDs, to major features such as\n * the different Pool specialization settings.\n *\n * Finally, the large number of tasks carried out by the Vault means its bytecode is very large, close to exceeding\n * the contract size limit imposed by EIP 170 (https://eips.ethereum.org/EIPS/eip-170). Manual tuning of the source code\n * was required to improve code generation and bring the bytecode size below this limit. This includes extensive\n * utilization of `internal` functions (particularly inside modifiers), usage of named return arguments, dedicated\n * storage access methods, dynamic revert reason generation, and usage of inline assembly, to name a few.\n */\nabstract contract Vault is VaultAuthorization, FlashLoans, Swaps {\n    constructor(\n        IAuthorizer authorizer,\n        IWETH weth,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration\n    ) VaultAuthorization(authorizer) AssetHelpers(weth) TemporarilyPausableVault(pauseWindowDuration, bufferPeriodDuration) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function setPaused(bool paused) external override nonReentrant authenticate {\n        _setPausedVault(paused);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WETH() external view override returns (IWETH) {\n        return _WETH();\n    }\n}\n"
    },
    "contracts/FlashLoans.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// This flash loan provider was based on the Aave protocol's open source\n// implementation and terminology and interfaces are intentionally kept\n// similar\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/helpers/RequiemErrors.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/helpers/TemporarilyPausableFlashLoan.sol\";\nimport \"./Fees.sol\";\nimport \"./interfaces/IFlashLoanRecipient.sol\";\n\n/**\n * @dev Handles Flash Loans through the Vault. Calls the `receiveFlashLoan` hook on the flash loan recipient\n * contract, which implements the `IFlashLoanRecipient` interface.\n */\nabstract contract FlashLoans is Fees, ReentrancyGuard, TemporarilyPausableFlashLoan {\n    using SafeERC20 for IERC20;\n\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external override nonReentrant whenNotPausedFlashLoan {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\n\n        // Used to ensure `tokens` is sorted in ascending order, which ensures token uniqueness.\n        IERC20 previousToken = IERC20(address(0));\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n\n            _require(token > previousToken, token == IERC20(address(0)) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);\n            previousToken = token;\n\n            preLoanBalances[i] = token.balanceOf(address(this));\n            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);\n\n            _require(preLoanBalances[i] >= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);\n            token.safeTransfer(address(recipient), amount);\n        }\n\n        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 preLoanBalance = preLoanBalances[i];\n\n            // Checking for loan repayment first (without accounting for fees) makes for simpler debugging, and results\n            // in more accurate revert reasons if the flash loan protocol fee percentage is zero.\n            uint256 postLoanBalance = token.balanceOf(address(this));\n            _require(postLoanBalance >= preLoanBalance, Errors.INVALID_POST_LOAN_BALANCE);\n\n            // No need for checked arithmetic since we know the loan was fully repaid.\n            uint256 receivedFeeAmount = postLoanBalance - preLoanBalance;\n            _require(receivedFeeAmount >= feeAmounts[i], Errors.INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT);\n\n            _payFeeAmount(token, receivedFeeAmount);\n            emit FlashLoan(recipient, token, amounts[i], receivedFeeAmount);\n        }\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    // function getPausedState()\n    //     external\n    //     view\n    //     override(TemporarilyPausable, ITemporarilyPausableVault)\n    //     returns (\n    //         bool paused,\n    //         uint256 pauseWindowEndTime,\n    //         uint256 bufferPeriodEndTime\n    //     )\n    // {\n    //     TemporarilyPausable.getPausedState(paused, pauseWindowEndTime, bufferPeriodEndTime);\n    // }\n}\n"
    },
    "contracts/libraries/helpers/TemporarilyPausableFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ITemporarilyPausableFlashLoan.sol\";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausableFlashLoan is ITemporarilyPausableFlashLoan {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, \"MAX_PAUSE_WINDOW_DURATION\");\n        require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, \"MAX_BUFFER_PERIOD_DURATION\");\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPausedFlashLoan() {\n        _ensureNotPausedFlashLoan();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedStateFlashLoan()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPausedFlashLoan();\n        pauseWindowEndTime = _getPauseWindowEndTimeFlashLoan();\n        bufferPeriodEndTime = _getBufferPeriodEndTimeFlashLoan();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPausedFlashLoan(bool paused) internal {\n        if (paused) {\n            require(block.timestamp < _getPauseWindowEndTimeFlashLoan(), \"PAUSE_WINDOW_EXPIRED\");\n        } else {\n            require(block.timestamp < _getBufferPeriodEndTimeFlashLoan(), \"BUFFER_PERIOD_EXPIRED\");\n        }\n\n        _paused = paused;\n        emit PausedStateChangedFlashLoan(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPausedFlashLoan() internal view {\n        require(_isNotPausedFlashLoan(), \"PAUSED\");\n    }\n\n    /**\n     * @dev Reverts if the contract is not paused.\n     */\n    function _ensurePausedFlashLoan() internal view {\n        require(!_isNotPausedFlashLoan(), \"NOT_PAUSED\");\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPausedFlashLoan() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTimeFlashLoan() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTimeFlashLoan() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTimeFlashLoan() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n"
    },
    "contracts/interfaces/ITemporarilyPausableFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausableFlashLoan {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChangedFlashLoan(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedStateFlashLoan()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n"
    },
    "contracts/interfaces/IVaultNonPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20/IERC20.sol\";\nimport \"./ISignaturesValidator.sol\";\nimport \"./IWETH.sol\";\n\nimport \"./IAsset.sol\";\nimport \"./IAuthorizer.sol\";\nimport \"./IFlashLoanRecipient.sol\";\nimport \"./IProtocolFeesCollector.sol\";\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVaultNonPausable is ISignaturesValidator {\n    // Generalities about the Vault:\n    //\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\n    //\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\n    //\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\n\n    // Authorizer\n    //\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\n    // can perform a given action.\n\n    /**\n     * @dev Returns the Vault's Authorizer.\n     */\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    /**\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\n     *\n     * Emits an `AuthorizerChanged` event.\n     */\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\n\n    /**\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\n     */\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\n\n    // Relayers\n    //\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n    // this power, two things must occur:\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n    //    functions.\n    //  - Each user must approve the relayer to act on their behalf.\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n    /**\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n    /**\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    /**\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\n     */\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user's Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n    /**\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n\n    /**\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n    /**\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n    /**\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    // Flash Loans\n\n    /**\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\n     *\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\n     * for each token contract. `tokens` must be sorted in ascending order.\n     *\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\n     * `receiveFlashLoan` call.\n     *\n     * Emits `FlashLoan` events.\n     */\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n\n    /**\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\n     */\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\n\n    // Asset Management\n    //\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\n    //\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\n    //\n    // This concept is unrelated to the IAsset interface.\n\n    /**\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\n     *\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\n     * operations of different kinds, with different Pools and tokens, at once.\n     *\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\n     */\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    /**\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\n     *\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\n     *\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\n     */\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n\n    /**\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\n     */\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n    // Protocol Fees\n    //\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\n    // permissioned accounts.\n    //\n    // There are two kinds of protocol fees:\n    //\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\n    //\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\n    // exiting a Pool in debt without first paying their share.\n\n    /**\n     * @dev Returns the current protocol fee module.\n     */\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\n\n    /**\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\n     * error in some part of the system.\n     *\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\n     *\n     * While the contract is paused, the following features are disabled:\n     * - depositing and transferring internal balance\n     * - transferring external balance (using the Vault's allowance)\n     * - swaps\n     * - joining Pools\n     * - Asset Manager interactions\n     *\n     * Internal Balance can still be withdrawn, and Pools exited.\n     */\n    function setPaused(bool paused) external;\n\n    /**\n     * @dev Returns the Vault's WETH instance.\n     */\n    function WETH() external view returns (IWETH);\n    // solhint-disable-previous-line func-name-mixedcase\n}\n"
    },
    "contracts/interfaces/ISignaturesValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidator {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n"
    },
    "contracts/RequiemZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./interfaces/IRequiemRouterLite.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/Babylonian.sol\";\n\ncontract RequiemZap is ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    // governance\n    address public governance;\n    address public WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    IUniswapV2Router public uniRouter;\n    IRequiemRouter public requiemRouter;\n    IRequiemFactory public requiemFactory;\n    IRequiemFormula public requiemFormula;\n\n    mapping(address => mapping(address => address[])) public RequiemPairs; // [input -> output] => requiem pair\n    uint public maxResidual = 100; // 1%, set 10000 to disable\n    address[] public tokensResidual;\n\n    event ZapIn(address indexed sender, address from, uint256 amtFrom, address pool, uint256 amtLp);\n    event ZapOut(address indexed sender, address pool, uint256 amtLp, address to, uint256 amtTo);\n    event Withdraw(address indexed token, uint256 amount, address to);\n    event LogGovernance(address governance);\n\n    receive() external payable {\n        require(msg.sender != tx.origin, \"Zap: Do not send ETH directly\");\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"Zap: !governance\");\n        _;\n    }\n\n    constructor(IUniswapV2Router _uniRouter, IRequiemRouter _requiemRouter) {\n        governance = msg.sender;\n        uniRouter = _uniRouter;\n        requiemRouter = _requiemRouter;\n        requiemFactory = IRequiemFactory(_requiemRouter.factory());\n        requiemFormula = IRequiemFormula(_requiemRouter.formula());\n        WETH = _requiemRouter.WETH();\n    }\n\n    /* ========== External Functions ========== */\n\n    // _to: must be a pair lp\n    // _from: must be in lp\n    // _amounts: amount_from, _minTokenB, _minLp\n    function zapInToken(address _from, uint[] calldata amounts, address _to, bool transferResidual) external nonReentrant returns (uint256 lpAmt) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amounts[0]);\n        _approveTokenIfNeeded(_from);\n\n        if (_from == IRequiemPair(_to).token0() || _from == IRequiemPair(_to).token1()) {\n            // swap half amount for other\n            address other;\n            uint256 sellAmount;\n            {\n                address token0 = IRequiemPair(_to).token0();\n                address token1 = IRequiemPair(_to).token1();\n                other = _from == token0 ? token1 : token0;\n                sellAmount = calculateSwapInAmount(_to, _from, amounts[0], token0);\n            }\n            uint otherAmount = _swap(_from, sellAmount, other, address(this), _to);\n            require(otherAmount >= amounts[1], \"Zap: Insufficient Receive Amount\");\n\n            lpAmt = _pairDeposit(_to, _from, other, amounts[0].sub(sellAmount), otherAmount, msg.sender, requiemFactory.isPair(_to), transferResidual);\n        } else {\n            uint bnbAmount = _swapTokenForBNB(_from, amounts[0], address(this), address(0));\n            lpAmt = _swapETHToLp(IRequiemPair(_to), bnbAmount, msg.sender, 0, transferResidual);\n        }\n\n        require(lpAmt >= amounts[2], \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, _from, amounts[0], _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _to: must be a pair lp\n    function zapIn(address _to, uint _minTokenB, uint _minLp, bool transferResidual) external payable nonReentrant returns (uint256) {\n        uint256 lpAmt = _swapETHToLp(IRequiemPair(_to), msg.value, msg.sender, _minTokenB, transferResidual);\n        require(lpAmt >= _minLp, \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, WETH, msg.value, _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _from: must be a pair lp\n    // _toToken: must be in lp\n    function zapOut(address _from, uint amount, address _toToken, uint256 _minTokensRec) public nonReentrant returns (uint256) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amount);\n        _approveTokenIfNeeded(_from);\n\n        address token0;\n        address token1;\n        uint256 amountA;\n        uint256 amountB;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            token0 = pair.token0();\n            token1 = pair.token1();\n            bool isRequiemPair = requiemFactory.isPair(_from);\n            if (isRequiemPair) {\n                (amountA, amountB) = requiemRouter.removeLiquidity(_from, token0, token1, amount, 1, 1, address(this), block.timestamp);\n            } else {\n                (amountA, amountB) = uniRouter.removeLiquidity(token0, token1, amount, 1, 1, address(this), block.timestamp);\n            }\n        }\n\n        uint256 tokenBought;\n        _approveTokenIfNeeded(token0);\n        _approveTokenIfNeeded(token1);\n        if (_toToken == ETH_ADDRESS) {\n            address _lpOfFromAndTo = WETH == token0 || WETH == token1 ? _from : address(0);\n            tokenBought = _swapTokenForBNB(token0, amountA, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swapTokenForBNB(token1, amountB, address(this), _lpOfFromAndTo));\n        } else {\n            address _lpOfFromAndTo = _toToken == token0 || _toToken == token1 ? _from : address(0);\n            tokenBought = _swap(token0, amountA, _toToken, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swap(token1, amountB, _toToken, address(this), _lpOfFromAndTo));\n        }\n\n        require(tokenBought >= _minTokensRec, \"Zap: High Slippage Out\");\n        if (_toToken == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(msg.sender, tokenBought);\n        } else {\n            IERC20(_toToken).safeTransfer(msg.sender, tokenBought);\n        }\n\n        emit ZapOut(msg.sender, _from, amount, _toToken, tokenBought);\n        return tokenBought;\n    }\n\n    function zapOutWithPermit(\n        address _from,\n        uint256 amount,\n        address _toToken,\n        uint256 _minTokensRec,\n        uint256 _approvalAmount,\n        uint256 _deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        // permit\n        IRequiemPair(_from).permit(\n            msg.sender,\n            address(this),\n            _approvalAmount,\n            _deadline,\n            v,\n            r,\n            s\n        );\n\n        return zapOut(_from, amount, _toToken, _minTokensRec);\n    }\n\n    /* ========== View Functions ===========*/\n    // _from: token A\n    // return amount B that will be convert from A to perform zap in\n    // return amount A that will be convert to B to perform zap in\n    function getAmountBToZapIn(address _from, uint _fromAmount, address lp) external view returns (uint256 amountBConverted, uint256 amountASell) {\n        address other;\n        uint sellAmount;\n        {\n            IRequiemPair pair = IRequiemPair(lp);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _from == token0 ? token1 : token0;\n            sellAmount = calculateSwapInAmount(lp, _from, _fromAmount, token0);\n        }\n\n        address[] memory path = new address[](1);\n        path[0] = lp;\n        uint[] memory amounts = requiemFormula.getFactoryAmountsOut(address(requiemFactory), _from, other, sellAmount, path);\n        return (amounts[amounts.length - 1], sellAmount);\n    }\n\n    // _from: lp pair\n    // return amountOtherSell _otherToken that will be removed from pair\n    // return amountToConverted _toToken that will be converted from other\n    // return amountToOrigin _toToken that will be removed from pair\n    function getAmountToZapOut(address _from, uint amount, address _toToken) external view\n    returns (uint256 amountOtherSell, uint256 amountToConverted, uint256 amountToOrigin) {\n        address other;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _toToken == token0 ? token1 : token0;\n        }\n        uint sellAmount;\n        uint amountToRemoved;\n        {\n            uint _totalSupply = IERC20(_from).totalSupply();\n            sellAmount = amount.mul(IERC20(other).balanceOf(_from)) / _totalSupply;\n            amountToRemoved = amount.mul(IERC20(_toToken).balanceOf(_from)) / _totalSupply;\n        }\n\n        uint _amountOut = _getRemovedReserveAmountOut(_from, other, sellAmount, amountToRemoved);\n        return (sellAmount, _amountOut, amountToRemoved);\n    }\n\n    function calculateSwapInAmount(address pair, address tokenIn, uint256 userIn, address pairToken0) internal view returns (uint256) {\n        (uint32 tokenWeight0, uint32 tokenWeight1,) = requiemFactory.getWeightsAndSwapFee(pair);\n\n        if (tokenWeight0 == 50) {\n            (uint256 res0, uint256 res1,) = IRequiemPair(pair).getReserves();\n            uint reserveIn = tokenIn == pairToken0 ? res0 : res1;\n            return Babylonian\n                .sqrt(reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009)))\n                .sub(reserveIn.mul(1997)) / 1994;\n        } else {\n            uint256 otherWeight = tokenIn == pairToken0 ? uint(tokenWeight1) : uint(tokenWeight0);\n            return userIn.mul(otherWeight).div(100);\n        }\n    }\n\n    /* ========== Private Functions ========== */\n    function _getRemovedReserveAmountOut(address pair, address tokenIn, uint sellAmount, uint amountToRemoved) internal view returns (uint) {\n        (, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) =\n        requiemFormula.getFactoryReserveAndWeights(address(requiemFactory), pair, tokenIn);\n        return requiemFormula.getAmountOut(sellAmount, reserveIn.sub(sellAmount), reserveOut.sub(amountToRemoved), tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    function _approveTokenIfNeeded(address token) private {\n        if (IERC20(token).allowance(address(this), address(uniRouter)) == 0) {\n            IERC20(token).safeApprove(address(uniRouter), type(uint).max);\n        }\n        if (IERC20(token).allowance(address(this), address(requiemRouter)) == 0) {\n            IERC20(token).safeApprove(address(requiemRouter), type(uint).max);\n        }\n    }\n\n    function _pairDeposit(\n        address _pair,\n        address _poolToken0,\n        address _poolToken1,\n        uint256 token0Bought,\n        uint256 token1Bought,\n        address receiver,\n        bool isRequiemPair,\n        bool transferResidual\n    ) internal returns (uint256 lpAmt) {\n        _approveTokenIfNeeded(_poolToken0);\n        _approveTokenIfNeeded(_poolToken1);\n\n        uint256 amountA;\n        uint256 amountB;\n        if (isRequiemPair) {\n            (amountA, amountB, lpAmt) = requiemRouter.addLiquidity(_pair, _poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        } else {\n            (amountA, amountB, lpAmt) = uniRouter.addLiquidity(_poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        }\n\n        uint amountAResidual = token0Bought.sub(amountA);\n        if (transferResidual || amountAResidual > token0Bought.mul(maxResidual).div(10000)) {\n            if (amountAResidual > 0) {\n                //Returning Residue in token0, if any.\n                _transferToken(_poolToken0, msg.sender, amountAResidual);\n            }\n        }\n\n        uint amountBRedisual = token1Bought.sub(amountB);\n        if (transferResidual || amountBRedisual > token1Bought.mul(maxResidual).div(10000)) {\n            if (amountBRedisual > 0) {\n                //Returning Residue in token1, if any\n                _transferToken(_poolToken1, msg.sender, amountBRedisual);\n            }\n        }\n\n        return lpAmt;\n    }\n\n    function _swapETHToLp(IRequiemPair pair, uint amount, address receiver, uint _minTokenB, bool transferResidual) private returns (uint256 lpAmt) {\n        address lp = address(pair);\n\n        // Lp\n        if (pair.token0() == WETH || pair.token1() == WETH) {\n            address token = pair.token0() == WETH ? pair.token1() : pair.token0();\n            uint swapValue = calculateSwapInAmount(lp, WETH, amount, pair.token0());\n            uint tokenAmount = _swapETHForToken(token, swapValue, address(this), lp);\n            require(tokenAmount >= _minTokenB, \"Zap: Insufficient Receive Amount\");\n\n            uint256 WETHAmount = amount.sub(swapValue);\n            IWETH(WETH).deposit{value : WETHAmount}();\n            lpAmt = _pairDeposit(lp, WETH, token, WETHAmount, tokenAmount, receiver, requiemFactory.isPair(lp), transferResidual);\n        } else {\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            uint token0Amount;\n            uint token1Amount;\n            {\n                (uint32 tokenWeight0,,) = requiemFactory.getWeightsAndSwapFee(lp);\n                uint swap0Value = amount.mul(uint(tokenWeight0)).div(100);\n                token0Amount = _swapETHForToken(token0, swap0Value, address(this), address(0));\n                token1Amount = _swapETHForToken(token1, amount.sub(swap0Value), address(this), address(0));\n            }\n\n            lpAmt = _pairDeposit(lp, token0, token1, token0Amount, token1Amount, receiver, requiemFactory.isPair(lp), transferResidual);\n        }\n    }\n\n    function _swapETHForToken(address token, uint value, address _receiver, address lpBNBToken) private returns (uint) {\n        if (token == WETH) {\n            IWETH(WETH).deposit{value : value}();\n            if (_receiver != address(this)) {\n                IERC20(WETH).safeTransfer(_receiver, value);\n            }\n            return value;\n        }\n        address[] memory path = RequiemPairs[WETH][token];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else if (lpBNBToken != address(0)) {\n            path = new address[](1);\n            path[0] = lpBNBToken;\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path BNBToken\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swapTokenForBNB(address token, uint amount, address _receiver, address lpTokenBNB) private returns (uint) {\n        if (token == WETH) {\n            _transferToken(WETH, _receiver, amount);\n            return amount;\n        }\n        address[] memory path = RequiemPairs[token][WETH];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else if (lpTokenBNB != address(0)) {\n            path = new address[](1);\n            path[0] = lpTokenBNB;\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path TokenBNB\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swap(address _from, uint _amount, address _to, address _receiver, address _lpOfFromTo) internal returns (uint) {\n        if (_from == _to) {\n            if (_receiver != address(this)) {\n                IERC20(_from).safeTransfer(_receiver, _amount);\n            }\n            return _amount;\n        }\n        address[] memory path = RequiemPairs[_from][_to];\n        uint[] memory amounts;\n        if (path.length > 0) {// use requiem\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else if (_lpOfFromTo != address(0)) {\n            path = new address[](1);\n            path[0] = _lpOfFromTo;\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path swap\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _transferToken(address token, address to, uint amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token == WETH) {\n            IWETH(WETH).withdraw(amount);\n            if (to != address(this)) {\n                TransferHelper.safeTransferETH(to, amount);\n            }\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n        return;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n    function withdraw(address to) external onlyGovernance {\n        address[] memory _tokens = tokensResidual;\n        withdrawToken(_tokens, to);\n    }\n\n    function withdrawToken(address[] memory tokens, address to) public onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _withdraw(tokens[i], to);\n        }\n    }\n\n    function withdrawTokenAmount(address token, address to, uint256 amount) external onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n        IERC20(token).safeTransfer(to, amount);\n        emit Withdraw(token, amount, to);\n    }\n\n    function _withdraw(address _token, address _to) internal {\n        if (_token == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(_to, address(this).balance);\n            emit Withdraw(_token, address(this).balance, _to);\n            return;\n        }\n\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, _balance);\n        emit Withdraw(_token, _balance, _to);\n    }\n\n    function setTokensResidual(address[] memory _tokensResidual) external onlyGovernance {\n        tokensResidual = _tokensResidual;\n    }\n\n    function addTokensResidual(address _token) external onlyGovernance {\n        tokensResidual.push(_token);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n        emit LogGovernance(governance);\n    }\n\n    function setRequiemPairs(address _input, address _output, address [] memory _pair) external onlyGovernance {\n        RequiemPairs[_input][_output] = _pair;\n    }\n\n    function setMaxResidual(uint _maxResidual) external onlyGovernance {\n        maxResidual = _maxResidual;\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemRouterLite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IRequiemRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/interfaces/IRequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint);\n    function feeTo() external view returns (address);\n    function formula() external view returns (address);\n    function protocolFee() external view returns (uint);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function isPair(address) external view returns (bool);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external returns (address pair);\n    function getWeightsAndSwapFee(address pair) external view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setProtocolFee(uint) external;\n}\n"
    },
    "contracts/interfaces/IRequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\ninterface IRequiemPair is IRequiemERC20 {\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity >=0.5.16;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n\n    function getReserveAndWeights(address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountIn);\n\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external view returns (uint amountIn);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountOut);\n\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external view returns (uint amountOut);\n\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external view returns (bool);\n    function getReserves(address pair, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n    function mintLiquidityFee(\n        uint totalLiquidity,\n        uint112 reserve0,\n        uint112  reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112  collectedFee0,\n        uint112 collectedFee1) external view returns (uint amount);\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.16;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./Babylonian.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n    uint256 private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z;\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"../interfaces/IRequiemPair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IRequiemPair(pair).price0CumulativeLast();\n        price1Cumulative = IRequiemPair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IRequiemPair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            (uint32 _tokenWeight0, uint32 _tokenWeight1) = IRequiemPair(pair).getTokenWeights();\n            uint112 mReserve0 = reserve0 * _tokenWeight1;\n            uint112 mReserve1 = reserve1 * _tokenWeight0;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(mReserve1, mReserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(mReserve0, mReserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/RequiemRouterDev.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9;\npragma abicoder v2;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemRouterDev.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract RequiemParaRouter is IRequiemParaRouter {\n    using SafeMath for uint256;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapPara(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        uint[][] memory indexes,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemRouterDev.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ninterface IRequiemParaRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint swapAmount; // tokenInAmount / tokenOutAmount\n        uint limitReturnAmount; // minAmountOut / maxAmountIn\n        uint maxPrice;\n    }\n    function factory() external view returns (address);\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut,\n        uint deadline\n    )\n    external payable returns (uint totalAmountOut);\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint maxTotalAmountIn,\n        uint deadline\n    ) external payable returns (uint totalAmountIn);\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/RequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9;\npragma abicoder v2;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemRouter.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract RequiemRouter is IRequiemRouter {\n    using SafeMath for uint256;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IRequiemRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint swapAmount; // tokenInAmount / tokenOutAmount\n        uint limitReturnAmount; // minAmountOut / maxAmountIn\n        uint maxPrice;\n    }\n    function factory() external view returns (address);\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut,\n        uint deadline\n    )\n    external payable returns (uint totalAmountOut);\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint maxTotalAmountIn,\n        uint deadline\n    ) external payable returns (uint totalAmountIn);\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/test/StakePoolRewardRebaserMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardRebaserMock is IStakePoolRewardRebaser {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRebaseAmount(address rewardToken, uint baseAmount) external override view returns (uint) {\n        return baseAmount.mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardRebaser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardRebaser {\n    function getRebaseAmount(address rewardToken, uint baseAmount) external view returns (uint);\n}"
    },
    "contracts/StakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IEpochController.sol\";\nimport \"./interfaces/stakePool/IStakePoolEpochReward.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\n\n// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\ncontract StakePoolEpochReward is IStakePoolEpochReward {\n    using SafeMath for uint256;\n    uint256 public override version;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastSnapshotIndex;\n        uint256 rewardEarned;\n        uint256 epochTimerStart;\n    }\n\n    struct Snapshot {\n        uint256 time;\n        uint256 rewardReceived;\n        uint256 rewardPerShare;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public override epochController;\n    address public override rewardToken;\n\n    uint256 public withdrawLockupEpochs;\n    uint256 public rewardLockupEpochs;\n\n    mapping(address => UserInfo) public userInfo;\n    Snapshot[] public snapshotHistory;\n\n    address public override stakeToken;\n    address public override rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 private _unlocked = 1;\n    bool private _initialized = false;\n    uint256 public constant BLOCKS_PER_DAY = 28800;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n        Snapshot memory genesisSnapshot = Snapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\n        snapshotHistory.push(genesisSnapshot);\n    }\n\n    modifier lock() {\n        require(_unlocked == 1, \"SPER: LOCKED\");\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SPER: !timelock\");\n        _;\n    }\n\n    modifier onlyEpochController() {\n        require(msg.sender == epochController, \"SPER: !epochController\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        if (_account != address(0)) {\n            UserInfo storage user = userInfo[_account];\n            user.rewardEarned = earned(_account);\n            user.lastSnapshotIndex = latestSnapshotIndex();\n        }\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        address _rewardFund,\n        address _timelock,\n        address _epochController,\n        address _rewardToken,\n        uint256 _withdrawLockupEpochs,\n        uint256 _rewardLockupEpochs\n    ) external {\n        require(_initialized == false, \"SPER: Initialize must be false.\");\n        stakeToken = _stakeToken;\n        rewardToken = _rewardToken;\n        rewardFund = _rewardFund;\n        setEpochController(_epochController);\n        setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setEpochController(address _epochController) public override lock onlyTimeLock {\n        epochController = _epochController;\n        epoch();\n        nextEpochPoint();\n        nextEpochLength();\n        nextEpochAllocatedReward();\n    }\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) public override lock onlyTimeLock {\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: range\"); // <= 2 week\n        withdrawLockupEpochs = _withdrawLockupEpochs;\n        rewardLockupEpochs = _rewardLockupEpochs;\n    }\n\n    function allocateReward(uint256 _amount) external override lock onlyEpochController {\n        require(_amount > 0, \"SPER: Cannot allocate 0\");\n        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\n        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\n        if (balance > 0) {\n            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\n            _amount = _after.sub(_before);\n\n            // Create & add new snapshot\n            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\n            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\n\n            Snapshot memory _newSnapshot = Snapshot({time: block.number, rewardReceived: _amount, rewardPerShare: _nextRPS});\n            emit AllocateReward(block.number, _amount);\n            snapshotHistory.push(_newSnapshot);\n        }\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        if (rewardToken == _token) {\n            // do not allow to drain reward token if less than 1 week after LatestSnapshot\n            if (block.number < (getLatestSnapshot().time + (BLOCKS_PER_DAY * 7))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // =========== Epoch getters\n\n    function epoch() public view override returns (uint256) {\n        return IEpochController(epochController).epoch();\n    }\n\n    function nextEpochPoint() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochPoint();\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochLength();\n    }\n\n    function nextEpochAllocatedReward() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\n    }\n\n    // =========== Snapshot getters\n\n    function latestSnapshotIndex() public view returns (uint256) {\n        return snapshotHistory.length.sub(1);\n    }\n\n    function getLatestSnapshot() internal view returns (Snapshot memory) {\n        return snapshotHistory[latestSnapshotIndex()];\n    }\n\n    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\n        return userInfo[_account].lastSnapshotIndex;\n    }\n\n    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\n        return snapshotHistory[getLastSnapshotIndexOf(_account)];\n    }\n\n    // =========== _account getters\n\n    function rewardPerShare() public view returns (uint256) {\n        return getLatestSnapshot().rewardPerShare;\n    }\n\n    function earned(address _account) public view override returns (uint256) {\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\n        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\n\n        UserInfo memory user = userInfo[_account];\n        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\n    }\n\n    function canWithdraw(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\n    }\n\n    function canClaimReward(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\n    }\n\n    function unlockWithdrawEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\n    }\n\n    function unlockRewardEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SPER: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SPER: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        user.epochTimerStart = epoch(); // reset timer\n        user.amount = user.amount.add(_amount);\n        emit Deposit(_account, _amount);\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _epoch = epoch();\n        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, \"SPER: still in withdraw lockup\");\n        require(user.amount >= _amount, \"SPER: invalid withdraw amount\");\n        _claimReward(false);\n        balance = balance.sub(_amount);\n        user.epochTimerStart = _epoch; // reset timer\n        user.amount = user.amount.sub(_amount);\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _reward = user.rewardEarned;\n        if (_reward > 0) {\n            if (_lockChecked) {\n                uint256 _epoch = epoch();\n                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, \"SPER: still in reward lockup\");\n                user.epochTimerStart = _epoch; // reset timer\n            }\n            user.rewardEarned = 0;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\n            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\n            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\n        }\n    }\n\n    function claimReward() public override {\n        _claimReward(true);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SPER: Not allowed\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        user.rewardEarned = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\ninterface IEpochController {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolEpochReward {\n    event AllocateReward(uint256 blocktime, uint256 amount);\n    event Deposit(address indexed account, uint256 amount);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event Withdraw(address indexed account, uint256 amount);\n\n    function version() external view returns (uint256);\n    function stakeToken() external view returns (address);\n    function rewardToken() external view returns (address);\n    function rewardFund() external view returns (address);\n    function epochController() external view returns (address);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward() external view returns (uint256);\n\n    function earned(address _account) external view returns (uint256);\n\n    function unlockWithdrawEpoch(address _account) external view returns (uint256);\n\n    function unlockRewardEpoch(address _account) external view returns (uint256);\n\n    function stake(uint256) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint256) external;\n\n    function claimReward() external;\n\n    function emergencyWithdraw() external;\n\n    function setEpochController(address) external;\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\n\n    function allocateReward(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity ^0.8.10;\n\ninterface IStakePoolController {\n    event MasterCreated(address indexed farm, address indexed stakeToken, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n    event ChangeGovernance(address indexed governance);\n    event SetFeeCollector(address indexed feeCollector);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n    event SetExtraFeeRate(uint256 indexed amount);\n\n    function allStakePools(uint256) external view returns (address stakePool);\n\n    function isStakePool(address contractAddress) external view returns (bool);\n\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n\n    function setStakePoolVerifier(address contractAddress, bool state) external;\n\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\n\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\n\n    function addStakePoolCreator(address contractAddress) external;\n\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n\n    function setEnableWhitelistRewardRebaser(bool value) external;\n\n    function setEnableWhitelistRewardMultiplier(bool value) external;\n\n    function allStakePoolsLength() external view returns (uint256);\n\n    function create(\n        uint256 version,\n        address stakeToken,\n        address rewardToken,\n        uint256 rewardFundAmount,\n        uint256 delayTimeLock,\n        bytes calldata data\n    ) external returns (address);\n\n    function setGovernance(address) external;\n\n    function setFeeCollector(address _address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n\n    function setExtraFeeRate(uint256 _extraFeeRate) external;\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardMultiplier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardMultiplier {\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n}"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardFund {\n    function initialize(address _stakePool, address _timelock) external;\n\n    function safeTransfer(address _token, address _to, uint _value) external;\n}"
    },
    "contracts/StakePoolEpochRewardCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePoolEpochReward.sol\";\n\ncontract StakePoolEpochRewardCreator is IStakePoolCreator {\n    uint256 public override version = 4001;\n    struct PoolRewardInfo {\n        address epochController;\n        uint256 withdrawLockupEpochs;\n        uint256 rewardLockupEpochs;\n    }\n\n    function create() external override returns (address) {\n        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\n        //\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.initialize(pair, address(stakePoolRewardFund), address(timelock), poolRewardInfo.epochController, rewardToken, poolRewardInfo.withdrawLockupEpochs, poolRewardInfo.rewardLockupEpochs);\n    }\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity ^0.8.10;\n\ninterface IStakePoolCreator {\n    function version() external returns (uint);\n\n    function create() external returns (address);\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external;\n}"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./libraries/SafeMath.sol\";\n\ncontract TimeLock {\n    using SafeMath for uint256;\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 1 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n    bool private _initialized;\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n    bool public admin_initialized;\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() {\n        admin_initialized = false;\n        _initialized = false;\n    }\n\n    function initialize(address _admin, uint256 _delay) public {\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        admin = _admin;\n        _initialized = true;\n        emit NewAdmin(admin);\n        emit NewDelay(delay);\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 _delay) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/StakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePool.sol\";\n\ncontract StakePoolCreator is IStakePoolCreator {\n    uint256 public override version = 3001;\n\n    struct PoolRewardInfo {\n        address rewardRebaser;\n        address rewardMultiplier;\n        uint256 startBlock;\n        uint256 endRewardBlock;\n        uint256 rewardPerBlock;\n        uint256 lockRewardPercent;\n        uint256 startVestingBlock;\n        uint256 endVestingBlock;\n        uint256 unstakingFrozenTime;\n    }\n\n    function create() external override returns (address) {\n        StakePool pool = new StakePool(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePool pool = StakePool(poolAddress);\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.addRewardPool(\n            rewardToken,\n            poolRewardInfo.rewardRebaser,\n            poolRewardInfo.rewardMultiplier,\n            poolRewardInfo.startBlock,\n            poolRewardInfo.endRewardBlock,\n            poolRewardInfo.rewardPerBlock,\n            poolRewardInfo.lockRewardPercent,\n            poolRewardInfo.startVestingBlock,\n            poolRewardInfo.endVestingBlock\n        );\n        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\n    }\n}\n"
    },
    "contracts/StakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\n\ncontract StakePool is IStakePool {\n    using SafeMath for uint256;\n    uint256 public override version;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        mapping(uint8 => uint256) rewardDebt;\n        mapping(uint8 => uint256) reward;\n        mapping(uint8 => uint256) accumulatedEarned; // will accumulate every time user harvest\n        mapping(uint8 => uint256) lockReward;\n        mapping(uint8 => uint256) lockRewardReleased;\n        uint256 lastStakeTime;\n    }\n\n    // Info of each rewardPool funding.\n    struct RewardPoolInfo {\n        address rewardToken; // Address of rewardPool token contract.\n        address rewardRebaser; // Address of rewardRebaser contract.\n        address rewardMultiplier; // Address of rewardMultiplier contract.\n        uint256 startRewardTime; // Start reward block number that rewardPool distribution occurs.\n        uint256 lastRewardTime; // Last block number that rewardPool distribution occurs.\n        uint256 endRewardTime; // Block time which rewardPool distribution ends.\n        uint256 rewardPerSecond; // Reward token amount to distribute per block.\n        uint256 accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n        uint256 lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n        uint256 startVestingTime; // Block time which vesting starts.\n        uint256 endVestingTime; // Block time which vesting ends.\n        uint256 vestingDuration;\n        uint256 totalPaidRewards;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n    RewardPoolInfo[] public rewardPoolInfo;\n    address public override stakeToken;\n    address public rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 public unstakingFrozenTime = 3 days;\n    uint256 private unlocked = 1;\n    bool private _initialized = false;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n    }\n\n    modifier lock() {\n        require(unlocked == 1, \"SP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SP: !timelock\");\n        _;\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\n            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n            if (rewardPool.rewardToken == _token) {\n                // do not allow to drain reward token if less than 3 days after pool ends\n                if (block.timestamp < (rewardPool.endRewardTime + (3 days))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        uint256 _unstakingFrozenTime,\n        address _rewardFund,\n        address _timelock\n    ) external override {\n        require(_initialized == false, \"SP: Initialize must be false.\");\n        require(unstakingFrozenTime <= 30 days, \"SP: unstakingFrozenTime > 30 days\");\n        stakeToken = _stakeToken;\n        unstakingFrozenTime = _unstakingFrozenTime;\n        rewardFund = _rewardFund;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external override lock onlyTimeLock {\n        require(rewardPoolInfo.length <= 16, \"SP: Reward pool length > 16\");\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        require(_startVestingTime <= _endVestingTime, \"SP: startVestingTime > endVestingTime\");\n        _startTime = (block.timestamp > _startTime) ? block.timestamp : _startTime;\n        require(_startTime < _endRewardTime, \"SP: startTime >= endRewardTime\");\n        require(_lockRewardPercent <= 100, \"SP: invalid lockRewardPercent\");\n        updateReward();\n        rewardPoolInfo.push(\n            RewardPoolInfo({\n                rewardToken: _rewardToken,\n                rewardRebaser: _rewardRebaser,\n                startRewardTime: _startTime,\n                rewardMultiplier: _rewardMultiplier,\n                lastRewardTime: _startTime,\n                endRewardTime: _endRewardTime,\n                rewardPerSecond: _rewardPerSecond,\n                accRewardPerShare: 0,\n                lockRewardPercent: _lockRewardPercent,\n                startVestingTime: _startVestingTime,\n                endVestingTime: _endVestingTime,\n                vestingDuration: _endVestingTime - _startVestingTime,\n                totalPaidRewards: 0\n            })\n        );\n        emit AddRewardPool(rewardPoolInfo.length - 1);\n    }\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardMultiplier = _rewardMultiplier;\n        updateReward(_pid);\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n    }\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardRebaser = _rewardRebaser;\n        updateReward(_pid);\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getRewardMultiplier(\n        uint8 _pid,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerSecond\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardMultiplier = rewardPool.rewardMultiplier;\n        if (rewardMultiplier == address(0)) {\n            return _to.sub(_from).mul(_rewardPerSecond);\n        }\n        return IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(rewardPool.startRewardTime, rewardPool.endRewardTime, _from, _to, _rewardPerSecond);\n    }\n\n    function getRewardRebase(\n        uint8 _pid,\n        address _rewardToken,\n        uint256 _pendingReward\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardRebaser = rewardPool.rewardRebaser;\n        if (rewardRebaser == address(0)) {\n            return _pendingReward;\n        }\n        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n    }\n\n    function getRewardPerSecond(\n        uint8 pid,\n        uint256 from,\n        uint256 to\n    ) public view returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n        uint256 rewardPerSecond = rewardPool.rewardPerSecond;\n        if (from < rewardPool.startRewardTime || from > rewardPool.endRewardTime) return 0;\n        uint256 reward = getRewardMultiplier(pid, from, to, rewardPerSecond);\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n    }\n\n    function getRewardPerSecond(uint8 pid) external view override returns (uint256) {\n        return getRewardPerSecond(pid, block.timestamp, block.timestamp + 1);\n    }\n\n    function updateRewardPool(\n        uint8 _pid,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond\n    ) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        require(block.timestamp <= rewardPool.endRewardTime && block.timestamp <= _endRewardTime, \"SP: blockTime > endRewardTime\");\n        updateReward(_pid);\n        rewardPool.endRewardTime = _endRewardTime;\n        rewardPool.rewardPerSecond = _rewardPerSecond;\n        emit UpdateRewardPool(_pid, _endRewardTime, _rewardPerSecond);\n    }\n\n    function stopRewardPool(uint8 _pid) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        updateReward(_pid);\n        rewardPool.endRewardTime = block.timestamp;\n        rewardPool.rewardPerSecond = 0;\n        emit UpdateRewardPool(_pid, rewardPool.endRewardTime, rewardPool.rewardPerSecond);\n    }\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SP: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SP: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        getAllRewards(_account);\n        user.amount = user.amount.add(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n        user.lastStakeTime = block.timestamp;\n        emit Deposit(_account, _amount);\n    }\n\n    function rewardPoolInfoLength() public view override returns (uint256) {\n        return rewardPoolInfo.length;\n    }\n\n    function unfrozenStakeTime(address _account) public view override returns (uint256) {\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"SP: invalid withdraw amount\");\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"SP: frozen\");\n        getAllRewards(msg.sender);\n        balance = balance.sub(_amount);\n        user.amount = user.amount.sub(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function getAllRewards(address _account) public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            getReward(_pid, _account);\n        }\n    }\n\n    function claimReward() external override {\n        getAllRewards(msg.sender);\n    }\n\n    function getReward(uint8 _pid, address _account) public override {\n        updateReward(_pid);\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n        uint256 _lockRewardPercent = rewardPool.lockRewardPercent;\n        if (_lockRewardPercent > 0) {\n            if (block.timestamp > rewardPool.endVestingTime) {\n                uint256 _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n                if (_unlockReward > 0) {\n                    _pendingReward = _pendingReward.add(_unlockReward);\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n                }\n            } else {\n                if (_pendingReward > 0) {\n                    uint256 _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n                    _pendingReward = _pendingReward.sub(_toLocked);\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n                }\n                uint256 _startVestingTime = rewardPool.startVestingTime;\n                if (block.timestamp > _startVestingTime) {\n                    uint256 _toReleased = user.lockReward[_pid].mul(block.timestamp.sub(_startVestingTime)).div(rewardPool.vestingDuration);\n                    uint256 _lockRewardReleased = user.lockRewardReleased[_pid];\n                    if (_toReleased > _lockRewardReleased) {\n                        uint256 _unlockReward = _toReleased.sub(_lockRewardReleased);\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n                        _pendingReward = _pendingReward.add(_unlockReward);\n                    }\n                }\n            }\n        }\n        if (_pendingReward > 0) {\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\n            uint256 reward = user.reward[_pid].add(_pendingReward);\n            user.reward[_pid] = reward;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            address rewardToken = rewardPool.rewardToken;\n            uint256 rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            if (rewardBalance > 0) {\n                user.reward[_pid] = 0;\n                uint256 rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\n                uint256 paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\n                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\n            }\n        }\n    }\n\n    function pendingReward(uint8 _pid, address _account) external view override returns (uint256) {\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime && lpSupply != 0) {\n            uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n        }\n        uint256 pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(unstakingFrozenTime == 0 || IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SP: Not allow emergencyWithdraw\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = 0;\n            user.reward[_pid] = 0;\n        }\n    }\n\n    function getUserInfo(uint8 _pid, address _account)\n        public\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 accumulatedEarned,\n            uint256 lockReward,\n            uint256 lockRewardReleased\n        )\n    {\n        UserInfo storage user = userInfo[_account];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt[_pid];\n        accumulatedEarned = user.accumulatedEarned[_pid];\n        lockReward = user.lockReward[_pid];\n        lockRewardReleased = user.lockRewardReleased[_pid];\n    }\n\n    function updateReward() public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            updateReward(_pid);\n        }\n    }\n\n    function updateReward(uint8 _pid) public override {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime) {\n            uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n            }\n            rewardPool.lastRewardTime = _endRewardTimeApplicable;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePool {\n    event Deposit(address indexed account, uint256 amount);\n    event AddRewardPool(uint256 indexed poolId);\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardTime, uint256 rewardPerSecond);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n    event Withdraw(address indexed account, uint256 amount);\n    function version() external view returns (uint);\n    function stakeToken() external view returns (address);\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external;\n\n    function stake(uint) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint) external;\n\n    function getReward(uint8 _pid, address _account) external;\n\n    function getAllRewards(address _account) external;\n    function claimReward() external;\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n    function getRewardPerSecond(uint8 pid) external view returns (uint);\n    function rewardPoolInfoLength() external view returns (uint);\n\n    function unfrozenStakeTime(address _account) external view returns (uint);\n\n    function emergencyWithdraw() external;\n\n    function updateReward() external;\n\n    function updateReward(uint8 _pid) external;\n\n    function updateRewardPool(uint8 _pid, uint256 _endRewardTime, uint256 _rewardPerSecond) external;\n    function stopRewardPool(uint8 _pid) external;\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) external view returns (uint);\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n\n    function getUserInfo(uint8 _pid, address _account) external view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased);\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external;\n}\n"
    },
    "contracts/StakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\n\ncontract StakePoolRewardFund is IStakePoolRewardFund {\n    address public stakePool;\n    address public timelock;\n    bool private _initialized;\n\n    function initialize(address _stakePool, address _timelock) external override {\n        require(_initialized == false, \"StakePoolRewardFund: already initialized\");\n        stakePool = _stakePool;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) external override {\n        require(msg.sender == stakePool, \"StakePoolRewardFund: !stakePool\");\n        TransferHelper.safeTransfer(_token, _to, _value);\n    }\n\n    function allowRecoverRewardToken(address _token) public view returns (bool){\n        return IStakePool(stakePool).allowRecoverRewardToken(_token);\n    }\n\n    function recoverAllRewardToken(\n        address _token,\n        address _to\n    ) external {\n        recoverRewardToken(_token, _to, IERC20(address(_token)).balanceOf(address(this)));\n    }\n\n    function recoverRewardToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) public {\n        require(msg.sender == timelock, \"StakePoolRewardFund: !timelock\");\n        require(allowRecoverRewardToken(_token), \"StakePoolRewardFund: not allow recover reward token\");\n        TransferHelper.safeTransfer(_token, _to, _amount);\n    }\n}\n"
    },
    "contracts/test/SimpleEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/stakePool/IStakePoolEpochReward.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract SimpleEpochController is IEpochController {\n    uint256 public _epoch = 0;\n    uint256 public epochLength = 5 minutes;\n    uint256 public lastEpochTime;\n    address public allocator;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        allocator = msg.sender;\n    }\n\n    function epoch() external view override returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external view override returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        owner = _owner;\n    }\n\n    function setAllocator(address _allocator) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        allocator = _allocator;\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return epochLength;\n    }\n\n    function allocateReward(address pool) external {\n        require(msg.sender == allocator, \"SimpleEpochController: FORBIDDEN\");\n        uint256 _amount = nextEpochAllocatedReward(pool);\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        TransferHelper.safeApprove(rewardToken, pool, _amount);\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IStakePoolEpochReward(pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address pool) public view override returns (uint256) {\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/test/EpochControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/stakePool/IStakePoolEpochReward.sol\";\n\ncontract EpochControllerMock is IEpochController {\n    uint256 private _epoch = 0;\n    address public rewardToken;\n    uint256 public lastEpochTime;\n\n    constructor(address _rewardToken) {\n        rewardToken = _rewardToken;\n    }\n\n    function epoch() external view override returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external view override returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return 12 hours;\n    }\n\n    function resetEpochTime() external {\n        lastEpochTime = block.timestamp;\n    }\n\n    function updateEpochTime(uint256 _lastEpochTime) external {\n        lastEpochTime = _lastEpochTime;\n    }\n\n    function allocateSeigniorage(uint256 _amount, address _pool) external {\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(rewardToken).approve(_pool, 0);\n        IERC20(rewardToken).approve(_pool, _amount);\n        IStakePoolEpochReward(_pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address _pool) external view override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/test/vault/MockInternalBalanceRelayer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/ERC20/IERC20.sol\";\nimport \"../../libraries/helpers/InputHelpers.sol\";\n\nimport \"../../interfaces/IVault.sol\";\n\ncontract MockInternalBalanceRelayer {\n    IVault public vault;\n\n    constructor(IVault _vault) {\n        vault = _vault;\n    }\n\n    function depositAndWithdraw(\n        address payable sender,\n        IAsset asset,\n        uint256[] memory depositAmounts,\n        uint256[] memory withdrawAmounts\n    ) public {\n        InputHelpers.ensureInputLengthMatch(depositAmounts.length, withdrawAmounts.length);\n        for (uint256 i = 0; i < depositAmounts.length; i++) {\n            IVault.UserBalanceOp[] memory deposit = _buildUserBalanceOp(\n                IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,\n                sender,\n                asset,\n                depositAmounts[i]\n            );\n            vault.manageUserBalance(deposit);\n\n            IVault.UserBalanceOp[] memory withdraw = _buildUserBalanceOp(\n                IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,\n                sender,\n                asset,\n                withdrawAmounts[i]\n            );\n            vault.manageUserBalance(withdraw);\n        }\n    }\n\n    function _buildUserBalanceOp(\n        IVault.UserBalanceOpKind kind,\n        address payable sender,\n        IAsset asset,\n        uint256 amount\n    ) internal pure returns (IVault.UserBalanceOp[] memory ops) {\n        ops = new IVault.UserBalanceOp[](1);\n        ops[0] = IVault.UserBalanceOp({ asset: asset, amount: amount, sender: sender, recipient: sender, kind: kind });\n    }\n}\n"
    },
    "contracts/Authorizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IAuthorizer.sol\";\nimport \"./libraries/AccessControl.sol\";\nimport \"./libraries/helpers/InputHelpers.sol\";\n\n/**\n * @dev Basic Authorizer implementation, based on OpenZeppelin's Access Control.\n *\n * Users are allowed to perform actions if they have the role with the same identifier. In this sense, roles are not\n * being truly used as such, since they each map to a single action identifier.\n *\n * This temporary implementation is expected to be replaced soon after launch by a more sophisticated one, able to\n * manage permissions across multiple contracts and to natively handle timelocks.\n */\ncontract Authorizer is AccessControl, IAuthorizer {\n    constructor(address admin) {\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address\n    ) public view override returns (bool) {\n        // This Authorizer ignores the 'where' field completely.\n        return AccessControl.hasRole(actionId, account);\n    }\n\n    /**\n     * @dev Grants multiple roles to a single account.\n     */\n    function grantRoles(bytes32[] memory roles, address account) external {\n        for (uint256 i = 0; i < roles.length; i++) {\n            grantRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Grants roles to a list of accounts.\n     */\n    function grantRolesToMany(bytes32[] memory roles, address[] memory accounts) external {\n        InputHelpers.ensureInputLengthMatch(roles.length, accounts.length);\n        for (uint256 i = 0; i < roles.length; i++) {\n            grantRole(roles[i], accounts[i]);\n        }\n    }\n\n    /**\n     * @dev Revokes multiple roles from a single account.\n     */\n    function revokeRoles(bytes32[] memory roles, address account) external {\n        for (uint256 i = 0; i < roles.length; i++) {\n            revokeRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Revokes roles from a list of accounts.\n     */\n    function revokeRolesFromMany(bytes32[] memory roles, address[] memory accounts) external {\n        InputHelpers.ensureInputLengthMatch(roles.length, accounts.length);\n        for (uint256 i = 0; i < roles.length; i++) {\n            revokeRole(roles[i], accounts[i]);\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/ERC20.sol\";\n\n/**\n * @dev THIS CONTRACT IS FOR TESTING PURPOSES ONLY.\n */\ncontract MockERC20 is ERC20 {\n    uint8 internal decimals_;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        super._mint(msg.sender, 1e27);\n        decimals_ = _decimals;\n    }\n\n    function mint(address _receiver, uint256 _amount) external {\n        _mint(_receiver, _amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return decimals_;\n    }\n}\n"
    },
    "contracts/libraries/helpers/SignaturesValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"../../interfaces/ISignaturesValidator.sol\";\nimport \"../EIP712.sol\";\n\n/**\n * @dev Utility for signing Solidity function calls.\n *\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\n *\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\n */\nabstract contract SignaturesValidator is ISignaturesValidator, EIP712 {\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\n    // for each of these values, even if 'v' is typically an 8 bit value.\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\n\n    // Replay attack prevention for each user.\n    mapping(address => uint256) internal _nextNonce;\n\n    constructor(string memory name) EIP712(name, \"1\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function getDomainSeparator() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getNextNonce(address user) external view override returns (uint256) {\n        return _nextNonce[user];\n    }\n\n    /**\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\n     */\n    function _validateSignature(address user, uint256 errorCode) internal {\n        uint256 nextNonce = _nextNonce[user]++;\n        _require(_isSignatureValid(user, nextNonce), errorCode);\n    }\n\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\n        uint256 deadline = _deadline();\n\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (deadline < block.timestamp) {\n            return false;\n        }\n\n        bytes32 typeHash = _typeHash();\n        if (typeHash == bytes32(0)) {\n            // Prevent accidental signature validation for functions that don't have an associated type hash.\n            return false;\n        }\n\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\n        return recoveredAddress != address(0) && recoveredAddress == user;\n    }\n\n    /**\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\n     * selector (available as `msg.sig`).\n     *\n     * The type hash must conform to the following format:\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\n     *\n     * If 0x00, all signatures will be considered invalid.\n     */\n    function _typeHash() internal view virtual returns (bytes32);\n\n    /**\n     * @dev Extracts the signature deadline from extra calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _deadline() internal pure returns (uint256) {\n        // The deadline is the first extra argument at the end of the original calldata.\n        return uint256(_decodeExtraCalldataWord(0));\n    }\n\n    /**\n     * @dev Extracts the signature parameters from extra calldata.\n     *\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\n     * be considered a valid signature in the first place.\n     */\n    function _signature()\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // v, r and s are appended after the signature deadline, in that order.\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\n        r = _decodeExtraCalldataWord(0x40);\n        s = _decodeExtraCalldataWord(0x60);\n    }\n\n    /**\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _calldata() internal pure returns (bytes memory result) {\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We simply overwrite the array length with the reduced one.\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\n            }\n        }\n    }\n\n    /**\n     * @dev Returns a 256 bit word from 'extra' calldata, at some offset from the expected end of the original calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\n        }\n    }\n}\n"
    },
    "contracts/test/vault/BalanceAllocationMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../libraries/balances/BalanceAllocation.sol\";\n\ncontract BalanceAllocationMock {\n    using BalanceAllocation for bytes32;\n\n    function total(bytes32 balance) public pure returns (uint256) {\n        return balance.total();\n    }\n\n    function totals(bytes32[] memory balances) public pure returns (uint256[] memory result) {\n        (result, ) = BalanceAllocation.totalsAndLastChangeBlock(balances);\n    }\n\n    function cash(bytes32 balance) public pure returns (uint256) {\n        return balance.cash();\n    }\n\n    function managed(bytes32 balance) public pure returns (uint256) {\n        return balance.managed();\n    }\n\n    function lastChangeBlock(bytes32 balance) public pure returns (uint256) {\n        return balance.lastChangeBlock();\n    }\n\n    function isNotZero(bytes32 balance) public pure returns (bool) {\n        return balance.isNotZero();\n    }\n\n    function isZero(bytes32 balance) public pure returns (bool) {\n        return balance.isZero();\n    }\n\n    function toBalance(\n        uint256 _cash,\n        uint256 _managed,\n        uint256 _lastChangeBlock\n    ) public pure returns (bytes32) {\n        return BalanceAllocation.toBalance(_cash, _managed, _lastChangeBlock);\n    }\n\n    function increaseCash(bytes32 balance, uint256 amount) public view returns (bytes32) {\n        return balance.increaseCash(amount);\n    }\n\n    function decreaseCash(bytes32 balance, uint256 amount) public view returns (bytes32) {\n        return balance.decreaseCash(amount);\n    }\n\n    function cashToManaged(bytes32 balance, uint256 amount) public pure returns (bytes32) {\n        return balance.cashToManaged(amount);\n    }\n\n    function managedToCash(bytes32 balance, uint256 amount) public pure returns (bytes32) {\n        return balance.managedToCash(amount);\n    }\n\n    function setManaged(bytes32 balance, uint256 newManaged) public view returns (bytes32) {\n        return balance.setManaged(newManaged);\n    }\n\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) public pure returns (bytes32) {\n        return BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\n    }\n\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) public pure returns (bytes32) {\n        return BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\n    }\n\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) public pure returns (bytes32) {\n        return BalanceAllocation.toSharedCash(tokenABalance, tokenBBalance);\n    }\n\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) public pure returns (bytes32) {\n        return BalanceAllocation.toSharedManaged(tokenABalance, tokenBBalance);\n    }\n}\n"
    },
    "contracts/StakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/IIsPair.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./StakePoolRewardFund.sol\";\n\ncontract StakePoolController is IStakePoolController {\n    IIsPair public swapFactory;\n    address public governance;\n\n    address public feeCollector;\n    address public feeToken;\n    uint public  feeAmount;\n\n    mapping(address => bool) private _stakePools;\n    mapping(address => bool) private _whitelistStakingFor;\n    mapping(address => bool) private _whitelistRewardRebaser;\n    mapping(address => bool) private _whitelistRewardMultiplier;\n    mapping(address => int8) private _whitelistStakePools;\n    mapping(address => bool) public _stakePoolVerifiers;\n    mapping(uint => address) public stakePoolCreators;\n    address[] public override allStakePools;\n    bool public enableWhitelistRewardRebaser = true;\n    bool public enableWhitelistRewardMultiplier = true;\n    bool private _initialized = false;\n\n    mapping(address => bool) public allowEmergencyWithdrawStakePools;\n\n    uint public extraFeeRate;\n\n    function initialize(address _swapFactory) public {\n        require(_initialized == false, \"SPC: initialized\");\n        governance = msg.sender;\n        swapFactory = IIsPair(_swapFactory);\n        _initialized = true;\n    }\n\n    function isStakePool(address b) external override view returns (bool){\n        return _stakePools[b];\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"SPC: !governance\");\n        _;\n    }\n\n    function setFeeCollector(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        feeCollector = _address;\n        emit SetFeeCollector(_address);\n    }\n    function setEnableWhitelistRewardRebaser(bool value) external onlyGovernance override {\n        enableWhitelistRewardRebaser = value;\n    }\n    function setEnableWhitelistRewardMultiplier(bool value) external onlyGovernance override {\n        enableWhitelistRewardMultiplier = value;\n    }\n    function setFeeToken(address _token) external onlyGovernance override {\n        require(_token != address(0), \"SPC: invalid _token\");\n        feeToken = _token;\n        emit SetFeeToken(_token);\n    }\n    function getCreationFee(address token) public view returns (uint) {\n        if (swapFactory.isPair(token)) {\n            return feeAmount;\n        }\n        return feeAmount * extraFeeRate / 1000;\n    }\n    function setFeeAmount(uint _feeAmount) external onlyGovernance override {\n        feeAmount = _feeAmount;\n        emit SetFeeAmount(_feeAmount);\n    }\n    function setExtraFeeRate(uint _extraFeeRate) external onlyGovernance override {\n        require(_extraFeeRate >= 1000 && _extraFeeRate <= 50000, \"SPC: invalid _extraFeeRate\");\n        extraFeeRate = _extraFeeRate;\n        emit SetExtraFeeRate(_extraFeeRate);\n    }\n    function isWhitelistStakingFor(address _address) external override view returns (bool){\n        return _whitelistStakingFor[_address];\n    }\n\n    function isWhitelistStakePool(address _address) external override view returns (int8){\n        return _whitelistStakePools[_address];\n    }\n    function isStakePoolVerifier(address _address) external override view returns (bool){\n        return _stakePoolVerifiers[_address];\n    }\n    function isAllowEmergencyWithdrawStakePool(address _address) external override view returns (bool){\n        return allowEmergencyWithdrawStakePools[_address];\n    }\n    function setWhitelistStakingFor(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistStakingFor[_address] = state;\n        emit SetWhitelistStakingFor(_address, state);\n    }\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        allowEmergencyWithdrawStakePools[_address] = state;\n    }\n\n    function setStakePoolVerifier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _stakePoolVerifiers[_address] = state;\n        emit SetStakePoolVerifier(_address, state);\n    }\n\n    function setWhitelistStakePool(address _address, int8 state) external override {\n        require(_address != address(0), \"SPC: invalid address\");\n        require(_stakePoolVerifiers[msg.sender] == true, \"SPC: invalid stake pool verifier\");\n        _whitelistStakePools[_address] = state;\n        emit SetWhitelistStakePool(_address, state);\n    }\n\n    function addStakePoolCreator(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        uint version = IStakePoolCreator(_address).version();\n        require(version >= 1000, \"Invalid stake pool creator version\");\n        stakePoolCreators[version] = _address;\n        emit SetStakePoolCreator(_address, version);\n    }\n\n    function isWhitelistRewardRebaser(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardRebaser) return true;\n        return _address == address(0) ? true : _whitelistRewardRebaser[_address];\n    }\n\n    function setWhitelistRewardRebaser(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardRebaser[_address] = state;\n        emit SetWhitelistRewardRebaser(_address, state);\n    }\n\n    function isWhitelistRewardMultiplier(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardMultiplier) return true;\n        return _address == address(0) ? true : _whitelistRewardMultiplier[_address];\n    }\n\n    function setWhitelistRewardMultiplier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardMultiplier[_address] = state;\n        emit SetWhitelistRewardMultiplier(_address, state);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance override {\n        require(_governance != address(0), \"SPC: invalid governance\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function allStakePoolsLength() external override view returns (uint) {\n        return allStakePools.length;\n    }\n    function createInternal(address stakePoolCreator, address stakeToken, address stakePoolRewardFund, address rewardToken, uint delayTimeLock, bytes calldata data) internal returns (address) {\n        TimeLock timelock = new TimeLock();\n        IStakePool pool = IStakePool(IStakePoolCreator(stakePoolCreator).create());\n        allStakePools.push(address(pool));\n        _stakePools[address(pool)] = true;\n        emit MasterCreated(address(pool), stakeToken, pool.version(), address(timelock), stakePoolRewardFund, allStakePools.length);\n        IStakePoolCreator(stakePoolCreator).initialize(address(pool), stakeToken, rewardToken, address(timelock), address(stakePoolRewardFund), data);\n        StakePoolRewardFund(stakePoolRewardFund).initialize(address(pool), address(timelock));\n        timelock.initialize(msg.sender, delayTimeLock);\n        return address(pool);\n    }\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) public override returns (address) {\n        address stakePoolCreator = stakePoolCreators[version];\n        require(stakePoolCreator != address(0), \"SPC: Invalid stake pool creator version\");\n        uint creationFee = getCreationFee(stakeToken);\n        if (feeCollector != address(0) && feeToken != address(0) && creationFee > 0) {\n            TransferHelper.safeTransferFrom(feeToken, msg.sender, feeCollector, creationFee);\n        }\n\n        StakePoolRewardFund stakePoolRewardFund = new StakePoolRewardFund();\n        if (rewardFundAmount > 0) {\n            require(IERC20(rewardToken).balanceOf(msg.sender) >= rewardFundAmount , \"SPC: Not enough rewardFundAmount\");\n            TransferHelper.safeTransferFrom(rewardToken, msg.sender, address(stakePoolRewardFund), rewardFundAmount);\n        }\n        return createInternal(stakePoolCreator, stakeToken, address(stakePoolRewardFund), rewardToken, delayTimeLock, data);\n    }\n}\n"
    },
    "contracts/interfaces/IIsPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IIsPair {\n    function isPair(address) external view returns (bool);\n}\n"
    },
    "contracts/test/FireBirdFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IIsPair.sol\";\n\ncontract RequiemMock is IIsPair {\n    mapping(address => bool) public override isPair;\n\n    function setIsPair(address pair, bool val) external {\n        isPair[pair] = val;\n    }\n}\n"
    },
    "contracts/RequiemParaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9;\npragma abicoder v2;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemRouter.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract RequiemRouter is IRequiemRouter {\n    using SafeMath for uint256;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IRequiemRouter.sol\";\n\ncontract RouterEventEmitter {\n    event Amounts(uint[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForTokens.selector, tokenIn, tokenOut, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactTokens.selector, tokenIn, tokenOut, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactETHForTokens.selector, tokenOut, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        address tokenIn,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactETH.selector, tokenIn, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForETH.selector, tokenIn, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapETHForExactTokens.selector, tokenOut, amountOut, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n}\n"
    },
    "contracts/RequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract RequiemFormula is IRequiemFormula {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE = 1;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\n\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n    uint256[128] private maxExpArray;\n\n    function initMaxExpArray() internal {\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    constructor() {\n        initMaxExpArray();\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count;\n            // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1;\n                // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1;\n                    // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n        // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\n        // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n        // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\n        // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000;\n        // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\n        // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n        // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000;\n        // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\n        // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n        // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\n        // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000;\n        // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000;\n        // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000;\n        // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000;\n        // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000;\n        // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000;\n        // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000;\n        // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000;\n        // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000;\n        // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000;\n        // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000;\n        // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00;\n        // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00;\n        // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900;\n        // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00;\n        // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340;\n        // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40;\n        // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0;\n        // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420;\n        // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021;\n        // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001;\n        // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n     * Auto-generated via \"PrintFunctionOptimalLog.py\"\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        }\n        // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        }\n        // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        }\n        // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        }\n        // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        }\n        // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        }\n        // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        }\n        // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        }\n        // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^01 / 01 - y^02 / 02\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^03 / 03 - y^04 / 04\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^05 / 05 - y^06 / 06\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^07 / 07 - y^08 / 08\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^09 / 09 - y^10 / 10\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^11 / 11 - y^12 / 12\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^13 / 13 - y^14 / 14\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via \"PrintFunctionOptimalExp.py\"\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000;\n        // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000;\n        // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000;\n        // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000;\n        // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000;\n        // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000;\n        // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800;\n        // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800;\n        // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00;\n        // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400;\n        // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300;\n        // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00;\n        // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480;\n        // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380;\n        // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638;\n        // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8;\n        // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c;\n        // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014;\n        // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001;\n        // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea;\n        // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n        // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function getReserveAndWeights(address pair, address tokenA)\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    function getFactoryReserveAndWeights(\n        address factory,\n        address pair,\n        address tokenA\n    )\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(factory, pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    /**\n     * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n     *\n     * Formula:\n     * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n     *\n     * @param amountIn                  source reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountOut\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountOut) {\n        // validate input\n        require(amountIn > 0, \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(10000 - swapFee);\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            return reserveOut.mul(amountInWithFee) / (reserveIn.mul(10000).add(amountInWithFee));\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = reserveIn.mul(10000).add(amountInWithFee);\n        (result, precision) = power(baseN, reserveIn.mul(10000), tokenWeightIn, tokenWeightOut);\n\n        uint256 temp1 = reserveOut.mul(result);\n        uint256 temp2 = reserveOut << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     *\n     * Formula:\n     * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n     *\n     * @param amountOut     target reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountIn\n     */\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountIn) {\n        // validate input\n        require(amountOut > 0, \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            uint256 numerator = reserveIn.mul(amountOut).mul(10000);\n            uint256 denominator = reserveOut.sub(amountOut).mul(10000 - swapFee);\n            return (numerator / denominator).add(1);\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = reserveOut.sub(amountOut);\n        (result, precision) = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n        uint256 baseReserveIn = reserveIn.mul(10000);\n        uint256 temp1 = baseReserveIn.mul(result);\n        uint256 temp2 = baseReserveIn << precision;\n        return (((temp1 - temp2) >> precision) / (10000 - swapFee)).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i],\n                currentTokenIn\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getPairAmountOut(\n        address pair,\n        address tokenIn,\n        uint256 amountIn\n    ) external view override returns (uint256 amountOut) {\n        (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountOut = getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i - 1],\n                currentTokenIn\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getPairAmountIn(\n        address pair,\n        address tokenIn,\n        uint256 amountOut\n    ) external view override returns (uint256 amountIn) {\n        (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountIn = getAmountIn(amountOut, reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        try IRequiemPair(pair).getTokenWeights() returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n            return (_tokenWeight0, _tokenWeight1, IRequiemPair(pair).getSwapFee());\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (\n            bytes memory /*lowLevelData*/\n        ) {\n            return (50, 50, 30);\n        }\n    }\n\n    function getFactoryWeightsAndSwapFee(address factory, address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        return IRequiemFactory(factory).getWeightsAndSwapFee(pair);\n    }\n\n    // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n    //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n    //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n    function ensureConstantValue(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 balance0Adjusted,\n        uint256 balance1Adjusted,\n        uint32 tokenWeight0\n    ) external view override returns (bool) {\n        if (tokenWeight0 == 50) {\n            return balance0Adjusted.mul(balance1Adjusted) >= reserve0.mul(reserve1);\n        }\n        if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n            return true;\n        }\n        if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n            return false;\n        }\n        uint32 w0 = tokenWeight0;\n        uint32 w1 = 100 - w0;\n\n        uint256 r0;\n        uint256 p0;\n        uint256 r1;\n        uint256 p1;\n        if (balance0Adjusted >= reserve0) {\n            (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n            (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n        } else {\n            (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n            (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n        }\n        uint256 minP = p0 < p1 ? p0 : p1;\n        p0 = p0 - minP;\n        p1 = p1 - minP;\n        return (r0 >> p0) <= (r1 >> p1);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\n        require(tokenA != tokenB, \"RequiemFormula: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"RequiemFormula: ZERO_ADDRESS\");\n    }\n\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        require(token0 == IRequiemPair(pair).token0() && token1 == IRequiemPair(pair).token1(), \"RequiemFormula: Invalid token\");\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function getOtherToken(address pair, address tokenA) external view override returns (address tokenB) {\n        address token0 = IRequiemPair(pair).token0();\n        address token1 = IRequiemPair(pair).token1();\n        require(token0 == tokenA || token1 == tokenA, \"RequiemFormula: Invalid tokenA\");\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure override returns (uint256 amountB) {\n        require(amountA > 0, \"RequiemFormula: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    function mintLiquidityFee(\n        uint256 totalLiquidity,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112 collectedFee0,\n        uint112 collectedFee1\n    ) external view override returns (uint256 amount) {\n        if (collectedFee0 > 0) {\n            (uint256 r0, uint256 p0) = power(uint256(collectedFee0).add(reserve0), reserve0, tokenWeight0, 100);\n            amount = amount.add(totalLiquidity.mul(r0) >> p0).sub(totalLiquidity);\n        }\n        if (collectedFee1 > 0) {\n            (uint256 r1, uint256 p1) = power(uint256(collectedFee1).add(reserve1), reserve1, tokenWeight1, 100);\n            amount = amount.add(totalLiquidity.mul(r1) >> p1).sub(totalLiquidity);\n        }\n    }\n}\n"
    },
    "contracts/RequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./RequiemERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IUniswapV2Callee.sol\";\n\ncontract RequiemPair is IRequiemPair, RequiemERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    \n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint private unlocked = 1;\n    address public formula;\n\n    uint112 private collectedFee0;           // uses single storage slot, accessible via getReserves\n    uint112 private collectedFee1;           // uses single storage slot, accessible via getReserves\n    uint32 private tokenWeight0;\n\n    uint32 private swapFee;\n\n    modifier lock() {\n        require(unlocked == 1, \"REQLP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function getCollectedFees() public view returns (uint112 _collectedFee0, uint112 _collectedFee1) {\n        _collectedFee0 = collectedFee0;\n        _collectedFee1 = collectedFee1;\n    }\n\n    function getTokenWeights() public view returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n        _tokenWeight0 = tokenWeight0;\n        _tokenWeight1 = 100 - tokenWeight0;\n    }\n\n    function getSwapFee() public view returns (uint32 _swapFee) {\n        _swapFee = swapFee;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"REQLP: TRANSFER_FAILED\");\n    }\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1, uint32 _tokenWeight0, uint32 _swapFee) external {\n        require(msg.sender == factory, \"REQLP: FORBIDDEN\");\n        // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        tokenWeight0 = _tokenWeight0;\n        swapFee = _swapFee;\n        formula = IRequiemFactory(factory).formula();\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 _tokenWeight0 = tokenWeight0;\n        require(balance0 * (100 - _tokenWeight0) <= type(uint112).max && balance1 * _tokenWeight0 <= type(uint112).max, \"REQLP: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            uint112 mReserve0 = _reserve0 * (100 - _tokenWeight0);\n            uint112 mReserve1 = _reserve1 * _tokenWeight0;\n            price0CumulativeLast += uint(UQ112x112.encode(mReserve1).uqdiv(mReserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(mReserve0).uqdiv(mReserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IRequiemFactory(factory).feeTo();\n        uint112 protocolFee = uint112(IRequiemFactory(factory).protocolFee());\n        feeOn = feeTo != address(0);\n        (uint112 _collectedFee0, uint112 _collectedFee1) = getCollectedFees();\n        if (protocolFee > 0 && feeOn && (_collectedFee0 > 0 || _collectedFee1 > 0)) {\n            uint32 _tokenWeight0 = tokenWeight0;\n            uint liquidity = IRequiemFormula(formula).mintLiquidityFee(\n                totalSupply, _reserve0, _reserve1,\n                _tokenWeight0, 100 - _tokenWeight0,\n                _collectedFee0 / protocolFee, _collectedFee1 / protocolFee\n            );\n            if (liquidity > 0) _mint(feeTo, liquidity);\n        }\n        if (_collectedFee0 > 0) collectedFee0 = 0;\n        if (_collectedFee1 > 0) collectedFee1 = 0;\n    }\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply;\n        // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply;// using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply;// using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, \"REQLP: INSUFFICIENT_OUTPUT_AMOUNT\");\n        uint112 _reserve0 = reserve0; // gas savings\n        uint112 _reserve1 = reserve1; // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: INSUFFICIENT_LIQUIDITY\");\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, \"REQLP: INVALID_TO\");\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"REQLP: INSUFFICIENT_INPUT_AMOUNT\");\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(10000);\n            uint balance1Adjusted = balance1.mul(10000);\n            { // avoids stack too deep errors\n                if (amount0In > 0) {\n                    uint amount0InFee = amount0In.mul(swapFee);\n                    balance0Adjusted = balance0Adjusted.sub(amount0InFee);\n                    collectedFee0 = uint112(uint(collectedFee0).add(amount0InFee));\n                }\n                if (amount1In > 0) {\n                    uint amount1InFee = amount1In.mul(swapFee);\n                    balance1Adjusted = balance1Adjusted.sub(amount1InFee);\n                    collectedFee1 = uint112(uint(collectedFee1).add(amount1InFee));\n                }\n                uint32 _tokenWeight0 = tokenWeight0;// gas savings\n                if (_tokenWeight0 == 50) { // gas savings for pair 50/50\n                    require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000**2), \"REQLP: K\");\n                } else {\n                    require(IRequiemFormula(formula).ensureConstantValue(uint(_reserve0).mul(10000), uint(_reserve1).mul(10000), balance0Adjusted, balance1Adjusted, _tokenWeight0), \"REQLP: K\");\n                }\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract RequiemERC20 is IRequiemERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Requiem Liquidity Provider\";\n    string public constant symbol = \"RLP\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    constructor() {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"RLP: EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"RLP: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/test/UniswapV2ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract RequiemERC20Wrapper is RequiemERC20 {\n    constructor(uint _totalSupply) public {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract TestERC20 is RequiemERC20 {\n    constructor(uint _totalSupply) public {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemWeightedPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\nimport \"./IRequiemSwapInterface.sol\";\n\ninterface IRequiemWeightedPair is IRequiemERC20, IRequiemSwapInterface {\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    // function getReserves()\n    //     external\n    //     view\n    //     returns (\n    //         uint112 reserve0,\n    //         uint112 reserve1,\n    //         uint32 blockTimestampLast\n    //     );\n\n    // function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwapInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\ninterface IRequiemSwapInterface {\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n\n\n    function tokens() external view returns (address[] memory);\n\n    function swapStruct(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        uint index0,\n        uint index1,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256[] memory reserves,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint256[] memory _collectedFees);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/RequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./RequiemPair.sol\";\n\ncontract RequiemFactory is IRequiemFactory {\n    address public feeTo;\n    address public formula;\n    uint256 public protocolFee;\n    address public feeToSetter;\n\n    mapping(bytes32 => address) private _pairSalts;\n    address[] public allPairs;\n    mapping(address => uint64) private _pairs;\n\n    constructor(address _feeToSetter, address _formula) {\n        feeToSetter = _feeToSetter;\n        formula = _formula;\n    }\n\n    function isPair(address b) external view returns (bool) {\n        return _pairs[b] > 0;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external view returns (address pair) {\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        pair = _pairSalts[salt];\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"RLP: IDENTICAL_ADDRESSES\");\n        require(tokenWeightA >= 2 && tokenWeightA <= 98 && (tokenWeightA % 2) == 0, \"RLP: INVALID_TOKEN_WEIGHT\");\n        // swap fee from [0.01% - 20%]\n        require(swapFee >= 1 && swapFee <= 2000, \"RLP: INVALID_SWAP_FEE\");\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        require(token0 != address(0), \"RLP: ZERO_ADDRESS\");\n        // single check is sufficient\n        bytes memory bytecode = type(RequiemPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        require(_pairSalts[salt] == address(0), \"RLP: PAIR_EXISTS\");\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IRequiemPair(pair).initialize(token0, token1, tokenWeight0, swapFee);\n        _pairSalts[salt] = address(pair);\n        allPairs.push(pair);\n        uint64 weightAndFee = uint64(swapFee);\n        weightAndFee |= uint64(tokenWeight0) << 32;\n        _pairs[address(pair)] = weightAndFee;\n        emit PairCreated(token0, token1, pair, tokenWeight0, swapFee, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n\n    function setProtocolFee(uint256 _protocolFee) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        require(_protocolFee == 0 || (_protocolFee >= 10000 && _protocolFee <= 100000), \"RLP: Invalid Protocol fee\");\n        protocolFee = _protocolFee;\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        uint64 weightAndFee = _pairs[pair];\n        if (weightAndFee > 0) {\n            swapFee = uint32(weightAndFee);\n            tokenWeight0 = uint32(weightAndFee >> 32);\n            tokenWeight1 = 100 - tokenWeight0;\n        } else {\n            // Default is 0.3%\n            return (50, 50, 30);\n        }\n    }\n}\n"
    },
    "contracts/ProtocolFeeRemover.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract ProtocolFeeRemover {\n    address public receiver;\n    address public governance;\n\n    event RemoveLiquidity(address indexed pair, uint256 token0, uint256 token1);\n    event ChangeGovernance(address changeValue);\n    event ChangeReceiver(address changeValue);\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    function setReceiver(address _receiver) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        receiver = _receiver;\n        emit ChangeReceiver(_receiver);\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function transfer(address _token, uint256 _value) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        TransferHelper.safeTransfer(_token, receiver, _value);\n    }\n\n    function transferAllTokens(address[] calldata _tokens) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC20(_tokens[i]).balanceOf(address(this));\n            TransferHelper.safeTransfer(_tokens[i], receiver, _balance);\n        }\n    }\n\n    function remove(address[] calldata pairs) external {\n        address _receiver = receiver;\n        // save gas\n        require(_receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IRequiemPair pair = IRequiemPair(pairs[i]);\n            uint256 liquidity = pair.balanceOf(address(this));\n            if (liquidity > 0) {\n                pair.transfer(address(pair), liquidity);\n                (uint256 amount0, uint256 amount1) = pair.burn(_receiver);\n                emit RemoveLiquidity(address(pair), amount0, amount1);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ISwapCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface ISwapCreator {\n\n    function create(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address timeLock\n    ) external returns (address);\n}"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface ISwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getTokenLength() external view returns (uint);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function swapStorage() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, address);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n}\n"
    },
    "contracts/interfaces/IStableSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IStableSwapFactory {\n    event SwapCreated(IERC20[] pooledTokens, address indexed swap, uint256 length);\n    event SetFeeTo(address indexed feeTo);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function allPools(uint256) external view returns (address pool);\n\n    function isPool(address) external view returns (bool);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function isTimelock(address) external view returns (bool);\n\n    function createPool(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        uint256 delayTimeLock\n    ) external returns (address pool);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n}\n"
    },
    "contracts/test/StakePoolRewardMultiplierMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardMultiplierMock is IStakePoolRewardMultiplier {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerBlock) external override view returns (uint) {\n        return _to.sub(_from).mul(_rewardPerBlock) .mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/test/DeflatingERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract DeflatingERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Deflating Test Token\";\n    string public constant symbol = \"DTT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _totalSupply) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        uint256 burnAmount = value / 100;\n        _burn(from, burnAmount);\n        uint256 transferAmount = value.sub(burnAmount);\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\n        balanceOf[to] = balanceOf[to].add(transferAmount);\n        emit Transfer(from, to, transferAmount);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/libraries/factories/BasePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IVault.sol\";\n\n/**\n * @dev Base contract for Pool factories.\n *\n * Pools are deployed from factories to allow third parties to reason about them. Unknown Pools may have arbitrary\n * logic: being able to assert that a Pool's behavior follows certain rules (those imposed by the contracts created by\n * the factory) is very powerful.\n */\nabstract contract BasePoolFactory {\n    IVault private immutable _vault;\n    mapping(address => bool) private _isPoolFromFactory;\n\n    event PoolCreated(address indexed pool);\n\n    constructor(IVault vault) {\n        _vault = vault;\n    }\n\n    /**\n     * @dev Returns the Vault's address.\n     */\n    function getVault() public view returns (IVault) {\n        return _vault;\n    }\n\n    /**\n     * @dev Returns true if `pool` was created by this factory.\n     */\n    function isPoolFromFactory(address pool) external view returns (bool) {\n        return _isPoolFromFactory[pool];\n    }\n\n    /**\n     * @dev Registers a new created pool.\n     *\n     * Emits a `PoolCreated` event.\n     */\n    function _register(address pool) internal {\n        _isPoolFromFactory[pool] = true;\n        emit PoolCreated(pool);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}