{
  "language": "Solidity",
  "sources": {
    "contracts/base/OwnerPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"../libraries/Ownable.sol\";\nimport \"../libraries/Pausable.sol\";\n\nabstract contract OwnerPausable is Ownable, Pausable {\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    "contracts/libraries/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"
    },
    "contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/StableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/Initializable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./base/OwnerPausable.sol\";\nimport \"./RequiemStableSwapLib.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./StableMath.sol\";\n\nabstract contract StableSwap is IRequiemSwap, OwnerPausable, ReentrancyGuard, Initializable, IRequiemStableSwap {\n    using RequiemStableSwapLib for RequiemStableSwapLib.SwapStorage;\n    using SafeERC20 for IERC20;\n\n    /// constants\n    uint256 public constant MIN_RAMP_TIME = 1 days;\n    uint256 public constant MAX_A = 1e6;\n    uint256 public constant MAX_A_CHANGE = 10;\n    uint256 public constant MAX_ADMIN_FEE = 1e10; // 100%\n    uint256 public constant MAX_SWAP_FEE = 1e8; // 1%\n    uint256 public constant MAX_WITHDRAW_FEE = 1e8; // 1%\n\n    /// STATE VARS\n    RequiemStableSwapLib.SwapStorage public swapStorage;\n    address public feeDistributor;\n    address public feeController;\n    mapping(address => uint8) public tokenIndexes;\n\n    modifier deadlineCheck(uint256 _deadline) {\n        require(block.timestamp <= _deadline, \"timeout\");\n        _;\n    }\n\n    modifier onlyFeeControllerOrOwner() {\n        require(msg.sender == feeController || msg.sender == owner(), \"!feeControllerOrOwner\");\n        _;\n    }\n\n    function initialize(\n        address[] memory _coins,\n        uint8[] memory _decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _A,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address _feeDistributor\n    ) external onlyOwner initializer {\n        require(_coins.length == _decimals.length, \"coinsLength != decimalsLength\");\n        require(_feeDistributor != address(0), \"feeDistributor = empty\");\n        uint256 numberOfCoins = _coins.length;\n        uint256[] memory rates = new uint256[](numberOfCoins);\n        IERC20[] memory coins = new IERC20[](numberOfCoins);\n        for (uint256 i = 0; i < numberOfCoins; i++) {\n            require(_coins[i] != address(0), \"invalidTokenAddress\");\n            require(_decimals[i] <= RequiemStableSwapLib.POOL_TOKEN_COMMON_DECIMALS, \"invalidDecimals\");\n            rates[i] = 10**(RequiemStableSwapLib.POOL_TOKEN_COMMON_DECIMALS - _decimals[i]);\n            coins[i] = IERC20(_coins[i]);\n            tokenIndexes[address(coins[i])] = uint8(i);\n        }\n\n        require(_A < MAX_A, \"> maxA\");\n        require(_fee <= MAX_SWAP_FEE, \"> maxSwapFee\");\n        require(_adminFee <= MAX_ADMIN_FEE, \"> maxAdminFee\");\n        require(_withdrawFee <= MAX_WITHDRAW_FEE, \"> maxWithdrawFee\");\n\n        swapStorage.lpToken = new LPToken(lpTokenName, lpTokenSymbol);\n        swapStorage.balances = new uint256[](numberOfCoins);\n        swapStorage.tokenMultipliers = rates;\n        swapStorage.pooledTokens = coins;\n        swapStorage.initialA = _A * RequiemStableSwapLib.A_PRECISION;\n        swapStorage.futureA = _A * RequiemStableSwapLib.A_PRECISION;\n        swapStorage.fee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n        feeDistributor = _feeDistributor;\n    }\n\n    /// PUBLIC FUNCTIONS\n    function addLiquidity(\n        uint256[] memory amounts,\n        uint256 minMintAmount,\n        uint256 deadline\n    ) external override whenNotPaused nonReentrant deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.addLiquidity(amounts, minMintAmount);\n    }\n\n    function swap(\n        uint8 fromIndex,\n        uint8 toIndex,\n        uint256 inAmount,\n        uint256 minOutAmount,\n        address to,\n        uint256 deadline\n    ) external override whenNotPaused nonReentrant deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.swap(fromIndex, toIndex, inAmount, minOutAmount, to);\n    }\n\n    function onSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external override whenNotPaused nonReentrant returns (uint256) {\n        return swapStorage.onSwapGivenIn(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn, amountOutMin, to);\n    }\n\n    function onSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) external override whenNotPaused nonReentrant returns (uint256) {\n        return swapStorage.onSwapGivenOut(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountOut, amountInMax, to);\n    }\n\n    function removeLiquidity(\n        uint256 lpAmount,\n        uint256[] memory minAmounts,\n        uint256 deadline\n    ) external override nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(lpAmount, minAmounts);\n    }\n\n    function removeLiquidityOneToken(\n        uint256 lpAmount,\n        uint8 index,\n        uint256 minAmount,\n        uint256 deadline\n    ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.removeLiquidityOneToken(lpAmount, index, minAmount);\n    }\n\n    function removeLiquidityImbalance(\n        uint256[] memory amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /// VIEW FUNCTIONS\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    function getA() external view override returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    function getAPrecise() external view override returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    function getTokens() external view override returns (IERC20[] memory) {\n        return swapStorage.pooledTokens;\n    }\n\n    function getToken(uint8 index) external view override returns (IERC20) {\n        return swapStorage.pooledTokens[index];\n    }\n\n    function getLpToken() external view override returns (IERC20) {\n        return swapStorage.lpToken;\n    }\n\n    function getTokenIndex(address token) external view override returns (uint8 index) {\n        index = tokenIndexes[token];\n        require(address(swapStorage.pooledTokens[index]) == token, \"tokenNotFound\");\n    }\n\n    function getTokenPrecisionMultipliers() external view returns (uint256[] memory) {\n        return swapStorage.tokenMultipliers;\n    }\n\n    function getTokenBalances() external view override returns (uint256[] memory) {\n        return swapStorage.balances;\n    }\n\n    function getTokenBalance(uint8 index) external view override returns (uint256) {\n        return swapStorage.balances[index];\n    }\n\n    function getNumberOfTokens() external view override returns (uint256) {\n        return swapStorage.pooledTokens.length;\n    }\n\n    function getAdminBalances() external view override returns (uint256[] memory adminBalances) {\n        uint256 length = swapStorage.pooledTokens.length;\n        adminBalances = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            adminBalances[i] = swapStorage.getAdminBalance(i);\n        }\n    }\n\n    function getAdminBalance(uint8 index) external view override returns (uint256) {\n        return swapStorage.getAdminBalance((index));\n    }\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view override returns (uint256) {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    function calculateSwap(\n        uint8 inIndex,\n        uint8 outIndex,\n        uint256 inAmount\n    ) external view override returns (uint256) {\n        return swapStorage.calculateSwap(inIndex, outIndex, inAmount);\n    }\n\n    // calculates output amount for given input\n    function calculateSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn);\n    }\n\n    // calculates input amount for given output\n    function calculateSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut\n    ) external view returns (uint256) {\n        return swapStorage.calculateSwapGivenOut(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountOut);\n    }\n\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view override returns (uint256[] memory) {\n        return swapStorage.calculateRemoveLiquidity(account, amount);\n    }\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 amount,\n        uint8 index\n    ) external view override returns (uint256) {\n        return swapStorage.calculateRemoveLiquidityOneToken(account, amount, index);\n    }\n\n    function calculateCurrentWithdrawFee(address account) external view override returns (uint256) {\n        return swapStorage._calculateCurrentWithdrawFee(account);\n    }\n\n    /// RESTRICTED FUNCTION\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external override {\n        require(msg.sender == address(swapStorage.lpToken), \"!lpToken\");\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * swap fee cannot be higher than 1% of each swap\n     * @param newSwapFee new swap fee to be applied on future transactions\n     * @param newAdminFee new admin fee to be applied on future transactions\n     * @param newWithdrawFee new initial withdraw fee to be applied on future withdrawal transactions\n     */\n    function setFee(\n        uint256 newSwapFee,\n        uint256 newAdminFee,\n        uint256 newWithdrawFee\n    ) external onlyOwner {\n        require(newSwapFee <= MAX_SWAP_FEE, \"> maxSwapFee\");\n        require(newAdminFee <= MAX_ADMIN_FEE, \"> maxAdminFee\");\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"> maxWithdrawFee\");\n        swapStorage.adminFee = newAdminFee;\n        swapStorage.fee = newSwapFee;\n        swapStorage.defaultWithdrawFee = newWithdrawFee;\n\n        emit NewFee(newSwapFee, newAdminFee, newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureATime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureATime) external onlyOwner {\n        require(block.timestamp >= swapStorage.initialATime + (1 days), \"< rampDelay\"); // please wait 1 days before start a new ramping\n        require(futureATime >= block.timestamp + (MIN_RAMP_TIME), \"< minRampTime\");\n        require(0 < futureA && futureA < MAX_A, \"outOfRange\");\n\n        uint256 initialAPrecise = swapStorage.getAPrecise();\n        uint256 futureAPrecise = futureA * RequiemStableSwapLib.A_PRECISION;\n\n        if (futureAPrecise < initialAPrecise) {\n            require(futureAPrecise * (MAX_A_CHANGE) >= initialAPrecise, \"> maxChange\");\n        } else {\n            require(futureAPrecise <= initialAPrecise * (MAX_A_CHANGE), \"> maxChange\");\n        }\n\n        swapStorage.initialA = initialAPrecise;\n        swapStorage.futureA = futureAPrecise;\n        swapStorage.initialATime = block.timestamp;\n        swapStorage.futureATime = futureATime;\n\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureATime);\n    }\n\n    function stopRampA() external onlyOwner {\n        require(swapStorage.futureATime > block.timestamp, \"alreadyStopped\");\n        uint256 currentA = swapStorage.getAPrecise();\n\n        swapStorage.initialA = currentA;\n        swapStorage.futureA = currentA;\n        swapStorage.initialATime = block.timestamp;\n        swapStorage.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n\n    function setFeeController(address _feeController) external onlyOwner {\n        require(_feeController != address(0), \"zeroAddress\");\n        feeController = _feeController;\n        emit FeeControllerChanged(_feeController);\n    }\n\n    function setFeeDistributor(address _feeDistributor) external onlyOwner {\n        require(_feeDistributor != address(0), \"zeroAddress\");\n        feeDistributor = _feeDistributor;\n        emit FeeDistributorChanged(_feeDistributor);\n    }\n\n    function withdrawAdminFee() external onlyFeeControllerOrOwner {\n        for (uint256 i = 0; i < swapStorage.pooledTokens.length; i++) {\n            IERC20 token = swapStorage.pooledTokens[i];\n            uint256 balance = token.balanceOf(address(this)) - (swapStorage.balances[i]);\n            if (balance != 0) {\n                token.safeTransfer(feeDistributor, balance);\n                emit CollectProtocolFee(address(token), balance);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}"
    },
    "contracts/interfaces/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\n// work differently from the OpenZeppelin version if it is not.\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\nimport \"../interfaces/ERC20/IERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     *\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\n     */\n    function _callOptionalReturn(address token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n        (bool success, bytes memory returndata) = token.call(data);\n\n        // If the low-level call didn't succeed we return whatever was returned from it.\n        assembly {\n            if eq(success, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\n        RequiemErrors._require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\n    }\n}\n"
    },
    "contracts/RequiemStableSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./tokens/LPToken.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\n/**\n * StableSwap main algorithm\n */\nlibrary RequiemStableSwapLib {\n    using SafeERC20 for IERC20;\n\n    event AddLiquidity(address indexed provider, uint256[] token_amounts, uint256[] fees, uint256 invariant, uint256 token_supply);\n\n    event TokenExchange(address indexed buyer, uint256 sold_id, uint256 tokens_sold, uint256 bought_id, uint256 tokens_bought);\n\n    event RemoveLiquidity(address indexed provider, uint256[] token_amounts, uint256[] fees, uint256 token_supply);\n\n    event RemoveLiquidityOne(address indexed provider, uint256 index, uint256 token_amount, uint256 coin_amount);\n\n    event RemoveLiquidityImbalance(address indexed provider, uint256[] token_amounts, uint256[] fees, uint256 invariant, uint256 token_supply);\n\n    uint256 public constant FEE_DENOMINATOR = 1e10;\n    // uint256 public constant PRECISION = 1e18;\n\n    /// @dev protect from division loss when run approximation loop. We cannot divide at the end because of overflow,\n    /// so we add some (small) PRECISION when divide in each iteration\n    uint256 public constant A_PRECISION = 100;\n    /// @dev max iteration of converge calccuate\n    uint256 internal constant MAX_ITERATION = 256;\n    uint256 public constant POOL_TOKEN_COMMON_DECIMALS = 18;\n\n    struct SwapStorage {\n        IERC20[] pooledTokens;\n        LPToken lpToken;\n        /// @dev token i multiplier to reach POOL_TOKEN_COMMON_DECIMALS\n        uint256[] tokenMultipliers;\n        /// @dev effective balance which might different from token balance of the contract 'cause it hold admin fee as well\n        uint256[] balances;\n        /// @dev swap fee ratio. Charge on any action which move balance state far from the ideal state\n        uint256 fee;\n        /// @dev admin fee in ratio of swap fee.\n        uint256 adminFee;\n        /// @dev observation of A, multiplied with A_PRECISION\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // withdrawal fee control\n        uint256 defaultWithdrawFee;\n        mapping(address => uint256) depositTimestamp;\n        mapping(address => uint256) withdrawFeeMultiplier;\n    }\n\n    /**\n     * @notice Deposit coins into the pool\n     * @param amounts List of amounts of coins to deposit\n     * @param minMintAmount Minimum amount of LP tokens to mint from the deposit\n     * @return mintAmount Amount of LP tokens received by depositing\n     */\n    function addLiquidity(\n        SwapStorage storage self,\n        uint256[] memory amounts,\n        uint256 minMintAmount\n    ) external returns (uint256 mintAmount) {\n        uint256 nCoins = self.pooledTokens.length;\n        require(amounts.length == nCoins, \"length\");\n        uint256[] memory fees = new uint256[](nCoins);\n        uint256 _fee = _feePerToken(self);\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 amp = _getAPrecise(self);\n\n        uint256 D0 = 0;\n        if (tokenSupply > 0) {\n            D0 = _getD(_xp(self.balances, self.tokenMultipliers), amp);\n        }\n\n        uint256[] memory newBalances = self.balances;\n\n        for (uint256 i = 0; i < nCoins; i++) {\n            if (tokenSupply == 0) {\n                require(amounts[i] > 0, \"tokens\");\n            }\n            // get real transfer in amount\n            newBalances[i] += _doTransferIn(self.pooledTokens[i], amounts[i]);\n        }\n\n        uint256 D1 = _getD(_xp(newBalances, self.tokenMultipliers), amp);\n        assert(D1 > D0); // double check\n\n        if (tokenSupply == 0) {\n            self.balances = newBalances;\n            mintAmount = D1;\n        } else {\n            uint256 diff = 0;\n            for (uint256 i = 0; i < nCoins; i++) {\n                diff = _distance((D1 * self.balances[i]) / D0, newBalances[i]);\n                fees[i] = (_fee * diff) / FEE_DENOMINATOR;\n                self.balances[i] = newBalances[i] - ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                newBalances[i] -= fees[i];\n            }\n            D1 = _getD(_xp(newBalances, self.tokenMultipliers), amp);\n            mintAmount = (tokenSupply * (D1 - D0)) / D0;\n        }\n\n        require(mintAmount >= minMintAmount, \"> s\");\n\n        self.lpToken.mint(msg.sender, mintAmount);\n        emit AddLiquidity(msg.sender, amounts, fees, D1, mintAmount);\n    }\n\n    // implements classic swap function a la compound\n    // here the regular calculations such as balance values are implemented\n    // funds are transferred in in that function and are not required to be sent\n    // to the contract\n    function swap(\n        SwapStorage storage self,\n        uint256 i,\n        uint256 j,\n        uint256 inAmount,\n        uint256 minOutAmount,\n        address to\n    ) external returns (uint256) {\n        IERC20 inCoin = self.pooledTokens[i];\n        uint256[] memory normalizedBalances = _xp(self);\n        inAmount = _doTransferIn(inCoin, inAmount);\n\n        uint256 y = _getY(self, i, j, normalizedBalances[i] + (inAmount * self.tokenMultipliers[i]), normalizedBalances);\n\n        uint256 dy = normalizedBalances[j] - y - 1; // iliminate rouding errors\n        uint256 dy_fee = (dy * self.fee) / FEE_DENOMINATOR;\n\n        dy = (dy - dy_fee) / self.tokenMultipliers[j]; // denormalize\n\n        require(dy >= minOutAmount, \"> s\");\n\n        // update balances\n        self.balances[i] += inAmount;\n        self.balances[j] -= dy + (dy_fee * self.adminFee) / FEE_DENOMINATOR / self.tokenMultipliers[j];\n\n        self.pooledTokens[j].safeTransfer(to, dy);\n        emit TokenExchange(to, i, inAmount, j, dy);\n        return dy;\n    }\n\n    /**\n     *  the same function as swap, but it expects that amounts already have been\n     *  sent to the contract\n     *   - designed to be used in the Requiem Swap framework\n     *   - deducts the fee from the output, in this case simple as the output is the calculated value\n     *   - viable function for batch swapping\n     * @param i token index in\n     * @param j token index out\n     */\n    function onSwapGivenIn(\n        SwapStorage storage self,\n        uint256 i,\n        uint256 j,\n        uint256 inAmount,\n        uint256 minOutAmount,\n        address to\n    ) external returns (uint256 dy) {\n        // we check whether the balance has increased by the suggested inAmount\n        require(self.balances[i] + inAmount <= IERC20(self.pooledTokens[i]).balanceOf(address(this)), \"input\");\n        uint256[] memory normalizedBalances = _xp(self);\n        uint256 x = normalizedBalances[i] + (inAmount * self.tokenMultipliers[i]);\n        uint256 y = _getY(self, i, j, x, normalizedBalances);\n\n        dy = normalizedBalances[j] - y - 1; // iliminate rouding errors\n        uint256 dy_fee = (dy * self.fee) / FEE_DENOMINATOR;\n\n        dy = (dy - dy_fee) / self.tokenMultipliers[j]; // denormalize\n\n        require(dy >= minOutAmount, \"> s\");\n\n        uint256 _adminFee = (dy_fee * self.adminFee) / FEE_DENOMINATOR / self.tokenMultipliers[j];\n\n        // update balances\n        self.balances[i] += inAmount;\n        self.balances[j] -= dy + _adminFee;\n\n        self.pooledTokens[j].safeTransfer(to, dy);\n        emit TokenExchange(to, i, inAmount, j, dy);\n\n        // returns final output amount\n        return dy;\n    }\n\n    /**\n     * the same function as swap, but it espects that amounts already have been\n     * sent to the contract and it requires the output to be provided\n     *  - designed to be used in the requirem swap framework\n     *  - deducts the fees from the output, that means that the\n     *    output has to be increased by the fee to then create a highe input\n     * @param i token index in\n     * @param j token index out\n     */\n    function onSwapGivenOut(\n        SwapStorage storage self,\n        uint256 i,\n        uint256 j,\n        uint256 outAmount,\n        uint256 maxInAmount,\n        address to\n    ) external returns (uint256 dx) {\n        uint256[] memory normalizedBalances = _xp(self);\n\n        // thre fee is a percentage from the \"actual\" amountOut, we have to use the quotient because of that\n        uint256 _amountOutInclFee = divDown(outAmount * FEE_DENOMINATOR, FEE_DENOMINATOR - self.fee);\n\n        // calculate out balance\n        uint256 y = normalizedBalances[j] - (_amountOutInclFee * self.tokenMultipliers[j]);\n\n        // calculate in balance\n        uint256 x = _getY(self, j, i, y, normalizedBalances);\n\n        // calculate normalized in balance\n        dx = x - normalizedBalances[i]; // no rounding adjustment\n\n        dx = dx / self.tokenMultipliers[i]; // denormalize\n\n        require(dx <= maxInAmount, \"> s\");\n\n        // update balances\n        self.balances[i] -= dx;\n        self.balances[j] -= _amountOutInclFee;\n\n        // do the transfer after all calculations\n        IERC20 inCoin = self.pooledTokens[i];\n        dx = _doTransferIn(inCoin, dx); // transfer the calculated amount in\n\n        self.pooledTokens[j].safeTransfer(to, outAmount); // transfer the desired amount out\n        emit TokenExchange(to, i, dx, j, outAmount);\n\n        // returns final input amount\n        return dx;\n    }\n\n    function removeLiquidity(\n        SwapStorage storage self,\n        uint256 lpAmount,\n        uint256[] memory minAmounts\n    ) external returns (uint256[] memory amounts) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(lpAmount <= totalSupply);\n        uint256 nCoins = self.pooledTokens.length;\n\n        uint256[] memory fees = new uint256[](nCoins);\n        amounts = _calculateRemoveLiquidity(self, msg.sender, lpAmount);\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"> s\");\n            self.balances[i] = self.balances[i] - amounts[i];\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        self.lpToken.burnFrom(msg.sender, lpAmount);\n        emit RemoveLiquidity(msg.sender, amounts, fees, totalSupply - lpAmount);\n    }\n\n    function removeLiquidityOneToken(\n        SwapStorage storage self,\n        uint256 lpAmount,\n        uint256 index,\n        uint256 minAmount\n    ) external returns (uint256) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(totalSupply > 0, \"totalSupply = 0\");\n        uint256 numTokens = self.pooledTokens.length;\n        require(lpAmount <= self.lpToken.balanceOf(msg.sender), \"> balance\");\n        require(lpAmount <= totalSupply, \"> totalSupply\");\n        require(index < numTokens, \"tokenNotFound\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = _calculateRemoveLiquidityOneToken(self, msg.sender, lpAmount, index);\n\n        require(dy >= minAmount, \"> s\");\n\n        self.balances[index] -= (dy + (dyFee * self.adminFee) / FEE_DENOMINATOR);\n        self.lpToken.burnFrom(msg.sender, lpAmount);\n        self.pooledTokens[index].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(msg.sender, index, lpAmount, dy);\n\n        return dy;\n    }\n\n    function removeLiquidityImbalance(\n        SwapStorage storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) external returns (uint256 burnAmount) {\n        uint256 nCoins = self.pooledTokens.length;\n        require(amounts.length == nCoins, \"length\");\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(totalSupply != 0, \"totalSupply = 0\");\n        uint256 _fee = _feePerToken(self);\n        uint256 amp = _getAPrecise(self);\n\n        uint256[] memory newBalances = self.balances;\n        uint256 D0 = _getD(_xp(self), amp);\n\n        for (uint256 i = 0; i < nCoins; i++) {\n            newBalances[i] -= amounts[i];\n        }\n\n        uint256 D1 = _getD(_xp(newBalances, self.tokenMultipliers), amp);\n        uint256[] memory fees = new uint256[](nCoins);\n\n        for (uint256 i = 0; i < nCoins; i++) {\n            uint256 idealBalance = (D1 * self.balances[i]) / D0;\n            uint256 diff = _distance(newBalances[i], idealBalance);\n            fees[i] = (_fee * diff) / FEE_DENOMINATOR;\n            self.balances[i] = newBalances[i] - ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n            newBalances[i] -= fees[i];\n        }\n\n        // recalculate invariant with fee charged balances\n        D1 = _getD(_xp(newBalances, self.tokenMultipliers), amp);\n        burnAmount = ((D0 - D1) * totalSupply) / D0;\n        assert(burnAmount > 0);\n        burnAmount = (burnAmount + 1) * (FEE_DENOMINATOR - _calculateCurrentWithdrawFee(self, msg.sender)); //In case of rounding errors - make it unfavorable for the \"attacker\"\n        require(burnAmount <= maxBurnAmount, \"> s\");\n\n        self.lpToken.burnFrom(msg.sender, burnAmount);\n\n        for (uint256 i = 0; i < nCoins; i++) {\n            if (amounts[i] != 0) {\n                self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n\n        emit RemoveLiquidityImbalance(msg.sender, amounts, fees, D1, totalSupply - burnAmount);\n    }\n\n    /// VIEW FUNCTIONS\n    function getAPrecise(SwapStorage storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * Returns portfolio virtual price (for calculating profit)\n     * scaled up by 1e18\n     */\n    function getVirtualPrice(SwapStorage storage self) external view returns (uint256) {\n        uint256 D = _getD(_xp(self), _getAPrecise(self));\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        return (D * 10**POOL_TOKEN_COMMON_DECIMALS) / tokenSupply;\n    }\n\n    function getAdminBalance(SwapStorage storage self, uint256 index) external view returns (uint256) {\n        require(index < self.pooledTokens.length, \"indexOutOfRange\");\n        return self.pooledTokens[index].balanceOf(address(this)) - (self.balances[index]);\n    }\n\n    /**\n     * Estimate amount of LP token minted or burned at deposit or withdrawal\n     * without taking fees into account\n     */\n    function calculateTokenAmount(\n        SwapStorage storage self,\n        uint256[] memory amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 nCoins = self.pooledTokens.length;\n        require(amounts.length == nCoins, \"length\");\n        uint256 amp = _getAPrecise(self);\n        uint256 D0 = _getD(_xp(self), amp);\n\n        uint256[] memory newBalances = self.balances;\n        for (uint256 i = 0; i < nCoins; i++) {\n            if (deposit) {\n                newBalances[i] += amounts[i];\n            } else {\n                newBalances[i] -= amounts[i];\n            }\n        }\n\n        uint256 D1 = _getD(_xp(newBalances, self.tokenMultipliers), amp);\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (totalSupply == 0) {\n            return D1; // first depositor take it all\n        }\n\n        uint256 diff = deposit ? D1 - D0 : D0 - D1;\n        return (diff * self.lpToken.totalSupply()) / D0;\n    }\n\n    function getA(SwapStorage storage self) external view returns (uint256) {\n        return _getAPrecise(self) / A_PRECISION;\n    }\n\n    // implements calculation of stable swap interface\n    // represents calculateSwapGivenIn function\n    function calculateSwap(\n        SwapStorage storage self,\n        uint256 inIndex,\n        uint256 outIndex,\n        uint256 inAmount\n    ) external view returns (uint256) {\n        uint256[] memory normalizedBalances = _xp(self);\n        uint256 newInBalance = normalizedBalances[inIndex] + (inAmount * self.tokenMultipliers[inIndex]);\n        uint256 outBalance = _getY(self, inIndex, outIndex, newInBalance, normalizedBalances);\n        uint256 outAmount = divDown(normalizedBalances[outIndex] - outBalance, self.tokenMultipliers[outIndex]);\n        uint256 _fee = (self.fee * outAmount) / FEE_DENOMINATOR;\n        return outAmount - _fee;\n    }\n\n    // implements calculation for Requiem interface\n    // note that due to the fact that the structure is not symmetric (unlike pairs)\n    // we require a separate function to calculate the input for a given output\n    function calculateSwapGivenOut(\n        SwapStorage storage self,\n        uint256 inIndex,\n        uint256 outIndex,\n        uint256 outAmount\n    ) external view returns (uint256) {\n        uint256[] memory normalizedBalances = _xp(self);\n        // fee has to be deducted on the output\n        uint256 _amountOutInclFee = divDown(outAmount * FEE_DENOMINATOR, FEE_DENOMINATOR - self.fee);\n        uint256 newOutBalance = normalizedBalances[outIndex] - (_amountOutInclFee * self.tokenMultipliers[outIndex]);\n        // switch index on regulat _getY function\n        uint256 inBalance = _getY(self, outIndex, inIndex, newOutBalance, normalizedBalances);\n        uint256 inAmount = divUp(inBalance - normalizedBalances[inIndex], self.tokenMultipliers[inIndex]);\n        return inAmount;\n    }\n\n    function calculateRemoveLiquidity(\n        SwapStorage storage self,\n        address account,\n        uint256 amount\n    ) external view returns (uint256[] memory) {\n        return _calculateRemoveLiquidity(self, account, amount);\n    }\n\n    function calculateRemoveLiquidityOneToken(\n        SwapStorage storage self,\n        address account,\n        uint256 lpAmount,\n        uint256 tokenIndex\n    ) external view returns (uint256 amount) {\n        (amount, ) = _calculateRemoveLiquidityOneToken(self, account, lpAmount, tokenIndex);\n    }\n\n    /**\n     * @notice Update the withdraw fee for `user`. If the user is currently\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\n     * the starting withdraw fee based on the last deposit's time & amount relative\n     * to the new deposit.\n     *\n     * @param self Swap struct to read from and write to\n     * @param user address of the user depositing tokens\n     * @param toMint amount of pool tokens to be minted\n     */\n    function updateUserWithdrawFee(\n        SwapStorage storage self,\n        address user,\n        uint256 toMint\n    ) external {\n        _updateUserWithdrawFee(self, user, toMint);\n    }\n\n    /// INTERNAL FUNCTIONS\n\n    /**\n     * Ramping A up or down, return A with precision of A_PRECISION\n     */\n    function _getAPrecise(SwapStorage storage self) internal view returns (uint256) {\n        if (block.timestamp >= self.futureATime) {\n            return self.futureA;\n        }\n\n        if (self.futureA > self.initialA) {\n            return self.initialA + ((self.futureA - self.initialA) * (block.timestamp - self.initialATime)) / (self.futureATime - self.initialATime);\n        }\n\n        return self.initialA - ((self.initialA - self.futureA) * (block.timestamp - self.initialATime)) / (self.futureATime - self.initialATime);\n    }\n\n    /**\n     * normalized balances of each tokens.\n     */\n    function _xp(uint256[] memory balances, uint256[] memory rates) internal pure returns (uint256[] memory) {\n        for (uint256 i = 0; i < balances.length; i++) {\n            rates[i] = (rates[i] * balances[i]);\n        }\n\n        return rates;\n    }\n\n    function _xp(SwapStorage storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenMultipliers);\n    }\n\n    /**\n     * Calculate D for *NORMALIZED* balances of each tokens\n     * @param xp normalized balances of token\n     */\n    function _getD(uint256[] memory xp, uint256 amp) internal pure returns (uint256) {\n        uint256 nCoins = xp.length;\n        uint256 sum = _sumOf(xp);\n        if (sum == 0) {\n            return 0;\n        }\n\n        uint256 Dprev = 0;\n        uint256 D = sum;\n        uint256 Ann = amp * nCoins;\n\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\n            uint256 D_P = D;\n            for (uint256 j = 0; j < xp.length; j++) {\n                D_P = (D_P * D) / (xp[j] * nCoins);\n            }\n            Dprev = D;\n            D = (((Ann * sum) / A_PRECISION + D_P * nCoins) * D) / (((Ann - A_PRECISION) * D) / A_PRECISION + (nCoins + 1) * D_P);\n            if (_distance(D, Dprev) <= 1) {\n                return D;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"invariantCalculationFailed\");\n    }\n\n    /**\n     * calculate new balance of when swap\n     * Done by solving quadratic equation iteratively.\n     *  x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     *  x_1**2 + b*x_1 = c\n     *  x_1 = (x_1**2 + c) / (2*x_1 + b)\n     * @param inIndex index of token to swap in\n     * @param outIndex index of token to swap out\n     * @param inBalance new balance (normalized) of input token if the swap is successful\n     * @return NORMALIZED balance of output token if the swap is successful\n     */\n    function _getY(\n        SwapStorage storage self,\n        uint256 inIndex,\n        uint256 outIndex,\n        uint256 inBalance,\n        uint256[] memory normalizedBalances\n    ) internal view returns (uint256) {\n        require(inIndex != outIndex, \"sameToken\");\n        uint256 nCoins = self.pooledTokens.length;\n        require(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n        uint256 amp = _getAPrecise(self);\n        uint256 Ann = amp * nCoins;\n        uint256 D = _getD(normalizedBalances, amp); // calculate invariant\n\n        uint256 sum = 0; // sum of new balances except output token\n        uint256 c = D;\n        for (uint256 i = 0; i < nCoins; i++) {\n            if (i == outIndex) {\n                continue;\n            }\n\n            uint256 x = i == inIndex ? inBalance : normalizedBalances[i];\n            sum += x;\n            c = (c * D) / (x * nCoins);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * nCoins);\n        uint256 b = sum + (D * A_PRECISION) / Ann;\n\n        uint256 lastY = 0;\n        uint256 y = D;\n\n        for (uint256 index = 0; index < MAX_ITERATION; index++) {\n            lastY = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (_distance(lastY, y) <= 1) {\n                return y;\n            }\n        }\n\n        revert(\"yCalculationFailed\");\n    }\n\n    function _calculateRemoveLiquidity(\n        SwapStorage storage self,\n        address account,\n        uint256 amount\n    ) internal view returns (uint256[] memory) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(amount <= totalSupply, \"total supply\");\n\n        uint256 feeAdjustedAmount = (amount * (FEE_DENOMINATOR - _calculateCurrentWithdrawFee(self, account))) / FEE_DENOMINATOR;\n\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            amounts[i] = (self.balances[i] * (feeAdjustedAmount)) / (totalSupply);\n        }\n        return amounts;\n    }\n\n    function _calculateRemoveLiquidityOneToken(\n        SwapStorage storage self,\n        address account,\n        uint256 tokenAmount,\n        uint256 index\n    ) internal view returns (uint256 dy, uint256 fee) {\n        require(index < self.pooledTokens.length, \"indexOutOfRange\");\n        uint256 amp = _getAPrecise(self);\n        uint256[] memory xp = _xp(self);\n        uint256 D0 = _getD(xp, amp);\n        uint256 D1 = D0 - (tokenAmount * D0) / self.lpToken.totalSupply();\n        uint256 newY = _getYD(self, amp, index, xp, D1);\n        uint256[] memory reducedXP = xp;\n        uint256 _fee = _feePerToken(self);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 expectedDx = 0;\n            if (i == index) {\n                expectedDx = (xp[i] * D1) / D0 - newY;\n            } else {\n                expectedDx = xp[i] - (xp[i] * D1) / D0;\n            }\n            reducedXP[i] -= (_fee * expectedDx) / FEE_DENOMINATOR;\n        }\n\n        dy = reducedXP[index] - _getYD(self, amp, index, reducedXP, D1);\n        dy = (dy - 1) / self.tokenMultipliers[index];\n        fee = ((xp[index] - newY) / self.tokenMultipliers[index]) - dy;\n        dy = (dy * (FEE_DENOMINATOR - _calculateCurrentWithdrawFee(self, account))) / FEE_DENOMINATOR;\n    }\n\n    function _feePerToken(SwapStorage storage self) internal view returns (uint256) {\n        uint256 nCoins = self.pooledTokens.length;\n        return (self.fee * nCoins) / (4 * (nCoins - 1));\n    }\n\n    function _getYD(\n        SwapStorage storage self,\n        uint256 A,\n        uint256 index,\n        uint256[] memory xp,\n        uint256 D\n    ) internal view returns (uint256) {\n        uint256 nCoins = self.pooledTokens.length;\n        assert(index < nCoins);\n        uint256 Ann = A * nCoins;\n        uint256 c = D;\n        uint256 s = 0;\n        uint256 _x = 0;\n        uint256 yPrev = 0;\n\n        for (uint256 i = 0; i < nCoins; i++) {\n            if (i == index) {\n                continue;\n            }\n            _x = xp[i];\n            s += _x;\n            c = (c * D) / (_x * nCoins);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * nCoins);\n        uint256 b = s + (D * A_PRECISION) / Ann;\n        uint256 y = D;\n\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\n            yPrev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (_distance(yPrev, y) <= 1) {\n                return y;\n            }\n        }\n        revert(\"invariantCalculationFailed\");\n    }\n\n    function _updateUserWithdrawFee(\n        SwapStorage storage self,\n        address user,\n        uint256 toMint\n    ) internal {\n        // If token is transferred to address 0 (or burned), don't update the fee.\n        if (user == address(0)) {\n            return;\n        }\n        if (self.defaultWithdrawFee == 0) {\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\n        } else {\n            // Otherwise, calculate appropriate discount based on last deposit amount\n            uint256 currentFee = _calculateCurrentWithdrawFee(self, user);\n            uint256 currentBalance = self.lpToken.balanceOf(user);\n\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\n            // ((toMint + currentBalance) * defaultWithdrawFee)\n            if ((toMint + currentBalance) * self.defaultWithdrawFee != 0) {\n                self.withdrawFeeMultiplier[user] = (((currentBalance * currentFee) + (toMint * self.defaultWithdrawFee)) * (FEE_DENOMINATOR)) / ((toMint + currentBalance) * self.defaultWithdrawFee);\n            }\n        }\n        self.depositTimestamp[user] = block.timestamp;\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws.\n     * Withdraw fee decays linearly over 4 weeks.\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function _calculateCurrentWithdrawFee(SwapStorage storage self, address user) internal view returns (uint256) {\n        uint256 endTime = self.depositTimestamp[user] + (4 weeks);\n        if (endTime > block.timestamp) {\n            uint256 timeLeftover = endTime - block.timestamp;\n            return (self.defaultWithdrawFee * self.withdrawFeeMultiplier[user] * timeLeftover) / (4 weeks) / FEE_DENOMINATOR;\n        }\n        return 0;\n    }\n\n    function _doTransferIn(IERC20 token, uint256 amount) internal returns (uint256) {\n        uint256 priorBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        return token.balanceOf(address(this)) - priorBalance;\n    }\n\n    function _sumOf(uint256[] memory x) internal pure returns (uint256 sum) {\n        sum = 0;\n        for (uint256 i = 0; i < x.length; i++) {\n            sum += x[i];\n        }\n    }\n\n    function _distance(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"div\");\n        return a / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"div\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            return 1 + (a - 1) / b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\n// solhint-disable var-name-mixedcase\n\ninterface IRequiemStableSwap {\n    /// EVENTS\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 tokenSupply);\n\n    event TokenExchange(address indexed buyer, uint256 soldId, uint256 tokensSold, uint256 boughtId, uint256 tokensBought);\n\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 tokenSupply);\n\n    event RemoveLiquidityOne(address indexed provider, uint256 tokenIndex, uint256 tokenAmount, uint256 coinAmount);\n\n    event RemoveLiquidityImbalance(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 tokenSupply);\n\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n\n    event StopRampA(uint256 A, uint256 timestamp);\n\n    event NewFee(uint256 fee, uint256 adminFee, uint256 withdrawFee);\n\n    event CollectProtocolFee(address token, uint256 amount);\n\n    event FeeControllerChanged(address newController);\n\n    event FeeDistributorChanged(address newController);\n\n    // pool data view functions\n    function getLpToken() external view returns (IERC20 lpToken);\n\n    function getA() external view returns (uint256);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokens() external view returns (IERC20[] memory);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getTokenBalances() external view returns (uint256[] memory);\n\n    function getNumberOfTokens() external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    function getAdminBalances() external view returns (uint256[] memory adminBalances);\n\n    function getAdminBalance(uint8 index) external view returns (uint256);\n\n    function calculateCurrentWithdrawFee(address account) external view returns (uint256);\n\n    // state modifying functions\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        address to,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemSwap {\n    // this funtion requires the correctly calculated amounts as input\n    // the others are supposed to implement that calculation\n    // no return value required since the amounts are already known\n    function onSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address to\n    ) external;\n\n    //\n    function onSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external returns (uint256);\n\n    function onSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) external returns (uint256);\n\n    function calculateSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (uint256);\n\n    function calculateSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/StableMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/math/Math.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed. Additionally, some variables have non mixed case names (e.g. P_D) that relate to the mathematical\n// derivations.\n// solhint-disable private-vars-leading-underscore, var-name-mixedcase\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n\n    uint256 internal constant _MIN_AMP = 1;\n    uint256 internal constant _MAX_AMP = 5000;\n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    uint256 internal constant _MAX_STABLE_TOKENS = 5;\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // About swap fees on joins and exits:\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n    // swap fees, it follows that (some) joins and exits should as well.\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n    // is the one to which swap fees are applied.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        **********************************************************************************************/\n\n        // We support rounding up or down.\n\n        uint256 sum = 0;\n        uint256 numTokens = balances.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            sum = sum.add(balances[i]);\n        }\n        if (sum == 0) {\n            return 0;\n        }\n\n        uint256 prevInvariant = 0;\n        uint256 invariant = sum;\n        uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 P_D = balances[0] * numTokens;\n            for (uint256 j = 1; j < numTokens; j++) {\n                P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n            }\n            prevInvariant = invariant;\n            invariant = Math.div(\n                Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                    Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                ),\n                Math.mul(numTokens + 1, invariant).add(\n                    // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                    Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                ),\n                roundUp\n            );\n\n            if (invariant > prevInvariant) {\n                if (invariant - prevInvariant <= 1) {\n                    return invariant;\n                }\n            } else if (prevInvariant - invariant <= 1) {\n                return invariant;\n            }\n        }\n\n        revert(\"STABLE_INVARIANT_DIDNT_CONVERGE\");\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    // The invariant should be rounded up.\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n        uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            invariant,\n            tokenIndexOut\n        );\n\n        // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n        // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n        balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n        return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n    }\n\n    // Computes how many tokens must be sent to a pool if `tokenAmountOut` are sent given the\n    // current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    // The invariant should be rounded up.\n    function _calcInGivenOut(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountOut,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // inGivenOut token x for y - polynomial equation to solve                                                   //\n        // ax = amount in to calculate                                                                               //\n        // bx = balance token in                                                                                     //\n        // x = bx + ax (finalBalanceIn)                                                                              //\n        // D = invariant                                                D                     D^(n+1)                //\n        // A = amplification coefficient               x^2 + ( S - ----------  - D) * x -  ------------- = 0         //\n        // n = number of tokens                                     (A * n^n)               A * n^2n * P             //\n        // S = sum of final balances but x                                                                           //\n        // P = product of final balances but x                                                                       //\n        **************************************************************************************************************/\n\n        // Amount in, so we round up overall.\n        balances[tokenIndexOut] = balances[tokenIndexOut].sub(tokenAmountOut);\n\n        uint256 finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            invariant,\n            tokenIndexIn\n        );\n\n        // No need to use checked arithmetic since `tokenAmountOut` was actually subtracted from the same balance right\n        // before calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n        balances[tokenIndexOut] = balances[tokenIndexOut] + tokenAmountOut;\n\n        return finalBalanceIn.sub(balances[tokenIndexIn]).add(1);\n    }\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // BPT out, so we round down overall.\n\n        // First loop calculates the sum of all token balances, which will be used to calculate\n        // the current weights of each token, relative to this sum\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // Calculate the weighted balance ratio without considering fees\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\n        // The weighted sum of token balance ratios with fee\n        uint256 invariantRatioWithFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 currentWeight = balances[i].divDown(sumBalances);\n            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\n            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(currentWeight));\n        }\n\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n        uint256[] memory newBalances = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 amountInWithoutFee;\n\n            // Check if the balance ratio is greater than the ideal ratio to charge fees or not\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));\n                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n            } else {\n                amountInWithoutFee = amountsIn[i];\n            }\n\n            newBalances[i] = balances[i].add(amountInWithoutFee);\n        }\n\n        // Get current and new invariants, taking swap fees into account\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\n\n        // If the invariant didn't increase for any reason, we simply don't mint BPT\n        if (invariantRatio > FixedPoint.ONE) {\n            return bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE);\n        } else {\n            return 0;\n        }\n    }\n\n    function _calcTokenInGivenExactBptOut(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // Token in, so we round up overall.\n\n        // Get the current invariant\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n\n        // Calculate new invariant\n        uint256 newInvariant = bptTotalSupply.add(bptAmountOut).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n        // Calculate amount in without fee.\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n        uint256 amountInWithoutFee = newBalanceTokenIndex.sub(balances[tokenIndex]);\n\n        // First calculate the sum of all token balances, which will be used to calculate\n        // the current weight of each token\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n        // accordingly.\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n        uint256 taxablePercentage = currentWeight.complement();\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n        return nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\n    }\n\n    /*\n    Flow of calculations:\n    amountsTokenOut -> amountsOutProportional ->\n    amountOutPercentageExcess -> amountOutBeforeFee -> newInvariant -> amountBPTIn\n    */\n    function _calcBptInGivenExactTokensOut(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // BPT in, so we round up overall.\n\n        // First loop calculates the sum of all token balances, which will be used to calculate\n        // the current weights of each token relative to this sum\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // Calculate the weighted balance ratio without considering fees\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\n        uint256 invariantRatioWithoutFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 currentWeight = balances[i].divUp(sumBalances);\n            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);\n            invariantRatioWithoutFees = invariantRatioWithoutFees.add(balanceRatiosWithoutFee[i].mulUp(currentWeight));\n        }\n\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n        uint256[] memory newBalances = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n            // 'token out'. This results in slightly larger price impact.\n\n            uint256 amountOutWithFee;\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\n                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n                amountOutWithFee = nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\n            } else {\n                amountOutWithFee = amountsOut[i];\n            }\n\n            newBalances[i] = balances[i].sub(amountOutWithFee);\n        }\n\n        // Get current and new invariants, taking into account swap fees\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\n\n        // return amountBPTIn\n        return bptTotalSupply.mulUp(invariantRatio.complement());\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n        // Calculate amount out without fee\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n        uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n        // First calculate the sum of all token balances, which will be used to calculate\n        // the current weight of each token\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n        // in swap fees.\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n        uint256 taxablePercentage = currentWeight.complement();\n\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n        return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n    }\n\n    function _calcTokensOutGivenExactBptIn(\n        uint256[] memory balances,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply\n    ) internal pure returns (uint256[] memory) {\n        /**********************************************************************************************\n        // exactBPTInForTokensOut                                                                    //\n        // (per token)                                                                               //\n        // aO = tokenAmountOut             /        bptIn         \\                                  //\n        // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n        // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n        // bpt = bptTotalSupply                                                                      //\n        **********************************************************************************************/\n\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\n        // multiplication and division.\n\n        uint256 bptRatio = bptAmountIn.divDown(bptTotalSupply);\n\n        uint256[] memory amountsOut = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsOut[i] = balances[i].mulDown(bptRatio);\n        }\n\n        return amountsOut;\n    }\n\n    // The amplification parameter equals: A n^(n-1)\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 lastInvariant,\n        uint256 tokenIndex,\n        uint256 protocolSwapFeePercentage\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // oneTokenSwapFee - polynomial equation to solve                                                            //\n        // af = fee amount to calculate in one token                                                                 //\n        // bf = balance of fee token                                                                                 //\n        // f = bf - af (finalBalanceFeeToken)                                                                        //\n        // D = old invariant                                            D                     D^(n+1)                //\n        // A = amplification coefficient               f^2 + ( S - ----------  - D) * f -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but f                                                                           //\n        // P = product of final balances but f                                                                       //\n        **************************************************************************************************************/\n\n        // Protocol swap fee amount, so we round down overall.\n\n        uint256 finalBalanceFeeToken = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            lastInvariant,\n            tokenIndex\n        );\n\n        if (balances[tokenIndex] <= finalBalanceFeeToken) {\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n            return 0;\n        }\n\n        // Result is rounded down\n        uint256 accumulatedTokenSwapFees = balances[tokenIndex] - finalBalanceFeeToken;\n        return accumulatedTokenSwapFees.mulDown(protocolSwapFeePercentage);\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n\n        uint256 ampTimesTotal = amplificationParameter * balances.length;\n        uint256 sum = balances[0];\n        uint256 P_D = balances[0] * balances.length;\n        for (uint256 j = 1; j < balances.length; j++) {\n            P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n            sum = sum.add(balances[j]);\n        }\n        // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n        sum = sum - balances[tokenIndex];\n\n        uint256 inv2 = Math.mul(invariant, invariant);\n        // We remove the balance from c by multiplying it\n        uint256 c = Math.mul(\n            Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n            balances[tokenIndex]\n        );\n        uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n        // We iterate to find the balance\n        uint256 prevTokenBalance = 0;\n        // We multiply the first iteration outside the loop with the invariant to set the value of the\n        // initial approximation.\n        uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n        for (uint256 i = 0; i < 255; i++) {\n            prevTokenBalance = tokenBalance;\n\n            tokenBalance = Math.divUp(\n                Math.mul(tokenBalance, tokenBalance).add(c),\n                Math.mul(tokenBalance, 2).add(b).sub(invariant)\n            );\n\n            if (tokenBalance > prevTokenBalance) {\n                if (tokenBalance - prevTokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            } else if (prevTokenBalance - tokenBalance <= 1) {\n                return tokenBalance;\n            }\n        }\n\n        revert(\"STABLE_GET_BALANCE_DIDNT_CONVERGE\");\n    }\n\n    function _getRate(\n        uint256[] memory balances,\n        uint256 amp,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        // When calculating the current BPT rate, we may not have paid the protocol fees, therefore\n        // the invariant should be smaller than its current value. Then, we round down overall.\n        uint256 invariant = _calculateInvariant(amp, balances, false);\n        return invariant.divDown(supply);\n    }\n}\n"
    },
    "contracts/libraries/helpers/RequiemErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n// solhint-disable\nlibrary RequiemErrors {\n    /**\n     * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n     * supported.\n     */\n    function _require(bool condition, uint256 errorCode) internal pure {\n        if (!condition) RequiemErrors._revert(errorCode);\n    }\n\n    /**\n     * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n     */\n    function _revert(uint256 errorCode) internal pure {\n        // We're going to dynamically create a revert string based on the error code, with the following format:\n        // 'REQ#{errorCode}'\n        // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n        //\n        // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n        // number (8 to 16 bits) than the individual string characters.\n        //\n        // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n        // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n        // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n        assembly {\n            // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n            // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n            // the '0' character.\n\n            let units := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let tenths := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let hundreds := add(mod(errorCode, 10), 0x30)\n\n            // With the individual characters, we can now construct the full string. The \"REQ#\" part is a known constant\n            // (0x52455123): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n            // characters to it, each shifted by a multiple of 8.\n            // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n            // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n            // array).\n\n            let revertReason := shl(200, add(0x52455123000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n            // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n            // message will have the following layout:\n            // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n            // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n            // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n            mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n            mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n            // The string length is fixed: 7 characters.\n            mstore(0x24, 7)\n            // Finally, the string itself is stored.\n            mstore(0x44, revertReason)\n\n            // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n            // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n            revert(0, 100)\n        }\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n"
    },
    "contracts/tokens/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\nimport \"../libraries/ERC20Burnable.sol\";\nimport \"../libraries/Ownable.sol\";\nimport \"../interfaces/IRequiemStableSwap.sol\";\n\ncontract LPToken is Ownable, ERC20Burnable {\n    IRequiemStableSwap public swap;\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {\n        swap = IRequiemStableSwap(msg.sender);\n    }\n\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        require(_amount > 0, \"zeroMintAmount\");\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n        swap.updateUserWithdrawFee(to, amount);\n    }\n}\n"
    },
    "contracts/libraries/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, msg.sender).sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\n\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        RequiemErrors._require(c >= a, Errors.ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, Errors.SUB_OVERFLOW);\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        uint256 errorCode\n    ) internal pure returns (uint256) {\n        RequiemErrors._require(b <= a, errorCode);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/libraries/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\n * Adapted from OpenZeppelin's SafeMath library\n */\nlibrary Math {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_OVERFLOW\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SUB_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n        return c;\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        return roundUp ? divUp(a, b) : divDown(a, b);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n        return a / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            return 1 + (a - 1) / b;\n        }\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./LogExpMath.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        require(b <= a, \"SUB_OVERFLOW\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        require(a == 0 || product / a == b, \"MUL_OVERFLOW\");\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        require(a == 0 || product / a == b, \"MUL_OVERFLOW\");\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, \"DIV_INTERNAL\"); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ZERO_DIVISION\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, \"DIV_INTERNAL\"); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return sub(raw, maxError);\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        return add(raw, maxError);\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}\n"
    },
    "contracts/libraries/math/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.10;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        require(x < 2**255, \"X_OUT_OF_BOUNDS\");\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        require(y < MILD_EXPONENT_BOUND, \"Y_OUT_OF_BOUNDS\");\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            \"PRODUCT_OUT_OF_BOUNDS\"\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"INVALID_EXPONENT\");\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        require(a > 0, \"OUT_OF_BOUNDS\");\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n"
    },
    "contracts/libraries/weighted/RequiemWeightedMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./../math/FixedPoint.sol\";\nimport \"./../math/Math.sol\";\nimport \"../helpers/InputHelpers.sol\";\nimport \"../helpers/RequiemErrors.sol\";\nimport \"../../interfaces/pool/IRequiemWeightedMath.sol\";\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\ncontract RequiemWeightedMath is IRequiemWeightedMath {\n    using FixedPoint for uint256;\n    // A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n    // implementation of the power function, as these ratios are often exponents.\n    uint256 public constant _MIN_WEIGHT = 0.01e18;\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n    uint256 public constant _MAX_WEIGHTED_TOKENS = 100;\n\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n    // ratio).\n\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\n    uint256 public constant _MAX_IN_RATIO = 0.3e18;\n    uint256 public constant _MAX_OUT_RATIO = 0.3e18;\n\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\n    uint256 public constant _MAX_INVARIANT_RATIO = 3e18;\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\n    uint256 public constant _MIN_INVARIANT_RATIO = 0.7e18;\n\n    // About swap fees on joins and exits:\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n    // swap fees, it follows that (some) joins and exits should as well.\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n    // is the one to which swap fees are applied.\n\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\n    // and, because there is a minimum BPT, we round down the invariant.\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances) external pure returns (uint256 invariant) {\n        /**********************************************************************************************\n        // invariant               _____                                                             //\n        // wi = weight index i      | |      wi                                                      //\n        // bi = balance index i     | |  bi ^   = i                                                  //\n        // i = invariant                                                                             //\n        **********************************************************************************************/\n\n        invariant = FixedPoint.ONE;\n        for (uint256 i = 0; i < normalizedWeights.length; i++) {\n            invariant = invariant.mulDown(balances[i].powDown(normalizedWeights[i]));\n        }\n\n        RequiemErrors._require(invariant > 0, Errors.ZERO_INVARIANT);\n    }\n\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n    // current balances and weights.\n    function _calcOutGivenIn(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountIn\n    ) external pure returns (uint256) {\n        /**********************************************************************************************\n        // outGivenIn                                                                                //\n        // aO = amountOut                                                                            //\n        // bO = balanceOut                                                                           //\n        // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n        // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n        // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n        // wO = weightOut                                                                            //\n        **********************************************************************************************/\n\n        // Amount out, so we round down overall.\n\n        // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\n        // Because bI / (bI + aI) <= 1, the exponent rounds down.\n\n        // Cannot exceed maximum in ratio\n        RequiemErrors._require(amountIn <= balanceIn.mulDown(_MAX_IN_RATIO), Errors.MAX_IN_RATIO);\n\n        uint256 denominator = balanceIn + amountIn;\n        uint256 base = balanceIn.divUp(denominator);\n        uint256 exponent = weightIn.divDown(weightOut);\n        uint256 power = base.powUp(exponent);\n\n        return balanceOut.mulDown(power.complement());\n    }\n\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n    // current balances and weights.\n    function _calcInGivenOut(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountOut\n    ) external pure returns (uint256) {\n        /**********************************************************************************************\n        // inGivenOut                                                                                //\n        // aO = amountOut                                                                            //\n        // bO = balanceOut                                                                           //\n        // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n        // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n        // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n        // wO = weightOut                                                                            //\n        **********************************************************************************************/\n\n        // Amount in, so we round up overall.\n\n        // The multiplication rounds up, and the power rounds up (so the base rounds up too).\n        // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\n\n        // Cannot exceed maximum out ratio\n        RequiemErrors._require(amountOut <= balanceOut.mulDown(_MAX_OUT_RATIO), Errors.MAX_OUT_RATIO);\n\n        uint256 base = balanceOut.divUp(balanceOut - amountOut);\n        uint256 exponent = weightOut.divUp(weightIn);\n        uint256 power = base.powUp(exponent);\n\n        // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n        // the following subtraction should never revert.\n        uint256 ratio = power - FixedPoint.ONE;\n\n        return balanceIn.mulUp(ratio);\n    }\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256, uint256[] memory) {\n        // BPT out, so we round down overall.\n\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\n\n        uint256 invariantRatioWithFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            balanceRatiosWithFee[i] = (balances[i] + amountsIn[i]).divDown(balances[i]);\n            invariantRatioWithFees = invariantRatioWithFees + (balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));\n        }\n\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeJoinExactTokensInInvariantRatio(\n            balances,\n            normalizedWeights,\n            amountsIn,\n            balanceRatiosWithFee,\n            invariantRatioWithFees,\n            swapFeePercentage\n        );\n\n        uint256 bptOut = (invariantRatio > FixedPoint.ONE) ? bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE) : 0;\n        return (bptOut, swapFees);\n    }\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    function _computeJoinExactTokensInInvariantRatio(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256[] memory balanceRatiosWithFee,\n        uint256 invariantRatioWithFees,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\n        // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\n        // increase.\n        swapFees = new uint256[](amountsIn.length);\n        invariantRatio = FixedPoint.ONE;\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 amountInWithoutFee;\n\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees - FixedPoint.ONE);\n                uint256 taxableAmount = amountsIn[i] - nonTaxableAmount;\n                uint256 swapFee = taxableAmount.mulUp(swapFeePercentage);\n\n                amountInWithoutFee = nonTaxableAmount + (taxableAmount - swapFee);\n                swapFees[i] = swapFee;\n            } else {\n                amountInWithoutFee = amountsIn[i];\n            }\n\n            uint256 balanceRatio = (balances[i] + amountInWithoutFee).divDown(balances[i]);\n\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\n        }\n    }\n\n    function _calcTokenInGivenExactBptOut(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256 amountIn, uint256 swapFee) {\n        /******************************************************************************************\n        // tokenInForExactBPTOut                                                                 //\n        // a = amountIn                                                                          //\n        // b = balance                      /  /    totalBPT + bptOut      \\    (1 / w)       \\  //\n        // bptOut = bptAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\n        // bpt = totalBPT                   \\  \\       totalBPT            /                  /  //\n        // w = weight                                                                            //\n        ******************************************************************************************/\n\n        // Token in, so we round up overall.\n\n        // Calculate the factor by which the invariant will increase after minting BPTAmountOut\n        uint256 invariantRatio = (bptTotalSupply + bptAmountOut).divUp(bptTotalSupply);\n        RequiemErrors._require(invariantRatio <= _MAX_INVARIANT_RATIO, Errors.MAX_OUT_BPT_FOR_TOKEN_IN);\n\n        // Calculate by how much the token balance has to increase to match the invariantRatio\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divUp(normalizedWeight));\n\n        uint256 amountInWithoutFee = balance.mulUp(balanceRatio - FixedPoint.ONE);\n\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n        // accordingly.\n        uint256 taxablePercentage = normalizedWeight.complement();\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountInWithoutFee - taxableAmount;\n\n        uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\n\n        swapFee = taxableAmountPlusFees - taxableAmount;\n        amountIn = nonTaxableAmount + taxableAmountPlusFees;\n    }\n\n    function _calcAllTokensInGivenExactBptOut(\n        uint256[] memory balances,\n        uint256 bptAmountOut,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory) {\n        /************************************************************************************\n        // tokensInForExactBptOut                                                          //\n        // (per token)                                                                     //\n        // aI = amountIn                   /   bptOut   \\                                  //\n        // b = balance           aI = b * | ------------ |                                 //\n        // bptOut = bptAmountOut           \\  totalBPT  /                                  //\n        // bpt = totalBPT                                                                  //\n        ************************************************************************************/\n\n        // Tokens in, so we round up overall.\n        uint256 bptRatio = bptAmountOut.divUp(totalBPT);\n\n        uint256[] memory amountsIn = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsIn[i] = balances[i].mulUp(bptRatio);\n        }\n\n        return amountsIn;\n    }\n\n    function _calcBptInGivenExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256, uint256[] memory) {\n        // BPT in, so we round up overall.\n\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\n        uint256 invariantRatioWithoutFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            balanceRatiosWithoutFee[i] = (balances[i] - amountsOut[i]).divUp(balances[i]);\n            invariantRatioWithoutFees = invariantRatioWithoutFees + (balanceRatiosWithoutFee[i].mulUp(normalizedWeights[i]));\n        }\n\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeExitExactTokensOutInvariantRatio(\n            balances,\n            normalizedWeights,\n            amountsOut,\n            balanceRatiosWithoutFee,\n            invariantRatioWithoutFees,\n            swapFeePercentage\n        );\n\n        uint256 bptIn = bptTotalSupply.mulUp(invariantRatio.complement());\n        return (bptIn, swapFees);\n    }\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    function _computeExitExactTokensOutInvariantRatio(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256[] memory balanceRatiosWithoutFee,\n        uint256 invariantRatioWithoutFees,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\n        swapFees = new uint256[](amountsOut.length);\n        invariantRatio = FixedPoint.ONE;\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n            // 'token out'. This results in slightly larger price impact.\n\n            uint256 amountOutWithFee;\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\n                uint256 taxableAmount = amountsOut[i] - nonTaxableAmount;\n                uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\n\n                swapFees[i] = taxableAmountPlusFees - taxableAmount;\n                amountOutWithFee = nonTaxableAmount + taxableAmountPlusFees;\n            } else {\n                amountOutWithFee = amountsOut[i];\n            }\n\n            uint256 balanceRatio = (balances[i] - amountOutWithFee).divDown(balances[i]);\n\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\n        }\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256 amountOut, uint256 swapFee) {\n        /*****************************************************************************************\n        // exactBPTInForTokenOut                                                                //\n        // a = amountOut                                                                        //\n        // b = balance                     /      /    totalBPT - bptIn       \\    (1 / w)  \\   //\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n        // bpt = totalBPT                  \\      \\       totalBPT            /             /   //\n        // w = weight                                                                           //\n        *****************************************************************************************/\n\n        // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n        // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\n\n        // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n        uint256 invariantRatio = (bptTotalSupply - bptAmountIn).divUp(bptTotalSupply);\n        RequiemErrors._require(invariantRatio >= _MIN_INVARIANT_RATIO, Errors.MIN_BPT_IN_FOR_TOKEN_OUT);\n\n        // Calculate by how much the token balance has to decrease to match invariantRatio\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\n\n        // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n        uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\n\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n        // in swap fees.\n        uint256 taxablePercentage = normalizedWeight.complement();\n\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountOutWithoutFee - taxableAmount;\n\n        swapFee = taxableAmount.mulUp(swapFeePercentage);\n        amountOut = nonTaxableAmount + (taxableAmount - swapFee);\n    }\n\n    function _calcTokensOutGivenExactBptIn(\n        uint256[] memory balances,\n        uint256 bptAmountIn,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory) {\n        /**********************************************************************************************\n        // exactBPTInForTokensOut                                                                    //\n        // (per token)                                                                               //\n        // aO = amountOut                  /        bptIn         \\                                  //\n        // b = balance           a0 = b * | ---------------------  |                                 //\n        // bptIn = bptAmountIn             \\       totalBPT       /                                  //\n        // bpt = totalBPT                                                                            //\n        **********************************************************************************************/\n\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\n        // multiplication and division.\n\n        uint256 bptRatio = bptAmountIn.divDown(totalBPT);\n\n        uint256[] memory amountsOut = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsOut[i] = balances[i].mulDown(bptRatio);\n        }\n\n        return amountsOut;\n    }\n\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 previousInvariant,\n        uint256 currentInvariant,\n        uint256 protocolSwapFeePercentage\n    ) external pure returns (uint256) {\n        /*********************************************************************************\n        /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\n        *********************************************************************************/\n\n        if (currentInvariant <= previousInvariant) {\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n            return 0;\n        }\n\n        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n        // fees to the Vault.\n\n        // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\n        // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\n\n        uint256 base = previousInvariant.divUp(currentInvariant);\n        uint256 exponent = FixedPoint.ONE.divDown(normalizedWeight);\n\n        // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\n        // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\n        // 1 / min exponent) the Pool will pay less in protocol fees than it should.\n        base = Math.max(base, FixedPoint.MIN_POW_BASE_FREE_EXPONENT);\n\n        uint256 power = base.powUp(exponent);\n\n        uint256 tokenAccruedFees = balance.mulDown(power.complement());\n        return tokenAccruedFees.mulDown(protocolSwapFeePercentage);\n    }\n}\n"
    },
    "contracts/libraries/helpers/InputHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nlibrary InputHelpers {\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\n        require(a == b, \"INPUT_LENGTH_MISMATCH\");\n    }\n\n    function ensureInputLengthMatch(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure {\n        require(a == b && b == c, \"INPUT_LENGTH_MISMATCH\");\n    }\n\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\n        address[] memory addressArray;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addressArray := array\n        }\n        ensureArrayIsSorted(addressArray);\n    }\n\n    function ensureArrayIsSorted(address[] memory array) internal pure {\n        if (array.length < 2) {\n            return;\n        }\n\n        address previous = array[0];\n        for (uint256 i = 1; i < array.length; ++i) {\n            address current = array[i];\n            require(previous < current, \"UNSORTED_ARRAY\");\n            previous = current;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/pool/IRequiemWeightedMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\ninterface IRequiemWeightedMath {\n    function _MIN_WEIGHT() external pure returns (uint256);\n\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n    function _MAX_WEIGHTED_TOKENS() external pure returns (uint256);\n\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n    // ratio).\n\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\n    function _MAX_IN_RATIO() external pure returns (uint256);\n\n    function _MAX_OUT_RATIO() external pure returns (uint256);\n\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\n    function _MAX_INVARIANT_RATIO() external pure returns (uint256);\n\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\n    function _MIN_INVARIANT_RATIO() external pure returns (uint256);\n\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\n    // and, because there is a minimum BPT, we round down the invariant.\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances) external pure returns (uint256 invariant);\n\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n    // current balances and weights.\n    function _calcOutGivenIn(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountIn\n    ) external pure returns (uint256);\n\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n    // current balances and weights.\n    function _calcInGivenOut(\n        uint256 balanceIn,\n        uint256 weightIn,\n        uint256 balanceOut,\n        uint256 weightOut,\n        uint256 amountOut\n    ) external pure returns (uint256);\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256, uint256[] memory);\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    // function _computeJoinExactTokensInInvariantRatio(\n    //     uint256[] memory balances,\n    //     uint256[] memory normalizedWeights,\n    //     uint256[] memory amountsIn,\n    //     uint256[] memory balanceRatiosWithFee,\n    //     uint256 invariantRatioWithFees,\n    //     uint256 swapFeePercentage\n    // ) external pure returns (uint256 invariantRatio, uint256[] memory swapFees);\n\n    function _calcTokenInGivenExactBptOut(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256 amountIn, uint256 swapFee);\n\n    function _calcAllTokensInGivenExactBptOut(\n        uint256[] memory balances,\n        uint256 bptAmountOut,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory);\n\n    function _calcBptInGivenExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256, uint256[] memory);\n\n    /**\n     * @dev Intermediate function to avoid stack-too-deep \"\n     */\n    // function _computeExitExactTokensOutInvariantRatio(\n    //     uint256[] memory balances,\n    //     uint256[] memory normalizedWeights,\n    //     uint256[] memory amountsOut,\n    //     uint256[] memory balanceRatiosWithoutFee,\n    //     uint256 invariantRatioWithoutFees,\n    //     uint256 swapFeePercentage\n    // ) external pure returns (uint256 invariantRatio, uint256[] memory swapFees);\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) external pure returns (uint256 amountOut, uint256 swapFee);\n\n    function _calcTokensOutGivenExactBptIn(\n        uint256[] memory balances,\n        uint256 bptAmountIn,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory);\n\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 balance,\n        uint256 normalizedWeight,\n        uint256 previousInvariant,\n        uint256 currentInvariant,\n        uint256 protocolSwapFeePercentage\n    ) external pure returns (uint256);\n}\n"
    },
    "contracts/test/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/helpers/RequiemErrors.sol\";\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../libraries/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\n\n // solhint-disable no-empty-blocks\n\ncontract ERC20Test is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        RequiemErrors._require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\n        RequiemErrors._require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        RequiemErrors._require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20Test.sol\";\nimport \"../libraries/ERC20Burnable.sol\";\nimport \"../libraries/AccessControl.sol\";\n\ncontract TestToken is AccessControl, ERC20, ERC20Burnable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        address admin,\n        string memory name,\n        string memory symbol // ,\n        // uint8 decimals\n    ) ERC20(name, symbol) {\n        // _setupDecimals(decimals);\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n        _setupRole(MINTER_ROLE, admin);\n    }\n\n    function mint(address recipient, uint256 amount) external {\n        require(hasRole(MINTER_ROLE, msg.sender), \"NOT_MINTER\");\n        _mint(recipient, amount);\n    }\n}\n"
    },
    "contracts/libraries/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        RequiemErrors._require(hasRole(_roles[role].adminRole, msg.sender), Errors.GRANT_SENDER_NOT_ADMIN);\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had already been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        RequiemErrors._require(hasRole(_roles[role].adminRole, msg.sender), Errors.REVOKE_SENDER_NOT_ADMIN);\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        RequiemErrors._require(account == msg.sender, Errors.RENOUNCE_SENDER_NOT_ALLOWED);\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/libraries/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the EnumerableSet library from OpenZeppelin Contracts, altered to remove the base private functions that\n// work on bytes32, replacing them with a native implementation for address and bytes32 values, to reduce bytecode \n// size and runtime costs.\n// The `unchecked_at` function was also added, which allows for more gas efficient data reads in some scenarios.\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // The original OpenZeppelin implementation uses a generic Set type with bytes32 values: this was replaced with\n    // AddressSet, which uses address keys natively, resulting in more dense bytecode.\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                address lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        RequiemErrors._require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(set, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return set._values[index];\n    }\n\n    function rawIndexOf(AddressSet storage set, address value) internal view returns (uint256) {\n        return set._indexes[value] - 1;\n    }\n\n    struct Bytes32Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0 \n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not \n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        RequiemErrors._require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(set, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return set._values[index];\n    }\n\n    function rawIndexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\n        return set._indexes[value] - 1;\n    }\n}\n"
    },
    "contracts/test/TestWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/AccessControl.sol\";\n\ncontract TestWETH is AccessControl, IWETH {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(address minter) {\n        _setupRole(DEFAULT_ADMIN_ROLE, minter);\n        _setupRole(MINTER_ROLE, minter);\n    }\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable override {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public override {\n        require(balanceOf[msg.sender] >= wad, \"INSUFFICIENT_BALANCE\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    // For testing purposes - this creates WETH that cannot be redeemed for ETH via 'withdraw'\n    function mint(address destinatary, uint256 amount) external {\n        require(hasRole(MINTER_ROLE, msg.sender), \"NOT_MINTER\");\n        balanceOf[destinatary] += amount;\n        emit Deposit(destinatary, amount);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public override returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public override returns (bool) {\n        require(balanceOf[src] >= wad, \"INSUFFICIENT_BALANCE\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"INSUFFICIENT_ALLOWANCE\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\n/**\n * @dev Interface for WETH9.\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\n */\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/RequiemZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./interfaces/IRequiemRouterLite.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/Babylonian.sol\";\n\ncontract RequiemZap is ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    // governance\n    address public governance;\n    address public WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    IUniswapV2Router public uniRouter;\n    IRequiemRouter public requiemRouter;\n    IRequiemFactory public requiemFactory;\n    IRequiemFormula public requiemFormula;\n\n    mapping(address => mapping(address => address[])) public RequiemPairs; // [input -> output] => requiem pair\n    uint public maxResidual = 100; // 1%, set 10000 to disable\n    address[] public tokensResidual;\n\n    event ZapIn(address indexed sender, address from, uint256 amtFrom, address pool, uint256 amtLp);\n    event ZapOut(address indexed sender, address pool, uint256 amtLp, address to, uint256 amtTo);\n    event Withdraw(address indexed token, uint256 amount, address to);\n    event LogGovernance(address governance);\n\n    receive() external payable {\n        require(msg.sender != tx.origin, \"Zap: Do not send ETH directly\");\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"Zap: !governance\");\n        _;\n    }\n\n    constructor(IUniswapV2Router _uniRouter, IRequiemRouter _requiemRouter) {\n        governance = msg.sender;\n        uniRouter = _uniRouter;\n        requiemRouter = _requiemRouter;\n        requiemFactory = IRequiemFactory(_requiemRouter.factory());\n        requiemFormula = IRequiemFormula(_requiemRouter.formula());\n        WETH = _requiemRouter.WETH();\n    }\n\n    /* ========== External Functions ========== */\n\n    // _to: must be a pair lp\n    // _from: must be in lp\n    // _amounts: amount_from, _minTokenB, _minLp\n    function zapInToken(address _from, uint[] calldata amounts, address _to, bool transferResidual) external nonReentrant returns (uint256 lpAmt) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amounts[0]);\n        _approveTokenIfNeeded(_from);\n\n        if (_from == IRequiemPair(_to).token0() || _from == IRequiemPair(_to).token1()) {\n            // swap half amount for other\n            address other;\n            uint256 sellAmount;\n            {\n                address token0 = IRequiemPair(_to).token0();\n                address token1 = IRequiemPair(_to).token1();\n                other = _from == token0 ? token1 : token0;\n                sellAmount = calculateSwapInAmount(_to, _from, amounts[0], token0);\n            }\n            uint otherAmount = _swap(_from, sellAmount, other, address(this), _to);\n            require(otherAmount >= amounts[1], \"Zap: Insufficient Receive Amount\");\n\n            lpAmt = _pairDeposit(_to, _from, other, amounts[0].sub(sellAmount), otherAmount, msg.sender, requiemFactory.isPair(_to), transferResidual);\n        } else {\n            uint bnbAmount = _swapTokenForBNB(_from, amounts[0], address(this), address(0));\n            lpAmt = _swapETHToLp(IRequiemPair(_to), bnbAmount, msg.sender, 0, transferResidual);\n        }\n\n        require(lpAmt >= amounts[2], \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, _from, amounts[0], _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _to: must be a pair lp\n    function zapIn(address _to, uint _minTokenB, uint _minLp, bool transferResidual) external payable nonReentrant returns (uint256) {\n        uint256 lpAmt = _swapETHToLp(IRequiemPair(_to), msg.value, msg.sender, _minTokenB, transferResidual);\n        require(lpAmt >= _minLp, \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, WETH, msg.value, _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _from: must be a pair lp\n    // _toToken: must be in lp\n    function zapOut(address _from, uint amount, address _toToken, uint256 _minTokensRec) public nonReentrant returns (uint256) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amount);\n        _approveTokenIfNeeded(_from);\n\n        address token0;\n        address token1;\n        uint256 amountA;\n        uint256 amountB;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            token0 = pair.token0();\n            token1 = pair.token1();\n            bool isRequiemPair = requiemFactory.isPair(_from);\n            if (isRequiemPair) {\n                (amountA, amountB) = requiemRouter.removeLiquidity(_from, token0, token1, amount, 1, 1, address(this), block.timestamp);\n            } else {\n                (amountA, amountB) = uniRouter.removeLiquidity(token0, token1, amount, 1, 1, address(this), block.timestamp);\n            }\n        }\n\n        uint256 tokenBought;\n        _approveTokenIfNeeded(token0);\n        _approveTokenIfNeeded(token1);\n        if (_toToken == ETH_ADDRESS) {\n            address _lpOfFromAndTo = WETH == token0 || WETH == token1 ? _from : address(0);\n            tokenBought = _swapTokenForBNB(token0, amountA, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swapTokenForBNB(token1, amountB, address(this), _lpOfFromAndTo));\n        } else {\n            address _lpOfFromAndTo = _toToken == token0 || _toToken == token1 ? _from : address(0);\n            tokenBought = _swap(token0, amountA, _toToken, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swap(token1, amountB, _toToken, address(this), _lpOfFromAndTo));\n        }\n\n        require(tokenBought >= _minTokensRec, \"Zap: High Slippage Out\");\n        if (_toToken == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(msg.sender, tokenBought);\n        } else {\n            IERC20(_toToken).safeTransfer(msg.sender, tokenBought);\n        }\n\n        emit ZapOut(msg.sender, _from, amount, _toToken, tokenBought);\n        return tokenBought;\n    }\n\n    function zapOutWithPermit(\n        address _from,\n        uint256 amount,\n        address _toToken,\n        uint256 _minTokensRec,\n        uint256 _approvalAmount,\n        uint256 _deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        // permit\n        IRequiemPair(_from).permit(\n            msg.sender,\n            address(this),\n            _approvalAmount,\n            _deadline,\n            v,\n            r,\n            s\n        );\n\n        return zapOut(_from, amount, _toToken, _minTokensRec);\n    }\n\n    /* ========== View Functions ===========*/\n    // _from: token A\n    // return amount B that will be convert from A to perform zap in\n    // return amount A that will be convert to B to perform zap in\n    function getAmountBToZapIn(address _from, uint _fromAmount, address lp) external view returns (uint256 amountBConverted, uint256 amountASell) {\n        address other;\n        uint sellAmount;\n        {\n            IRequiemPair pair = IRequiemPair(lp);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _from == token0 ? token1 : token0;\n            sellAmount = calculateSwapInAmount(lp, _from, _fromAmount, token0);\n        }\n\n        address[] memory path = new address[](1);\n        path[0] = lp;\n        uint[] memory amounts = requiemFormula.getFactoryAmountsOut(address(requiemFactory), _from, other, sellAmount, path);\n        return (amounts[amounts.length - 1], sellAmount);\n    }\n\n    // _from: lp pair\n    // return amountOtherSell _otherToken that will be removed from pair\n    // return amountToConverted _toToken that will be converted from other\n    // return amountToOrigin _toToken that will be removed from pair\n    function getAmountToZapOut(address _from, uint amount, address _toToken) external view\n    returns (uint256 amountOtherSell, uint256 amountToConverted, uint256 amountToOrigin) {\n        address other;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _toToken == token0 ? token1 : token0;\n        }\n        uint sellAmount;\n        uint amountToRemoved;\n        {\n            uint _totalSupply = IERC20(_from).totalSupply();\n            sellAmount = amount.mul(IERC20(other).balanceOf(_from)) / _totalSupply;\n            amountToRemoved = amount.mul(IERC20(_toToken).balanceOf(_from)) / _totalSupply;\n        }\n\n        uint _amountOut = _getRemovedReserveAmountOut(_from, other, sellAmount, amountToRemoved);\n        return (sellAmount, _amountOut, amountToRemoved);\n    }\n\n    function calculateSwapInAmount(address pair, address tokenIn, uint256 userIn, address pairToken0) internal view returns (uint256) {\n        (uint32 tokenWeight0, uint32 tokenWeight1,) = requiemFactory.getWeightsAndSwapFee(pair);\n\n        if (tokenWeight0 == 50) {\n            (uint256 res0, uint256 res1,) = IRequiemPair(pair).getReserves();\n            uint reserveIn = tokenIn == pairToken0 ? res0 : res1;\n            return Babylonian\n                .sqrt(reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009)))\n                .sub(reserveIn.mul(1997)) / 1994;\n        } else {\n            uint256 otherWeight = tokenIn == pairToken0 ? uint(tokenWeight1) : uint(tokenWeight0);\n            return userIn.mul(otherWeight).div(100);\n        }\n    }\n\n    /* ========== Private Functions ========== */\n    function _getRemovedReserveAmountOut(address pair, address tokenIn, uint sellAmount, uint amountToRemoved) internal view returns (uint) {\n        (, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) =\n        requiemFormula.getFactoryReserveAndWeights(address(requiemFactory), pair, tokenIn);\n        return requiemFormula.getAmountOut(sellAmount, reserveIn.sub(sellAmount), reserveOut.sub(amountToRemoved), tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    function _approveTokenIfNeeded(address token) private {\n        if (IERC20(token).allowance(address(this), address(uniRouter)) == 0) {\n            IERC20(token).approve(address(uniRouter), type(uint).max);\n        }\n        if (IERC20(token).allowance(address(this), address(requiemRouter)) == 0) {\n            IERC20(token).approve(address(requiemRouter), type(uint).max);\n        }\n    }\n\n    function _pairDeposit(\n        address _pair,\n        address _poolToken0,\n        address _poolToken1,\n        uint256 token0Bought,\n        uint256 token1Bought,\n        address receiver,\n        bool isRequiemPair,\n        bool transferResidual\n    ) internal returns (uint256 lpAmt) {\n        _approveTokenIfNeeded(_poolToken0);\n        _approveTokenIfNeeded(_poolToken1);\n\n        uint256 amountA;\n        uint256 amountB;\n        if (isRequiemPair) {\n            (amountA, amountB, lpAmt) = requiemRouter.addLiquidity(_pair, _poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        } else {\n            (amountA, amountB, lpAmt) = uniRouter.addLiquidity(_poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        }\n\n        uint amountAResidual = token0Bought.sub(amountA);\n        if (transferResidual || amountAResidual > token0Bought.mul(maxResidual).div(10000)) {\n            if (amountAResidual > 0) {\n                //Returning Residue in token0, if any.\n                _transferToken(_poolToken0, msg.sender, amountAResidual);\n            }\n        }\n\n        uint amountBRedisual = token1Bought.sub(amountB);\n        if (transferResidual || amountBRedisual > token1Bought.mul(maxResidual).div(10000)) {\n            if (amountBRedisual > 0) {\n                //Returning Residue in token1, if any\n                _transferToken(_poolToken1, msg.sender, amountBRedisual);\n            }\n        }\n\n        return lpAmt;\n    }\n\n    function _swapETHToLp(IRequiemPair pair, uint amount, address receiver, uint _minTokenB, bool transferResidual) private returns (uint256 lpAmt) {\n        address lp = address(pair);\n\n        // Lp\n        if (pair.token0() == WETH || pair.token1() == WETH) {\n            address token = pair.token0() == WETH ? pair.token1() : pair.token0();\n            uint swapValue = calculateSwapInAmount(lp, WETH, amount, pair.token0());\n            uint tokenAmount = _swapETHForToken(token, swapValue, address(this), lp);\n            require(tokenAmount >= _minTokenB, \"Zap: Insufficient Receive Amount\");\n\n            uint256 WETHAmount = amount.sub(swapValue);\n            IWETH(WETH).deposit{value : WETHAmount}();\n            lpAmt = _pairDeposit(lp, WETH, token, WETHAmount, tokenAmount, receiver, requiemFactory.isPair(lp), transferResidual);\n        } else {\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            uint token0Amount;\n            uint token1Amount;\n            {\n                (uint32 tokenWeight0,,) = requiemFactory.getWeightsAndSwapFee(lp);\n                uint swap0Value = amount.mul(uint(tokenWeight0)).div(100);\n                token0Amount = _swapETHForToken(token0, swap0Value, address(this), address(0));\n                token1Amount = _swapETHForToken(token1, amount.sub(swap0Value), address(this), address(0));\n            }\n\n            lpAmt = _pairDeposit(lp, token0, token1, token0Amount, token1Amount, receiver, requiemFactory.isPair(lp), transferResidual);\n        }\n    }\n\n    function _swapETHForToken(address token, uint value, address _receiver, address lpBNBToken) private returns (uint) {\n        if (token == WETH) {\n            IWETH(WETH).deposit{value : value}();\n            if (_receiver != address(this)) {\n                IERC20(WETH).safeTransfer(_receiver, value);\n            }\n            return value;\n        }\n        address[] memory path = RequiemPairs[WETH][token];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else if (lpBNBToken != address(0)) {\n            path = new address[](1);\n            path[0] = lpBNBToken;\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path BNBToken\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swapTokenForBNB(address token, uint amount, address _receiver, address lpTokenBNB) private returns (uint) {\n        if (token == WETH) {\n            _transferToken(WETH, _receiver, amount);\n            return amount;\n        }\n        address[] memory path = RequiemPairs[token][WETH];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else if (lpTokenBNB != address(0)) {\n            path = new address[](1);\n            path[0] = lpTokenBNB;\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path TokenBNB\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swap(address _from, uint _amount, address _to, address _receiver, address _lpOfFromTo) internal returns (uint) {\n        if (_from == _to) {\n            if (_receiver != address(this)) {\n                IERC20(_from).safeTransfer(_receiver, _amount);\n            }\n            return _amount;\n        }\n        address[] memory path = RequiemPairs[_from][_to];\n        uint[] memory amounts;\n        if (path.length > 0) {// use requiem\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else if (_lpOfFromTo != address(0)) {\n            path = new address[](1);\n            path[0] = _lpOfFromTo;\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path swap\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _transferToken(address token, address to, uint amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token == WETH) {\n            IWETH(WETH).withdraw(amount);\n            if (to != address(this)) {\n                TransferHelper.safeTransferETH(to, amount);\n            }\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n        return;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n    function withdraw(address to) external onlyGovernance {\n        address[] memory _tokens = tokensResidual;\n        withdrawToken(_tokens, to);\n    }\n\n    function withdrawToken(address[] memory tokens, address to) public onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _withdraw(tokens[i], to);\n        }\n    }\n\n    function withdrawTokenAmount(address token, address to, uint256 amount) external onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n        IERC20(token).safeTransfer(to, amount);\n        emit Withdraw(token, amount, to);\n    }\n\n    function _withdraw(address _token, address _to) internal {\n        if (_token == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(_to, address(this).balance);\n            emit Withdraw(_token, address(this).balance, _to);\n            return;\n        }\n\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, _balance);\n        emit Withdraw(_token, _balance, _to);\n    }\n\n    function setTokensResidual(address[] memory _tokensResidual) external onlyGovernance {\n        tokensResidual = _tokensResidual;\n    }\n\n    function addTokensResidual(address _token) external onlyGovernance {\n        tokensResidual.push(_token);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n        emit LogGovernance(governance);\n    }\n\n    function setRequiemPairs(address _input, address _output, address [] memory _pair) external onlyGovernance {\n        RequiemPairs[_input][_output] = _pair;\n    }\n\n    function setMaxResidual(uint _maxResidual) external onlyGovernance {\n        maxResidual = _maxResidual;\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemRouterLite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IRequiemRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/interfaces/IRequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint);\n    function feeTo() external view returns (address);\n    function formula() external view returns (address);\n    function protocolFee() external view returns (uint);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function isPair(address) external view returns (bool);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external returns (address pair);\n    function getWeightsAndSwapFee(address pair) external view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setProtocolFee(uint) external;\n}\n"
    },
    "contracts/interfaces/IRequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPair is IRequiemERC20 {\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity >=0.5.16;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n\n    function getReserveAndWeights(address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountIn);\n\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external view returns (uint amountIn);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountOut);\n\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external view returns (uint amountOut);\n\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external view returns (bool);\n    function getReserves(address pair, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n    function mintLiquidityFee(\n        uint totalLiquidity,\n        uint112 reserve0,\n        uint112  reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112  collectedFee0,\n        uint112 collectedFee1) external view returns (uint amount);\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.10;\n\n// solhint-disable avoid-low-level-calls, reason-string\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./Babylonian.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n    uint256 private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z;\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"../interfaces/IRequiemPair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IRequiemPair(pair).price0CumulativeLast();\n        price1Cumulative = IRequiemPair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IRequiemPair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            (uint32 _tokenWeight0, uint32 _tokenWeight1) = IRequiemPair(pair).getTokenWeights();\n            uint112 mReserve0 = reserve0 * _tokenWeight1;\n            uint112 mReserve1 = reserve1 * _tokenWeight0;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(mReserve1, mReserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(mReserve0, mReserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/RequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.10;\npragma abicoder v2;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemRouter.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemRouter is IRequiemRouter {\n    using SafeMath for uint256;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemRouter {\n    event Exchange(address pair, uint256 amountOut, address output);\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n        uint256 maxPrice;\n    }\n\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) external payable returns (uint256 totalAmountOut);\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) external payable returns (uint256 totalAmountIn);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) external returns (uint256 liquidity);\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) external payable returns (uint256 liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n}\n"
    },
    "contracts/test/StakePoolRewardRebaserMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"../libraries/SafeMath.sol\";\n\n// solhint-disable state-visibility\n\ncontract StakePoolRewardRebaserMock is IStakePoolRewardRebaser {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) {\n        rate = _rate;\n    }\n    function getRebaseAmount(address, uint baseAmount) external override view returns (uint) {\n        return baseAmount.mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardRebaser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolRewardRebaser {\n    function getRebaseAmount(address rewardToken, uint baseAmount) external view returns (uint);\n}"
    },
    "contracts/StakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IEpochController.sol\";\nimport \"./interfaces/stakePool/IStakePoolEpochReward.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\n\n// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\ncontract StakePoolEpochReward is IStakePoolEpochReward {\n    using SafeMath for uint256;\n    uint256 public override version;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastSnapshotIndex;\n        uint256 rewardEarned;\n        uint256 epochTimerStart;\n    }\n\n    struct Snapshot {\n        uint256 time;\n        uint256 rewardReceived;\n        uint256 rewardPerShare;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public override epochController;\n    address public override rewardToken;\n\n    uint256 public withdrawLockupEpochs;\n    uint256 public rewardLockupEpochs;\n\n    mapping(address => UserInfo) public userInfo;\n    Snapshot[] public snapshotHistory;\n\n    address public override stakeToken;\n    address public override rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 private _unlocked = 1;\n    bool private _initialized = false;\n    uint256 public constant BLOCKS_PER_DAY = 28800;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n        Snapshot memory genesisSnapshot = Snapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\n        snapshotHistory.push(genesisSnapshot);\n    }\n\n    modifier lock() {\n        require(_unlocked == 1, \"SPER: LOCKED\");\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SPER: !timelock\");\n        _;\n    }\n\n    modifier onlyEpochController() {\n        require(msg.sender == epochController, \"SPER: !epochController\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        if (_account != address(0)) {\n            UserInfo storage user = userInfo[_account];\n            user.rewardEarned = earned(_account);\n            user.lastSnapshotIndex = latestSnapshotIndex();\n        }\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        address _rewardFund,\n        address _timelock,\n        address _epochController,\n        address _rewardToken,\n        uint256 _withdrawLockupEpochs,\n        uint256 _rewardLockupEpochs\n    ) external {\n        require(_initialized == false, \"SPER: Initialize must be false.\");\n        stakeToken = _stakeToken;\n        rewardToken = _rewardToken;\n        rewardFund = _rewardFund;\n        setEpochController(_epochController);\n        setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setEpochController(address _epochController) public override lock onlyTimeLock {\n        epochController = _epochController;\n        epoch();\n        nextEpochPoint();\n        nextEpochLength();\n        nextEpochAllocatedReward();\n    }\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) public override lock onlyTimeLock {\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: range\"); // <= 2 week\n        withdrawLockupEpochs = _withdrawLockupEpochs;\n        rewardLockupEpochs = _rewardLockupEpochs;\n    }\n\n    function allocateReward(uint256 _amount) external override lock onlyEpochController {\n        require(_amount > 0, \"SPER: Cannot allocate 0\");\n        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\n        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\n        if (balance > 0) {\n            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\n            _amount = _after.sub(_before);\n\n            // Create & add new snapshot\n            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\n            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\n\n            Snapshot memory _newSnapshot = Snapshot({time: block.number, rewardReceived: _amount, rewardPerShare: _nextRPS});\n            emit AllocateReward(block.number, _amount);\n            snapshotHistory.push(_newSnapshot);\n        }\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        if (rewardToken == _token) {\n            // do not allow to drain reward token if less than 1 week after LatestSnapshot\n            if (block.number < (getLatestSnapshot().time + (BLOCKS_PER_DAY * 7))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // =========== Epoch getters\n\n    function epoch() public view override returns (uint256) {\n        return IEpochController(epochController).epoch();\n    }\n\n    function nextEpochPoint() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochPoint();\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochLength();\n    }\n\n    function nextEpochAllocatedReward() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\n    }\n\n    // =========== Snapshot getters\n\n    function latestSnapshotIndex() public view returns (uint256) {\n        return snapshotHistory.length.sub(1);\n    }\n\n    function getLatestSnapshot() internal view returns (Snapshot memory) {\n        return snapshotHistory[latestSnapshotIndex()];\n    }\n\n    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\n        return userInfo[_account].lastSnapshotIndex;\n    }\n\n    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\n        return snapshotHistory[getLastSnapshotIndexOf(_account)];\n    }\n\n    // =========== _account getters\n\n    function rewardPerShare() public view returns (uint256) {\n        return getLatestSnapshot().rewardPerShare;\n    }\n\n    function earned(address _account) public view override returns (uint256) {\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\n        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\n\n        UserInfo memory user = userInfo[_account];\n        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\n    }\n\n    function canWithdraw(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\n    }\n\n    function canClaimReward(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\n    }\n\n    function unlockWithdrawEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\n    }\n\n    function unlockRewardEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SPER: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SPER: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        user.epochTimerStart = epoch(); // reset timer\n        user.amount = user.amount.add(_amount);\n        emit Deposit(_account, _amount);\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _epoch = epoch();\n        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, \"SPER: still in withdraw lockup\");\n        require(user.amount >= _amount, \"SPER: invalid withdraw amount\");\n        _claimReward(false);\n        balance = balance.sub(_amount);\n        user.epochTimerStart = _epoch; // reset timer\n        user.amount = user.amount.sub(_amount);\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _reward = user.rewardEarned;\n        if (_reward > 0) {\n            if (_lockChecked) {\n                uint256 _epoch = epoch();\n                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, \"SPER: still in reward lockup\");\n                user.epochTimerStart = _epoch; // reset timer\n            }\n            user.rewardEarned = 0;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\n            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\n            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\n        }\n    }\n\n    function claimReward() public override {\n        _claimReward(true);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SPER: Not allowed\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        user.rewardEarned = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\ninterface IEpochController {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// solhint-disable max-line-length\n\ninterface IStakePoolEpochReward {\n    event AllocateReward(uint256 blocktime, uint256 amount);\n    event Deposit(address indexed account, uint256 amount);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event Withdraw(address indexed account, uint256 amount);\n\n    function version() external view returns (uint256);\n\n    function stakeToken() external view returns (address);\n\n    function rewardToken() external view returns (address);\n\n    function rewardFund() external view returns (address);\n\n    function epochController() external view returns (address);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward() external view returns (uint256);\n\n    function earned(address _account) external view returns (uint256);\n\n    function unlockWithdrawEpoch(address _account) external view returns (uint256);\n\n    function unlockRewardEpoch(address _account) external view returns (uint256);\n\n    function stake(uint256) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint256) external;\n\n    function claimReward() external;\n\n    function emergencyWithdraw() external;\n\n    function setEpochController(address) external;\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\n\n    function allocateReward(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// solhint-disable max-line-length\n\ninterface IStakePoolController {\n    event MasterCreated(address indexed farm, address indexed stakeToken, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n    event ChangeGovernance(address indexed governance);\n    event SetFeeCollector(address indexed feeCollector);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n    event SetExtraFeeRate(uint256 indexed amount);\n\n    function allStakePools(uint256) external view returns (address stakePool);\n\n    function isStakePool(address contractAddress) external view returns (bool);\n\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n\n    function setStakePoolVerifier(address contractAddress, bool state) external;\n\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\n\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\n\n    function addStakePoolCreator(address contractAddress) external;\n\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n\n    function setEnableWhitelistRewardRebaser(bool value) external;\n\n    function setEnableWhitelistRewardMultiplier(bool value) external;\n\n    function allStakePoolsLength() external view returns (uint256);\n\n    function create(\n        uint256 version,\n        address stakeToken,\n        address rewardToken,\n        uint256 rewardFundAmount,\n        uint256 delayTimeLock,\n        bytes calldata data\n    ) external returns (address);\n\n    function setGovernance(address) external;\n\n    function setFeeCollector(address _address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n\n    function setExtraFeeRate(uint256 _extraFeeRate) external;\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardMultiplier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolRewardMultiplier {\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n}"
    },
    "contracts/interfaces/stakePool/IStakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolRewardFund {\n    function initialize(address _stakePool, address _timelock) external;\n\n    function safeTransfer(address _token, address _to, uint _value) external;\n}"
    },
    "contracts/StakePoolEpochRewardCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePoolEpochReward.sol\";\n\ncontract StakePoolEpochRewardCreator is IStakePoolCreator {\n    uint256 public override version = 4001;\n    struct PoolRewardInfo {\n        address epochController;\n        uint256 withdrawLockupEpochs;\n        uint256 rewardLockupEpochs;\n    }\n\n    function create() external override returns (address) {\n        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\n        //\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.initialize(pair, address(stakePoolRewardFund), address(timelock), poolRewardInfo.epochController, rewardToken, poolRewardInfo.withdrawLockupEpochs, poolRewardInfo.rewardLockupEpochs);\n    }\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolCreator {\n    function version() external returns (uint);\n\n    function create() external returns (address);\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external;\n}"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./libraries/SafeMath.sol\";\n\ncontract TimeLock {\n    using SafeMath for uint256;\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 1 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n    bool private _initialized;\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n    bool public admin_initialized;\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() {\n        admin_initialized = false;\n        _initialized = false;\n    }\n\n    function initialize(address _admin, uint256 _delay) public {\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        admin = _admin;\n        _initialized = true;\n        emit NewAdmin(admin);\n        emit NewDelay(delay);\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 _delay) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/StakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePool.sol\";\n\ncontract StakePoolCreator is IStakePoolCreator {\n    uint256 public override version = 3001;\n\n    struct PoolRewardInfo {\n        address rewardRebaser;\n        address rewardMultiplier;\n        uint256 startBlock;\n        uint256 endRewardBlock;\n        uint256 rewardPerBlock;\n        uint256 lockRewardPercent;\n        uint256 startVestingBlock;\n        uint256 endVestingBlock;\n        uint256 unstakingFrozenTime;\n    }\n\n    function create() external override returns (address) {\n        StakePool pool = new StakePool(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePool pool = StakePool(poolAddress);\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.addRewardPool(\n            rewardToken,\n            poolRewardInfo.rewardRebaser,\n            poolRewardInfo.rewardMultiplier,\n            poolRewardInfo.startBlock,\n            poolRewardInfo.endRewardBlock,\n            poolRewardInfo.rewardPerBlock,\n            poolRewardInfo.lockRewardPercent,\n            poolRewardInfo.startVestingBlock,\n            poolRewardInfo.endVestingBlock\n        );\n        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\n    }\n}\n"
    },
    "contracts/StakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\n\ncontract StakePool is IStakePool {\n    using SafeMath for uint256;\n    uint256 public override version;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        mapping(uint8 => uint256) rewardDebt;\n        mapping(uint8 => uint256) reward;\n        mapping(uint8 => uint256) accumulatedEarned; // will accumulate every time user harvest\n        mapping(uint8 => uint256) lockReward;\n        mapping(uint8 => uint256) lockRewardReleased;\n        uint256 lastStakeTime;\n    }\n\n    // Info of each rewardPool funding.\n    struct RewardPoolInfo {\n        address rewardToken; // Address of rewardPool token contract.\n        address rewardRebaser; // Address of rewardRebaser contract.\n        address rewardMultiplier; // Address of rewardMultiplier contract.\n        uint256 startRewardTime; // Start reward block number that rewardPool distribution occurs.\n        uint256 lastRewardTime; // Last block number that rewardPool distribution occurs.\n        uint256 endRewardTime; // Block time which rewardPool distribution ends.\n        uint256 rewardPerSecond; // Reward token amount to distribute per block.\n        uint256 accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n        uint256 lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n        uint256 startVestingTime; // Block time which vesting starts.\n        uint256 endVestingTime; // Block time which vesting ends.\n        uint256 vestingDuration;\n        uint256 totalPaidRewards;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n    RewardPoolInfo[] public rewardPoolInfo;\n    address public override stakeToken;\n    address public rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 public unstakingFrozenTime = 3 days;\n    uint256 private unlocked = 1;\n    bool private _initialized = false;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n    }\n\n    modifier lock() {\n        require(unlocked == 1, \"SP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SP: !timelock\");\n        _;\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\n            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n            if (rewardPool.rewardToken == _token) {\n                // do not allow to drain reward token if less than 3 days after pool ends\n                if (block.timestamp < (rewardPool.endRewardTime + (3 days))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        uint256 _unstakingFrozenTime,\n        address _rewardFund,\n        address _timelock\n    ) external override {\n        require(_initialized == false, \"SP: Initialize must be false.\");\n        require(unstakingFrozenTime <= 30 days, \"SP: unstakingFrozenTime > 30 days\");\n        stakeToken = _stakeToken;\n        unstakingFrozenTime = _unstakingFrozenTime;\n        rewardFund = _rewardFund;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external override lock onlyTimeLock {\n        require(rewardPoolInfo.length <= 16, \"SP: Reward pool length > 16\");\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        require(_startVestingTime <= _endVestingTime, \"SP: startVestingTime > endVestingTime\");\n        _startTime = (block.timestamp > _startTime) ? block.timestamp : _startTime;\n        require(_startTime < _endRewardTime, \"SP: startTime >= endRewardTime\");\n        require(_lockRewardPercent <= 100, \"SP: invalid lockRewardPercent\");\n        updateReward();\n        rewardPoolInfo.push(\n            RewardPoolInfo({\n                rewardToken: _rewardToken,\n                rewardRebaser: _rewardRebaser,\n                startRewardTime: _startTime,\n                rewardMultiplier: _rewardMultiplier,\n                lastRewardTime: _startTime,\n                endRewardTime: _endRewardTime,\n                rewardPerSecond: _rewardPerSecond,\n                accRewardPerShare: 0,\n                lockRewardPercent: _lockRewardPercent,\n                startVestingTime: _startVestingTime,\n                endVestingTime: _endVestingTime,\n                vestingDuration: _endVestingTime - _startVestingTime,\n                totalPaidRewards: 0\n            })\n        );\n        emit AddRewardPool(rewardPoolInfo.length - 1);\n    }\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardMultiplier = _rewardMultiplier;\n        updateReward(_pid);\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n    }\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardRebaser = _rewardRebaser;\n        updateReward(_pid);\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getRewardMultiplier(\n        uint8 _pid,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerSecond\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardMultiplier = rewardPool.rewardMultiplier;\n        if (rewardMultiplier == address(0)) {\n            return _to.sub(_from).mul(_rewardPerSecond);\n        }\n        return IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(rewardPool.startRewardTime, rewardPool.endRewardTime, _from, _to, _rewardPerSecond);\n    }\n\n    function getRewardRebase(\n        uint8 _pid,\n        address _rewardToken,\n        uint256 _pendingReward\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardRebaser = rewardPool.rewardRebaser;\n        if (rewardRebaser == address(0)) {\n            return _pendingReward;\n        }\n        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n    }\n\n    function getRewardPerSecond(\n        uint8 pid,\n        uint256 from,\n        uint256 to\n    ) public view returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n        uint256 rewardPerSecond = rewardPool.rewardPerSecond;\n        if (from < rewardPool.startRewardTime || from > rewardPool.endRewardTime) return 0;\n        uint256 reward = getRewardMultiplier(pid, from, to, rewardPerSecond);\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n    }\n\n    function getRewardPerSecond(uint8 pid) external view override returns (uint256) {\n        return getRewardPerSecond(pid, block.timestamp, block.timestamp + 1);\n    }\n\n    function updateRewardPool(\n        uint8 _pid,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond\n    ) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        require(block.timestamp <= rewardPool.endRewardTime && block.timestamp <= _endRewardTime, \"SP: blockTime > endRewardTime\");\n        updateReward(_pid);\n        rewardPool.endRewardTime = _endRewardTime;\n        rewardPool.rewardPerSecond = _rewardPerSecond;\n        emit UpdateRewardPool(_pid, _endRewardTime, _rewardPerSecond);\n    }\n\n    function stopRewardPool(uint8 _pid) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        updateReward(_pid);\n        rewardPool.endRewardTime = block.timestamp;\n        rewardPool.rewardPerSecond = 0;\n        emit UpdateRewardPool(_pid, rewardPool.endRewardTime, rewardPool.rewardPerSecond);\n    }\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SP: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SP: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        getAllRewards(_account);\n        user.amount = user.amount.add(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n        user.lastStakeTime = block.timestamp;\n        emit Deposit(_account, _amount);\n    }\n\n    function rewardPoolInfoLength() public view override returns (uint256) {\n        return rewardPoolInfo.length;\n    }\n\n    function unfrozenStakeTime(address _account) public view override returns (uint256) {\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"SP: invalid withdraw amount\");\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"SP: frozen\");\n        getAllRewards(msg.sender);\n        balance = balance.sub(_amount);\n        user.amount = user.amount.sub(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function getAllRewards(address _account) public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            getReward(_pid, _account);\n        }\n    }\n\n    function claimReward() external override {\n        getAllRewards(msg.sender);\n    }\n\n    function getReward(uint8 _pid, address _account) public override {\n        updateReward(_pid);\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n        uint256 _lockRewardPercent = rewardPool.lockRewardPercent;\n        if (_lockRewardPercent > 0) {\n            if (block.timestamp > rewardPool.endVestingTime) {\n                uint256 _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n                if (_unlockReward > 0) {\n                    _pendingReward = _pendingReward.add(_unlockReward);\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n                }\n            } else {\n                if (_pendingReward > 0) {\n                    uint256 _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n                    _pendingReward = _pendingReward.sub(_toLocked);\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n                }\n                uint256 _startVestingTime = rewardPool.startVestingTime;\n                if (block.timestamp > _startVestingTime) {\n                    uint256 _toReleased = user.lockReward[_pid].mul(block.timestamp.sub(_startVestingTime)).div(rewardPool.vestingDuration);\n                    uint256 _lockRewardReleased = user.lockRewardReleased[_pid];\n                    if (_toReleased > _lockRewardReleased) {\n                        uint256 _unlockReward = _toReleased.sub(_lockRewardReleased);\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n                        _pendingReward = _pendingReward.add(_unlockReward);\n                    }\n                }\n            }\n        }\n        if (_pendingReward > 0) {\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\n            uint256 reward = user.reward[_pid].add(_pendingReward);\n            user.reward[_pid] = reward;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            address rewardToken = rewardPool.rewardToken;\n            uint256 rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            if (rewardBalance > 0) {\n                user.reward[_pid] = 0;\n                uint256 rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\n                uint256 paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\n                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\n            }\n        }\n    }\n\n    function pendingReward(uint8 _pid, address _account) external view override returns (uint256) {\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime && lpSupply != 0) {\n            uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n        }\n        uint256 pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(unstakingFrozenTime == 0 || IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SP: Not allow emergencyWithdraw\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = 0;\n            user.reward[_pid] = 0;\n        }\n    }\n\n    function getUserInfo(uint8 _pid, address _account)\n        public\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 accumulatedEarned,\n            uint256 lockReward,\n            uint256 lockRewardReleased\n        )\n    {\n        UserInfo storage user = userInfo[_account];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt[_pid];\n        accumulatedEarned = user.accumulatedEarned[_pid];\n        lockReward = user.lockReward[_pid];\n        lockRewardReleased = user.lockRewardReleased[_pid];\n    }\n\n    function updateReward() public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            updateReward(_pid);\n        }\n    }\n\n    function updateReward(uint8 _pid) public override {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime) {\n            uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n            }\n            rewardPool.lastRewardTime = _endRewardTimeApplicable;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/stakePool/IStakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// solhint-disable max-line-length\n\ninterface IStakePool {\n    event Deposit(address indexed account, uint256 amount);\n    event AddRewardPool(uint256 indexed poolId);\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardTime, uint256 rewardPerSecond);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n    event Withdraw(address indexed account, uint256 amount);\n    function version() external view returns (uint);\n    function stakeToken() external view returns (address);\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external;\n\n    function stake(uint) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint) external;\n\n    function getReward(uint8 _pid, address _account) external;\n\n    function getAllRewards(address _account) external;\n    function claimReward() external;\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n    function getRewardPerSecond(uint8 pid) external view returns (uint);\n    function rewardPoolInfoLength() external view returns (uint);\n\n    function unfrozenStakeTime(address _account) external view returns (uint);\n\n    function emergencyWithdraw() external;\n\n    function updateReward() external;\n\n    function updateReward(uint8 _pid) external;\n\n    function updateRewardPool(uint8 _pid, uint256 _endRewardTime, uint256 _rewardPerSecond) external;\n    function stopRewardPool(uint8 _pid) external;\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) external view returns (uint);\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n\n    function getUserInfo(uint8 _pid, address _account) external view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased);\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external;\n}\n"
    },
    "contracts/StakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolRewardFund.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\n\ncontract StakePoolRewardFund is IStakePoolRewardFund {\n    address public stakePool;\n    address public timelock;\n    bool private _initialized;\n\n    function initialize(address _stakePool, address _timelock) external override {\n        require(_initialized == false, \"StakePoolRewardFund: already initialized\");\n        stakePool = _stakePool;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) external override {\n        require(msg.sender == stakePool, \"StakePoolRewardFund: !stakePool\");\n        TransferHelper.safeTransfer(_token, _to, _value);\n    }\n\n    function allowRecoverRewardToken(address _token) public view returns (bool){\n        return IStakePool(stakePool).allowRecoverRewardToken(_token);\n    }\n\n    function recoverAllRewardToken(\n        address _token,\n        address _to\n    ) external {\n        recoverRewardToken(_token, _to, IERC20(address(_token)).balanceOf(address(this)));\n    }\n\n    function recoverRewardToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) public {\n        require(msg.sender == timelock, \"StakePoolRewardFund: !timelock\");\n        require(allowRecoverRewardToken(_token), \"StakePoolRewardFund: not allow recover reward token\");\n        TransferHelper.safeTransfer(_token, _to, _amount);\n    }\n}\n"
    },
    "contracts/test/SimpleEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/stakePool/IStakePoolEpochReward.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\n// solhint-disable not-rely-on-time\n\ncontract SimpleEpochController is IEpochController {\n    uint256 public _epoch = 0;\n    uint256 public epochLength = 5 minutes;\n    uint256 public lastEpochTime;\n    address public allocator;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        allocator = msg.sender;\n    }\n\n    function epoch() external view override returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external view override returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        owner = _owner;\n    }\n\n    function setAllocator(address _allocator) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        allocator = _allocator;\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return epochLength;\n    }\n\n    function allocateReward(address pool) external {\n        require(msg.sender == allocator, \"SimpleEpochController: FORBIDDEN\");\n        uint256 _amount = nextEpochAllocatedReward(pool);\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        TransferHelper.safeApprove(rewardToken, pool, _amount);\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IStakePoolEpochReward(pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address pool) public view override returns (uint256) {\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/test/EpochControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/stakePool/IStakePoolEpochReward.sol\";\n\n// solhint-disable not-rely-on-time\n\ncontract EpochControllerMock is IEpochController {\n    uint256 private _epoch = 0;\n    address public rewardToken;\n    uint256 public lastEpochTime;\n\n    constructor(address _rewardToken) {\n        rewardToken = _rewardToken;\n    }\n\n    function epoch() external view override returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external view override returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function nextEpochLength() public pure override returns (uint256) {\n        return 12 hours;\n    }\n\n    function resetEpochTime() external {\n        lastEpochTime = block.timestamp;\n    }\n\n    function updateEpochTime(uint256 _lastEpochTime) external {\n        lastEpochTime = _lastEpochTime;\n    }\n\n    function allocateSeigniorage(uint256 _amount, address _pool) external {\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(rewardToken).approve(_pool, 0);\n        IERC20(rewardToken).approve(_pool, _amount);\n        IStakePoolEpochReward(_pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address) external pure override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/StakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/stakePool/IStakePoolCreator.sol\";\nimport \"./interfaces/stakePool/IStakePoolController.sol\";\nimport \"./interfaces/IIsPair.sol\";\nimport \"./interfaces/stakePool/IStakePool.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./StakePoolRewardFund.sol\";\n\ncontract StakePoolController is IStakePoolController {\n    IIsPair public swapFactory;\n    address public governance;\n\n    address public feeCollector;\n    address public feeToken;\n    uint public  feeAmount;\n\n    mapping(address => bool) private _stakePools;\n    mapping(address => bool) private _whitelistStakingFor;\n    mapping(address => bool) private _whitelistRewardRebaser;\n    mapping(address => bool) private _whitelistRewardMultiplier;\n    mapping(address => int8) private _whitelistStakePools;\n    mapping(address => bool) public _stakePoolVerifiers;\n    mapping(uint => address) public stakePoolCreators;\n    address[] public override allStakePools;\n    bool public enableWhitelistRewardRebaser = true;\n    bool public enableWhitelistRewardMultiplier = true;\n    bool private _initialized = false;\n\n    mapping(address => bool) public allowEmergencyWithdrawStakePools;\n\n    uint public extraFeeRate;\n\n    function initialize(address _swapFactory) public {\n        require(_initialized == false, \"SPC: initialized\");\n        governance = msg.sender;\n        swapFactory = IIsPair(_swapFactory);\n        _initialized = true;\n    }\n\n    function isStakePool(address b) external override view returns (bool){\n        return _stakePools[b];\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"SPC: !governance\");\n        _;\n    }\n\n    function setFeeCollector(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        feeCollector = _address;\n        emit SetFeeCollector(_address);\n    }\n    function setEnableWhitelistRewardRebaser(bool value) external onlyGovernance override {\n        enableWhitelistRewardRebaser = value;\n    }\n    function setEnableWhitelistRewardMultiplier(bool value) external onlyGovernance override {\n        enableWhitelistRewardMultiplier = value;\n    }\n    function setFeeToken(address _token) external onlyGovernance override {\n        require(_token != address(0), \"SPC: invalid _token\");\n        feeToken = _token;\n        emit SetFeeToken(_token);\n    }\n    function getCreationFee(address token) public view returns (uint) {\n        if (swapFactory.isPair(token)) {\n            return feeAmount;\n        }\n        return feeAmount * extraFeeRate / 1000;\n    }\n    function setFeeAmount(uint _feeAmount) external onlyGovernance override {\n        feeAmount = _feeAmount;\n        emit SetFeeAmount(_feeAmount);\n    }\n    function setExtraFeeRate(uint _extraFeeRate) external onlyGovernance override {\n        require(_extraFeeRate >= 1000 && _extraFeeRate <= 50000, \"SPC: invalid _extraFeeRate\");\n        extraFeeRate = _extraFeeRate;\n        emit SetExtraFeeRate(_extraFeeRate);\n    }\n    function isWhitelistStakingFor(address _address) external override view returns (bool){\n        return _whitelistStakingFor[_address];\n    }\n\n    function isWhitelistStakePool(address _address) external override view returns (int8){\n        return _whitelistStakePools[_address];\n    }\n    function isStakePoolVerifier(address _address) external override view returns (bool){\n        return _stakePoolVerifiers[_address];\n    }\n    function isAllowEmergencyWithdrawStakePool(address _address) external override view returns (bool){\n        return allowEmergencyWithdrawStakePools[_address];\n    }\n    function setWhitelistStakingFor(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistStakingFor[_address] = state;\n        emit SetWhitelistStakingFor(_address, state);\n    }\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        allowEmergencyWithdrawStakePools[_address] = state;\n    }\n\n    function setStakePoolVerifier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _stakePoolVerifiers[_address] = state;\n        emit SetStakePoolVerifier(_address, state);\n    }\n\n    function setWhitelistStakePool(address _address, int8 state) external override {\n        require(_address != address(0), \"SPC: invalid address\");\n        require(_stakePoolVerifiers[msg.sender] == true, \"SPC: invalid stake pool verifier\");\n        _whitelistStakePools[_address] = state;\n        emit SetWhitelistStakePool(_address, state);\n    }\n\n    function addStakePoolCreator(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        uint version = IStakePoolCreator(_address).version();\n        require(version >= 1000, \"Invalid stake pool creator version\");\n        stakePoolCreators[version] = _address;\n        emit SetStakePoolCreator(_address, version);\n    }\n\n    function isWhitelistRewardRebaser(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardRebaser) return true;\n        return _address == address(0) ? true : _whitelistRewardRebaser[_address];\n    }\n\n    function setWhitelistRewardRebaser(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardRebaser[_address] = state;\n        emit SetWhitelistRewardRebaser(_address, state);\n    }\n\n    function isWhitelistRewardMultiplier(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardMultiplier) return true;\n        return _address == address(0) ? true : _whitelistRewardMultiplier[_address];\n    }\n\n    function setWhitelistRewardMultiplier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardMultiplier[_address] = state;\n        emit SetWhitelistRewardMultiplier(_address, state);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance override {\n        require(_governance != address(0), \"SPC: invalid governance\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function allStakePoolsLength() external override view returns (uint) {\n        return allStakePools.length;\n    }\n    function createInternal(address stakePoolCreator, address stakeToken, address stakePoolRewardFund, address rewardToken, uint delayTimeLock, bytes calldata data) internal returns (address) {\n        TimeLock timelock = new TimeLock();\n        IStakePool pool = IStakePool(IStakePoolCreator(stakePoolCreator).create());\n        allStakePools.push(address(pool));\n        _stakePools[address(pool)] = true;\n        emit MasterCreated(address(pool), stakeToken, pool.version(), address(timelock), stakePoolRewardFund, allStakePools.length);\n        IStakePoolCreator(stakePoolCreator).initialize(address(pool), stakeToken, rewardToken, address(timelock), address(stakePoolRewardFund), data);\n        StakePoolRewardFund(stakePoolRewardFund).initialize(address(pool), address(timelock));\n        timelock.initialize(msg.sender, delayTimeLock);\n        return address(pool);\n    }\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) public override returns (address) {\n        address stakePoolCreator = stakePoolCreators[version];\n        require(stakePoolCreator != address(0), \"SPC: Invalid stake pool creator version\");\n        uint creationFee = getCreationFee(stakeToken);\n        if (feeCollector != address(0) && feeToken != address(0) && creationFee > 0) {\n            TransferHelper.safeTransferFrom(feeToken, msg.sender, feeCollector, creationFee);\n        }\n\n        StakePoolRewardFund stakePoolRewardFund = new StakePoolRewardFund();\n        if (rewardFundAmount > 0) {\n            require(IERC20(rewardToken).balanceOf(msg.sender) >= rewardFundAmount , \"SPC: Not enough rewardFundAmount\");\n            TransferHelper.safeTransferFrom(rewardToken, msg.sender, address(stakePoolRewardFund), rewardFundAmount);\n        }\n        return createInternal(stakePoolCreator, stakeToken, address(stakePoolRewardFund), rewardToken, delayTimeLock, data);\n    }\n}\n"
    },
    "contracts/interfaces/IIsPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IIsPair {\n    function isPair(address) external view returns (bool);\n}\n"
    },
    "contracts/test/RequiemFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IIsPair.sol\";\n\ncontract RequiemMock is IIsPair {\n    mapping(address => bool) public override isPair;\n\n    function setIsPair(address pair, bool val) external {\n        isPair[pair] = val;\n    }\n}\n"
    },
    "contracts/RequiemStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/Initializable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./base/OwnerPausable.sol\";\nimport \"./RequiemStableSwapLib.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemStableSwap is IRequiemSwap, OwnerPausable, ReentrancyGuard, Initializable, IRequiemStableSwap {\n    using RequiemStableSwapLib for RequiemStableSwapLib.SwapStorage;\n    using SafeERC20 for IERC20;\n\n    /// constants\n    uint256 public constant MIN_RAMP_TIME = 1 days;\n    uint256 public constant MAX_A = 1e6;\n    uint256 public constant MAX_A_CHANGE = 10;\n    uint256 public constant MAX_ADMIN_FEE = 1e10; // 100%\n    uint256 public constant MAX_SWAP_FEE = 1e8; // 1%\n    uint256 public constant MAX_WITHDRAW_FEE = 1e8; // 1%\n\n    /// STATE VARS\n    RequiemStableSwapLib.SwapStorage public swapStorage;\n    address public feeDistributor;\n    address public feeController;\n    mapping(address => uint8) public tokenIndexes;\n\n    modifier deadlineCheck(uint256 _deadline) {\n        require(block.timestamp <= _deadline, \"timeout\");\n        _;\n    }\n\n    modifier onlyFeeControllerOrOwner() {\n        require(msg.sender == feeController || msg.sender == owner(), \"!feeController\");\n        _;\n    }\n\n    function initialize(\n        address[] memory _coins,\n        uint8[] memory _decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _A,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address _feeDistributor\n    ) external onlyOwner initializer {\n        require(_coins.length == _decimals.length, \"coinsL != decimalsL\");\n        require(_feeDistributor != address(0), \"feeDistributor = empty\");\n        uint256 numberOfCoins = _coins.length;\n        uint256[] memory rates = new uint256[](numberOfCoins);\n        IERC20[] memory coins = new IERC20[](numberOfCoins);\n        for (uint256 i = 0; i < numberOfCoins; i++) {\n            require(_coins[i] != address(0), \"invalidTokenAddress\");\n            require(_decimals[i] <= RequiemStableSwapLib.POOL_TOKEN_COMMON_DECIMALS, \"invalidDecimals\");\n            rates[i] = 10**(RequiemStableSwapLib.POOL_TOKEN_COMMON_DECIMALS - _decimals[i]);\n            coins[i] = IERC20(_coins[i]);\n            tokenIndexes[address(coins[i])] = uint8(i);\n        }\n\n        require(_A < MAX_A, \"> maxA\");\n        require(_fee <= MAX_SWAP_FEE, \"> maxSFee\");\n        require(_adminFee <= MAX_ADMIN_FEE, \"> maxAFee\");\n        require(_withdrawFee <= MAX_WITHDRAW_FEE, \"> maxWFee\");\n\n        swapStorage.lpToken = new LPToken(lpTokenName, lpTokenSymbol);\n        swapStorage.balances = new uint256[](numberOfCoins);\n        swapStorage.tokenMultipliers = rates;\n        swapStorage.pooledTokens = coins;\n        swapStorage.initialA = _A * RequiemStableSwapLib.A_PRECISION;\n        swapStorage.futureA = _A * RequiemStableSwapLib.A_PRECISION;\n        swapStorage.fee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n        feeDistributor = _feeDistributor;\n    }\n\n    /// PUBLIC FUNCTIONS\n    function addLiquidity(\n        uint256[] memory amounts,\n        uint256 minMintAmount,\n        uint256 deadline\n    ) external override whenNotPaused nonReentrant deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.addLiquidity(amounts, minMintAmount);\n    }\n\n    // standard swap function a la curve\n    // just the to parameter is added to be more flexible\n    function swap(\n        uint8 fromIndex,\n        uint8 toIndex,\n        uint256 inAmount,\n        uint256 minOutAmount,\n        address to,\n        uint256 deadline\n    ) external override whenNotPaused nonReentrant deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.swap(fromIndex, toIndex, inAmount, minOutAmount, to);\n    }\n\n    // function for the requiem swap interface\n    // recalculates the output amount from the input\n    // has no check for slippage, that should be wrapped arount that funtion if used\n    // calculation-wise not really less efficient than just validating input amounts\n    // since the invariant would have to be calculated twice\n    function onSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256,\n        address to\n    ) external override whenNotPaused nonReentrant {\n        // swapStorage._swap(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn, amountOut, to);\n        swapStorage.onSwapGivenIn(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn, 0, to);\n    }\n\n    // expects amount alrady to be sent to this address\n    // calculates the output amount and sends it after deducting the fee\n    function onSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external override whenNotPaused nonReentrant returns (uint256) {\n        return swapStorage.onSwapGivenIn(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn, amountOutMin, to);\n    }\n\n    // calculates the input amount from a given output amount\n    // will transfer amounts to itself as input is not yet known\n    function onSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) external override whenNotPaused nonReentrant returns (uint256) {\n        return swapStorage.onSwapGivenOut(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountOut, amountInMax, to);\n    }\n\n    function removeLiquidity(\n        uint256 lpAmount,\n        uint256[] memory minAmounts,\n        uint256 deadline\n    ) external override nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(lpAmount, minAmounts);\n    }\n\n    function removeLiquidityOneToken(\n        uint256 lpAmount,\n        uint8 index,\n        uint256 minAmount,\n        uint256 deadline\n    ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.removeLiquidityOneToken(lpAmount, index, minAmount);\n    }\n\n    function removeLiquidityImbalance(\n        uint256[] memory amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /// VIEW FUNCTIONS\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    function getA() external view override returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    function getAPrecise() external view override returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    function getTokens() external view override returns (IERC20[] memory) {\n        return swapStorage.pooledTokens;\n    }\n\n    function getToken(uint8 index) external view override returns (IERC20) {\n        return swapStorage.pooledTokens[index];\n    }\n\n    function getLpToken() external view override returns (IERC20) {\n        return swapStorage.lpToken;\n    }\n\n    function getTokenIndex(address token) external view override returns (uint8 index) {\n        index = tokenIndexes[token];\n        require(address(swapStorage.pooledTokens[index]) == token, \"tokenNotFound\");\n    }\n\n    function getTokenPrecisionMultipliers() external view returns (uint256[] memory) {\n        return swapStorage.tokenMultipliers;\n    }\n\n    function getTokenBalances() external view override returns (uint256[] memory) {\n        return swapStorage.balances;\n    }\n\n    function getTokenBalance(uint8 index) external view override returns (uint256) {\n        return swapStorage.balances[index];\n    }\n\n    function getNumberOfTokens() external view override returns (uint256) {\n        return swapStorage.pooledTokens.length;\n    }\n\n    function getAdminBalances() external view override returns (uint256[] memory adminBalances) {\n        uint256 length = swapStorage.pooledTokens.length;\n        adminBalances = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            adminBalances[i] = swapStorage.getAdminBalance(i);\n        }\n    }\n\n    function getAdminBalance(uint8 index) external view override returns (uint256) {\n        return swapStorage.getAdminBalance((index));\n    }\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view override returns (uint256) {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    function calculateSwap(\n        uint8 inIndex,\n        uint8 outIndex,\n        uint256 inAmount\n    ) external view override returns (uint256) {\n        return swapStorage.calculateSwap(inIndex, outIndex, inAmount);\n    }\n\n    // calculates output amount for given input\n    function calculateSwapGivenIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountIn);\n    }\n\n    // calculates input amount for given output\n    function calculateSwapGivenOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut\n    ) external view returns (uint256) {\n        return swapStorage.calculateSwapGivenOut(tokenIndexes[tokenIn], tokenIndexes[tokenOut], amountOut);\n    }\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view override returns (uint256[] memory) {\n        return swapStorage.calculateRemoveLiquidity(account, amount);\n    }\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 amount,\n        uint8 index\n    ) external view override returns (uint256) {\n        return swapStorage.calculateRemoveLiquidityOneToken(account, amount, index);\n    }\n\n    function calculateCurrentWithdrawFee(address account) external view override returns (uint256) {\n        return swapStorage._calculateCurrentWithdrawFee(account);\n    }\n\n    /// RESTRICTED FUNCTION\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external override {\n        require(msg.sender == address(swapStorage.lpToken), \"!lpToken\");\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * swap fee cannot be higher than 1% of each swap\n     * @param newSwapFee new swap fee to be applied on future transactions\n     * @param newAdminFee new admin fee to be applied on future transactions\n     * @param newWithdrawFee new initial withdraw fee to be applied on future withdrawal transactions\n     */\n    function setFee(\n        uint256 newSwapFee,\n        uint256 newAdminFee,\n        uint256 newWithdrawFee\n    ) external onlyOwner {\n        require(newSwapFee <= MAX_SWAP_FEE, \"> SFee\");\n        require(newAdminFee <= MAX_ADMIN_FEE, \"> AFee\");\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"> WFee\");\n        swapStorage.adminFee = newAdminFee;\n        swapStorage.fee = newSwapFee;\n        swapStorage.defaultWithdrawFee = newWithdrawFee;\n\n        emit NewFee(newSwapFee, newAdminFee, newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureATime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureATime) external onlyOwner {\n        require(block.timestamp >= swapStorage.initialATime + (1 days), \"< rampD\"); // please wait 1 days before start a new ramping\n        require(futureATime >= block.timestamp + (MIN_RAMP_TIME), \"< minRampT\");\n        require(0 < futureA && futureA < MAX_A, \"outOfRange\");\n\n        uint256 initialAPrecise = swapStorage.getAPrecise();\n        uint256 futureAPrecise = futureA * RequiemStableSwapLib.A_PRECISION;\n\n        if (futureAPrecise < initialAPrecise) {\n            require(futureAPrecise * (MAX_A_CHANGE) >= initialAPrecise, \"> maxC\");\n        } else {\n            require(futureAPrecise <= initialAPrecise * (MAX_A_CHANGE), \"> maxC\");\n        }\n\n        swapStorage.initialA = initialAPrecise;\n        swapStorage.futureA = futureAPrecise;\n        swapStorage.initialATime = block.timestamp;\n        swapStorage.futureATime = futureATime;\n\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureATime);\n    }\n\n    function stopRampA() external onlyOwner {\n        require(swapStorage.futureATime > block.timestamp, \"alreadyStopped\");\n        uint256 currentA = swapStorage.getAPrecise();\n\n        swapStorage.initialA = currentA;\n        swapStorage.futureA = currentA;\n        swapStorage.initialATime = block.timestamp;\n        swapStorage.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n\n    function setFeeController(address _feeController) external onlyOwner {\n        require(_feeController != address(0), \"zero\");\n        feeController = _feeController;\n        emit FeeControllerChanged(_feeController);\n    }\n\n    function setFeeDistributor(address _feeDistributor) external onlyOwner {\n        require(_feeDistributor != address(0), \"zero\");\n        feeDistributor = _feeDistributor;\n        emit FeeDistributorChanged(_feeDistributor);\n    }\n\n    function withdrawAdminFee() external onlyFeeControllerOrOwner {\n        for (uint256 i = 0; i < swapStorage.pooledTokens.length; i++) {\n            IERC20 token = swapStorage.pooledTokens[i];\n            uint256 balance = token.balanceOf(address(this)) - (swapStorage.balances[i]);\n            if (balance != 0) {\n                token.safeTransfer(feeDistributor, balance);\n                emit CollectProtocolFee(address(token), balance);\n            }\n        }\n    }\n}\n"
    },
    "contracts/RequiemQRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.10;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemQRouter.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemQRouter is IRequiemQRouter {\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    // the onSwap functions are designed to include the stable swap\n    // it currenty only allows exactIn structures\n    function onSwapExactTokensForTokens(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to,\n        uint256 deadline\n    ) public virtual ensure(deadline) returns (uint256 amountLast) {\n        amountLast = amountIn;\n        TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amountIn);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? to : pools[i + 1];\n            amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(tokens[i], tokens[i + 1], amountLast, 0, _to);\n        }\n        require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n    }\n\n    function onSwapExactETHForTokens(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountOutMin,\n        address to,\n        uint256 deadline\n    ) external payable virtual ensure(deadline) returns (uint256 amountLast) {\n        amountLast = msg.value;\n        transferETHTo(msg.value, pools[0]);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? to : pools[i + 1];\n            amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(tokens[i], tokens[i + 1], amountLast, 0, _to);\n        }\n        require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n    }\n\n    function onSwapExactTokensForETH(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountLast) {\n        amountLast = amountIn;\n        TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amountIn);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? address(this) : pools[i + 1];\n            amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(tokens[i], tokens[i + 1], amountLast, 0, _to);\n        }\n        require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n        transferAll(ETH_ADDRESS, to, amountLast);\n    }\n\n    // direct swap function for given exact output\n    function onSwapTokensForExactTokens(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256[] memory amounts) {\n        // set amount array\n        amounts = new uint256[](tokens.length);\n        amounts[pools.length] = amountOut;\n\n        // calculate all amounts to be sent and recieved\n        for (uint256 i = amounts.length - 1; i > 0; i--) {\n            amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(tokens[i - 1], tokens[i], amounts[i]);\n        }\n\n        // check input condition\n        require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT\");\n\n        // tranfer amounts\n        TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amounts[0]);\n\n        // use general swap functions that do not execute the full calculation to save gas\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? to : pools[i + 1];\n            IRequiemSwap(pools[i]).onSwap(tokens[i], tokens[i + 1], amounts[i], amounts[i + 1], _to);\n        }\n    }\n\n    function onSwapETHForExactTokens(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountOut,\n        address to,\n        uint256 deadline\n    ) external payable virtual ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = new uint256[](tokens.length);\n        amounts[pools.length] = amountOut;\n        for (uint256 i = amounts.length - 1; i > 0; i--) {\n            amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(tokens[i - 1], tokens[i], amounts[i]);\n        }\n\n        require(amounts[0] <= msg.value, \"EXCESSIVE_INPUT\");\n\n        transferETHTo(amounts[0], pools[0]);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? to : pools[i + 1];\n            IRequiemSwap(pools[i]).onSwap(tokens[i], tokens[i + 1], amounts[i], amounts[i + 1], _to);\n        }\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    function onSwapTokensForExactETH(\n        address[] memory pools,\n        address[] memory tokens,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = new uint256[](tokens.length);\n        amounts[pools.length] = amountOut;\n        for (uint256 i = amounts.length - 1; i > 0; i--) {\n            amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(tokens[i - 1], tokens[i], amounts[i]);\n        }\n\n        require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT\");\n        TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amounts[0]);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address _to = i == pools.length - 1 ? address(this) : pools[i + 1];\n            IRequiemSwap(pools[i]).onSwap(tokens[i], tokens[i + 1], amounts[i], amounts[i + 1], _to);\n        }\n\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            tokenAmountOut += totalAmountOut;\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender) - balanceBefore >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn += tokenAmountInFirstSwap;\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool) - reserveInput;\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _calculateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    // the same as _validateAmountIn, just with no requirement checking\n    function _calculateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemQRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemQRouter {\n    event Exchange(address pair, uint256 amountOut, address output);\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n        uint256 maxPrice;\n    }\n\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) external payable returns (uint256 totalAmountOut);\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) external payable returns (uint256 totalAmountIn);\n}\n"
    },
    "contracts/RequiemQPairManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.10;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemQPairManager.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemQPairManager is IRequiemQPairManager {\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n     // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemQPairManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemQPairManager {\n    event Exchange(address pair, uint256 amountOut, address output);\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n        uint256 maxPrice;\n    }\n\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) external returns (uint256 liquidity);\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) external payable returns (uint256 liquidity);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n}\n"
    },
    "contracts/RequiemFormulaTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./libraries/SafeMath.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string, no-unused-vars\n\ncontract RequiemFormulaTest is IRequiemFormula {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE = 1;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\n\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n    uint256[128] private maxExpArray;\n\n    function initMaxExpArray() public {\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    constructor() {\n        initMaxExpArray();\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) public view returns (uint256, uint8) {\n        require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) public pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count;\n            // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1;\n                // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1;\n                    // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) public pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) public view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) public pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n        // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\n        // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n        // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\n        // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000;\n        // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\n        // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n        // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000;\n        // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\n        // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n        // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\n        // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000;\n        // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000;\n        // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000;\n        // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000;\n        // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000;\n        // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000;\n        // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000;\n        // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000;\n        // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000;\n        // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000;\n        // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000;\n        // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00;\n        // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00;\n        // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900;\n        // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00;\n        // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340;\n        // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40;\n        // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0;\n        // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420;\n        // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021;\n        // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001;\n        // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n     * Auto-generated via \"PrintFunctionOptimalLog.py\"\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) public pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        }\n        // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        }\n        // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        }\n        // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        }\n        // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        }\n        // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        }\n        // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        }\n        // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        }\n        // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^01 / 01 - y^02 / 02\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^03 / 03 - y^04 / 04\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^05 / 05 - y^06 / 06\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^07 / 07 - y^08 / 08\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^09 / 09 - y^10 / 10\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^11 / 11 - y^12 / 12\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^13 / 13 - y^14 / 14\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via \"PrintFunctionOptimalExp.py\"\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) public pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000;\n        // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000;\n        // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000;\n        // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000;\n        // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000;\n        // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000;\n        // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800;\n        // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800;\n        // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00;\n        // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400;\n        // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300;\n        // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00;\n        // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480;\n        // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380;\n        // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638;\n        // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8;\n        // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c;\n        // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014;\n        // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001;\n        // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea;\n        // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n        // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function getReserveAndWeights(address pair, address tokenA)\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    function getFactoryReserveAndWeights(\n        address factory,\n        address pair,\n        address tokenA\n    )\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(factory, pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    /**\n     * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n     *\n     * Formula:\n     * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n     *\n     * @param amountIn                  source reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountOut\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountOut) {\n        // validate input\n        require(amountIn > 0, \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(10000 - swapFee);\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            return reserveOut.mul(amountInWithFee) / (reserveIn.mul(10000).add(amountInWithFee));\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = reserveIn.mul(10000).add(amountInWithFee);\n        (result, precision) = power(baseN, reserveIn.mul(10000), tokenWeightIn, tokenWeightOut);\n\n        uint256 temp1 = reserveOut.mul(result);\n        uint256 temp2 = reserveOut << precision;\n        amountOut = (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     *\n     * Formula:\n     * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n     *\n     * @param amountOut     target reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountIn\n     */\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountIn) {\n        // validate input\n        require(amountOut > 0, \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            uint256 numerator = reserveIn.mul(amountOut).mul(10000);\n            uint256 denominator = reserveOut.sub(amountOut).mul(10000 - swapFee);\n            return (numerator / denominator).add(1);\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = reserveOut.sub(amountOut);\n        (result, precision) = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n        uint256 baseReserveIn = reserveIn.mul(10000);\n        uint256 temp1 = baseReserveIn.mul(result);\n        uint256 temp2 = baseReserveIn << precision;\n        amountIn = (((temp1 - temp2) >> precision) / (10000 - swapFee)).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i],\n                currentTokenIn\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getPairAmountOut(\n        address pair,\n        address tokenIn,\n        uint256 amountIn\n    ) external view override returns (uint256 amountOut) {\n        (, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountOut = getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i - 1],\n                currentTokenIn\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getPairAmountIn(\n        address pair,\n        address tokenIn,\n        uint256 amountOut\n    ) external view override returns (uint256 amountIn) {\n        (, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountIn = getAmountIn(amountOut, reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        try IRequiemPair(pair).getTokenWeights() returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n            return (_tokenWeight0, _tokenWeight1, IRequiemPair(pair).getSwapFee());\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (\n            bytes memory /*lowLevelData*/\n        ) {\n            return (50, 50, 30);\n        }\n    }\n\n    function getFactoryWeightsAndSwapFee(address factory, address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        return IRequiemFactory(factory).getWeightsAndSwapFee(pair);\n    }\n\n    // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n    //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n    //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n    function ensureConstantValue(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 balance0Adjusted,\n        uint256 balance1Adjusted,\n        uint32 tokenWeight0\n    ) external view override returns (bool) {\n        if (tokenWeight0 == 50) {\n            return balance0Adjusted.mul(balance1Adjusted) >= reserve0.mul(reserve1);\n        }\n        if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n            return true;\n        }\n        if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n            return false;\n        }\n        uint32 w0 = tokenWeight0;\n        uint32 w1 = 100 - w0;\n\n        uint256 r0;\n        uint256 p0;\n        uint256 r1;\n        uint256 p1;\n        if (balance0Adjusted >= reserve0) {\n            (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n            (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n        } else {\n            (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n            (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n        }\n        uint256 minP = p0 < p1 ? p0 : p1;\n        p0 = p0 - minP;\n        p1 = p1 - minP;\n        return (r0 >> p0) <= (r1 >> p1);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\n        require(tokenA != tokenB, \"RequiemFormula: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"RequiemFormula: ZERO_ADDRESS\");\n    }\n\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        require(token0 == IRequiemPair(pair).token0() && token1 == IRequiemPair(pair).token1(), \"RequiemFormula: Invalid token\");\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function getOtherToken(address pair, address tokenA) external view override returns (address tokenB) {\n        address token0 = IRequiemPair(pair).token0();\n        address token1 = IRequiemPair(pair).token1();\n        require(token0 == tokenA || token1 == tokenA, \"RequiemFormula: Invalid tokenA\");\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure override returns (uint256 amountB) {\n        require(amountA > 0, \"RequiemFormula: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    function mintLiquidityFee(\n        uint256 totalLiquidity,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112 collectedFee0,\n        uint112 collectedFee1\n    ) external view override returns (uint256 amount) {\n        if (collectedFee0 > 0) {\n            (uint256 r0, uint256 p0) = power(uint256(collectedFee0).add(reserve0), reserve0, tokenWeight0, 100);\n            amount = amount.add(totalLiquidity.mul(r0) >> p0).sub(totalLiquidity);\n        }\n        if (collectedFee1 > 0) {\n            (uint256 r1, uint256 p1) = power(uint256(collectedFee1).add(reserve1), reserve1, tokenWeight1, 100);\n            amount = amount.add(totalLiquidity.mul(r1) >> p1).sub(totalLiquidity);\n        }\n    }\n}\n"
    },
    "contracts/RequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.10;\n\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string, no-unused-vars\n\ncontract RequiemFormula is IRequiemFormula {\n\n    uint256 private constant ONE = 1;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\n\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n    uint256[128] private maxExpArray;\n\n    function initMaxExpArray() internal {\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    constructor() {\n        initMaxExpArray();\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count;\n            // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1;\n                // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1;\n                    // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n        // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\n        // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n        // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\n        // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000;\n        // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\n        // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n        // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000;\n        // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\n        // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n        // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\n        // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000;\n        // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000;\n        // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000;\n        // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000;\n        // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000;\n        // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000;\n        // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000;\n        // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000;\n        // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000;\n        // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000;\n        // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000;\n        // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00;\n        // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00;\n        // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900;\n        // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00;\n        // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340;\n        // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40;\n        // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0;\n        // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420;\n        // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021;\n        // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001;\n        // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n     * Auto-generated via \"PrintFunctionOptimalLog.py\"\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        }\n        // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        }\n        // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        }\n        // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        }\n        // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        }\n        // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        }\n        // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        }\n        // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        }\n        // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^01 / 01 - y^02 / 02\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^03 / 03 - y^04 / 04\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^05 / 05 - y^06 / 06\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^07 / 07 - y^08 / 08\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^09 / 09 - y^10 / 10\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^11 / 11 - y^12 / 12\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^13 / 13 - y^14 / 14\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via \"PrintFunctionOptimalExp.py\"\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000;\n        // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000;\n        // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000;\n        // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000;\n        // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000;\n        // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000;\n        // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800;\n        // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800;\n        // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00;\n        // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400;\n        // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300;\n        // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00;\n        // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480;\n        // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380;\n        // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638;\n        // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8;\n        // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c;\n        // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014;\n        // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001;\n        // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea;\n        // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n        // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function getReserveAndWeights(address pair, address tokenA)\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    function getFactoryReserveAndWeights(\n        address factory,\n        address pair,\n        address tokenA\n    )\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(factory, pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    /**\n     * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n     *\n     * Formula:\n     * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n     *\n     * @param amountIn                  source reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountOut\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountOut) {\n        // validate input\n        require(amountIn > 0, \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn * (10000 - swapFee);\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            return reserveOut * amountInWithFee / (reserveIn * 10000 + amountInWithFee);\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = reserveIn * 10000 + amountInWithFee;\n        (result, precision) = power(baseN, reserveIn * 10000, tokenWeightIn, tokenWeightOut);\n\n        uint256 temp1 = reserveOut * result;\n        uint256 temp2 = reserveOut << precision;\n        amountOut = (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     *\n     * Formula:\n     * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n     *\n     * @param amountOut     target reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountIn\n     */\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountIn) {\n        // validate input\n        require(amountOut > 0, \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            uint256 numerator = reserveIn * amountOut * 10000;\n            uint256 denominator = (reserveOut - amountOut) * (10000 - swapFee);\n            return numerator / denominator + 1;\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = reserveOut - amountOut;\n        (result, precision) = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n        uint256 baseReserveIn = reserveIn - 10000;\n        uint256 temp1 = baseReserveIn - result;\n        uint256 temp2 = baseReserveIn << precision;\n        amountIn = ((temp1 - temp2) >> precision) / (10000 - swapFee) + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i],\n                currentTokenIn\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getPairAmountOut(\n        address pair,\n        address tokenIn,\n        uint256 amountIn\n    ) external view override returns (uint256 amountOut) {\n        (, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountOut = getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i - 1],\n                currentTokenIn\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getPairAmountIn(\n        address pair,\n        address tokenIn,\n        uint256 amountOut\n    ) external view override returns (uint256 amountIn) {\n        (, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountIn = getAmountIn(amountOut, reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        try IRequiemPair(pair).getTokenWeights() returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n            return (_tokenWeight0, _tokenWeight1, IRequiemPair(pair).getSwapFee());\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (\n            bytes memory /*lowLevelData*/\n        ) {\n            return (50, 50, 30);\n        }\n    }\n\n    function getFactoryWeightsAndSwapFee(address factory, address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        return IRequiemFactory(factory).getWeightsAndSwapFee(pair);\n    }\n\n    // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n    //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n    //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n    function ensureConstantValue(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 balance0Adjusted,\n        uint256 balance1Adjusted,\n        uint32 tokenWeight0\n    ) external view override returns (bool) {\n        if (tokenWeight0 == 50) {\n            return balance0Adjusted*balance1Adjusted >= reserve0*reserve1;\n        }\n        if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n            return true;\n        }\n        if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n            return false;\n        }\n        uint32 w0 = tokenWeight0;\n        uint32 w1 = 100 - w0;\n\n        uint256 r0;\n        uint256 p0;\n        uint256 r1;\n        uint256 p1;\n        if (balance0Adjusted >= reserve0) {\n            (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n            (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n        } else {\n            (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n            (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n        }\n        uint256 minP = p0 < p1 ? p0 : p1;\n        p0 = p0 - minP;\n        p1 = p1 - minP;\n        return (r0 >> p0) <= (r1 >> p1);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\n        require(tokenA != tokenB, \"RequiemFormula: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"RequiemFormula: ZERO_ADDRESS\");\n    }\n\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        require(token0 == IRequiemPair(pair).token0() && token1 == IRequiemPair(pair).token1(), \"RequiemFormula: Invalid token\");\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function getOtherToken(address pair, address tokenA) external view override returns (address tokenB) {\n        address token0 = IRequiemPair(pair).token0();\n        address token1 = IRequiemPair(pair).token1();\n        require(token0 == tokenA || token1 == tokenA, \"RequiemFormula: Invalid tokenA\");\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure override returns (uint256 amountB) {\n        require(amountA > 0, \"RequiemFormula: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    function mintLiquidityFee(\n        uint256 totalLiquidity,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112 collectedFee0,\n        uint112 collectedFee1\n    ) external view override returns (uint256 amount) {\n        if (collectedFee0 > 0) {\n            (uint256 r0, uint256 p0) = power(uint256(collectedFee0) + reserve0, reserve0, tokenWeight0, 100);\n            amount = amount + ((totalLiquidity * r0) >> p0) - totalLiquidity;\n        }\n        if (collectedFee1 > 0) {\n            (uint256 r1, uint256 p1) = power(uint256(collectedFee1) + reserve1, reserve1, tokenWeight1, 100);\n            amount = amount + ((totalLiquidity  * r1) >> p1) - totalLiquidity;\n        }\n    }\n}\n"
    },
    "contracts/RequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./RequiemERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IUniswapV2Callee.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string, avoid-low-level-calls\n\ncontract RequiemPair is IRequiemSwap, IRequiemPair, RequiemERC20 {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 private unlocked = 1;\n    address public formula;\n\n    uint112 private collectedFee0; // uses single storage slot, accessible via getReserves\n    uint112 private collectedFee1; // uses single storage slot, accessible via getReserves\n\n    uint32 private tokenWeight0;\n    uint32 private tokenWeight1;\n    uint32 private swapFee;\n\n    modifier lock() {\n        require(unlocked == 1, \"REQLP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function getCollectedFees() public view returns (uint112 _collectedFee0, uint112 _collectedFee1) {\n        _collectedFee0 = collectedFee0;\n        _collectedFee1 = collectedFee1;\n    }\n\n    function getTokenWeights() public view returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n        _tokenWeight0 = tokenWeight0;\n        _tokenWeight1 = tokenWeight1;\n    }\n\n    function getSwapFee() public view returns (uint32 _swapFee) {\n        _swapFee = swapFee;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"REQLP: TRANSFER_FAILED\");\n    }\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _token0,\n        address _token1,\n        uint32 _tokenWeight0,\n        uint32 _swapFee\n    ) external {\n        require(msg.sender == factory, \"REQLP: FORBIDDEN\");\n        // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        tokenWeight0 = _tokenWeight0;\n        tokenWeight1 = 100 - tokenWeight0;\n        swapFee = _swapFee;\n        formula = IRequiemFactory(factory).formula();\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        uint32 _tokenWeight0 = tokenWeight0;\n        require(balance0 * (100 - _tokenWeight0) <= type(uint112).max && balance1 * _tokenWeight0 <= type(uint112).max, \"REQLP: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            uint112 mReserve0 = _reserve0 * (100 - _tokenWeight0);\n            uint112 mReserve1 = _reserve1 * _tokenWeight0;\n            price0CumulativeLast += uint256(UQ112x112.encode(mReserve1).uqdiv(mReserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(mReserve0).uqdiv(mReserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IRequiemFactory(factory).feeTo();\n        uint112 protocolFee = uint112(IRequiemFactory(factory).protocolFee());\n        feeOn = feeTo != address(0);\n        (uint112 _collectedFee0, uint112 _collectedFee1) = getCollectedFees();\n        if (protocolFee > 0 && feeOn && (_collectedFee0 > 0 || _collectedFee1 > 0)) {\n            uint32 _tokenWeight0 = tokenWeight0;\n            uint256 liquidity = IRequiemFormula(formula).mintLiquidityFee(\n                totalSupply,\n                _reserve0,\n                _reserve1,\n                _tokenWeight0,\n                100 - _tokenWeight0,\n                _collectedFee0 / protocolFee,\n                _collectedFee1 / protocolFee\n            );\n            if (liquidity > 0) _mint(feeTo, liquidity);\n        }\n        if (_collectedFee0 > 0) collectedFee0 = 0;\n        if (_collectedFee1 > 0) collectedFee1 = 0;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n        _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply;\n        // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n        _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n        require(amount0Out > 0 || amount1Out > 0, \"REQLP: INSUFFICIENT_OUTPUT_AMOUNT\");\n        uint112 _reserve0 = reserve0; // gas savings\n        uint112 _reserve1 = reserve1; // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"REQLP: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"REQLP: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(10000);\n            uint256 balance1Adjusted = balance1.mul(10000);\n            {\n                // avoids stack too deep errors\n                if (amount0In > 0) {\n                    uint256 amount0InFee = amount0In.mul(swapFee);\n                    balance0Adjusted = balance0Adjusted.sub(amount0InFee);\n                    collectedFee0 = uint112(uint256(collectedFee0).add(amount0InFee));\n                }\n                if (amount1In > 0) {\n                    uint256 amount1InFee = amount1In.mul(swapFee);\n                    balance1Adjusted = balance1Adjusted.sub(amount1InFee);\n                    collectedFee1 = uint112(uint256(collectedFee1).add(amount1InFee));\n                }\n                uint32 _tokenWeight0 = tokenWeight0; // gas savings\n                if (_tokenWeight0 == 50) {\n                    // gas savings for pair 50/50\n                    require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(10000**2), \"REQLP: K\");\n                } else {\n                    require(IRequiemFormula(formula).ensureConstantValue(uint256(_reserve0).mul(10000), uint256(_reserve1).mul(10000), balance0Adjusted, balance1Adjusted, _tokenWeight0), \"REQLP: K\");\n                }\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    //\n    function calculateSwapGivenIn(\n        address tokenIn,\n        address,\n        uint256 amountIn\n    ) external view returns (uint256) {\n        (uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut) = tokenIn == token0\n            ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n            : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n        return IRequiemFormula(formula).getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    function calculateSwapGivenOut(\n        address tokenIn,\n        address,\n        uint256 amountOut\n    ) external view returns (uint256) {\n        (uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut) = tokenIn == token0\n            ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n            : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n        return IRequiemFormula(formula).getAmountIn(amountOut, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    // calculates output amount for given input and executes the respective trade\n    // viable for use in multi swaps as it returns the output value\n    // requires the amount in to be sent to this address beforehand\n    function onSwapGivenIn(\n        address tokenIn,\n        address,\n        uint256 amountIn,\n        uint256,\n        address to\n    ) external override lock returns (uint256) {\n        bool inToken0 = tokenIn == token0;\n        (uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut) = inToken0\n            ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n            : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n        uint256 amountOut = IRequiemFormula(formula).getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n        (uint256 amount0Out, uint256 amount1Out) = inToken0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n        return _swap(amount0Out, amount1Out, to);\n    }\n\n    // calculates input amount for given output and executes the respective trade\n    // calling this one only makes sense if a single trade is supposd to be executed in the tx\n    // requires the amount in to be sent to this address beforehand\n    function onSwapGivenOut(\n        address tokenIn,\n        address,\n        uint256 amountOut,\n        uint256,\n        address to\n    ) external override lock returns (uint256) {\n        bool inToken0 = tokenIn == token0;\n        (uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut) = tokenIn == token0\n            ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n            : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n        uint256 amountIn = IRequiemFormula(formula).getAmountIn(amountOut, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n        (uint256 amount0Out, uint256 amount1Out) = inToken0 ? (uint256(0), amountIn) : (amountIn, uint256(0));\n        return _swap(amount0Out, amount1Out, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function _swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to\n    ) internal returns (uint256) {\n        require(amount0Out > 0 || amount1Out > 0, \"REQLP: INSUFFICIENT_OUTPUT_AMOUNT\");\n        uint112 _reserve0 = reserve0; // gas savings\n        uint112 _reserve1 = reserve1; // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"REQLP: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"REQLP: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(10000);\n            uint256 balance1Adjusted = balance1.mul(10000);\n            {\n                // avoids stack too deep errors\n                if (amount0In > 0) {\n                    uint256 amount0InFee = amount0In.mul(swapFee);\n                    balance0Adjusted = balance0Adjusted.sub(amount0InFee);\n                    collectedFee0 = uint112(uint256(collectedFee0).add(amount0InFee));\n                }\n                if (amount1In > 0) {\n                    uint256 amount1InFee = amount1In.mul(swapFee);\n                    balance1Adjusted = balance1Adjusted.sub(amount1InFee);\n                    collectedFee1 = uint112(uint256(collectedFee1).add(amount1InFee));\n                }\n                uint32 _tokenWeight0 = tokenWeight0; // gas savings\n                if (_tokenWeight0 == 50) {\n                    // gas savings for pair 50/50\n                    require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(10000**2), \"REQLP: K\");\n                } else {\n                    require(IRequiemFormula(formula).ensureConstantValue(uint256(_reserve0).mul(10000), uint256(_reserve1).mul(10000), balance0Adjusted, balance1Adjusted, _tokenWeight0), \"REQLP: K\");\n                }\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n        return amount0Out > 0 ? amount0Out : amount1Out;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function onSwap(\n        address tokenIn,\n        address,\n        uint256,\n        uint256 amountOut,\n        address to\n    ) external override lock {\n        (uint256 amount0Out, uint256 amount1Out) = token0 == tokenIn ? (uint256(0), amountOut) : (amountOut, uint256(0));\n        require(amount0Out > 0 || amount1Out > 0, \"REQLP: INSUFFICIENT_OUTPUT_AMOUNT\");\n        uint112 _reserve0 = reserve0; // gas savings\n        uint112 _reserve1 = reserve1; // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"REQLP: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"REQLP: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(10000);\n            uint256 balance1Adjusted = balance1.mul(10000);\n            {\n                // avoids stack too deep errors\n                if (amount0In > 0) {\n                    uint256 amount0InFee = amount0In.mul(swapFee);\n                    balance0Adjusted = balance0Adjusted.sub(amount0InFee);\n                    collectedFee0 = uint112(uint256(collectedFee0).add(amount0InFee));\n                }\n                if (amount1In > 0) {\n                    uint256 amount1InFee = amount1In.mul(swapFee);\n                    balance1Adjusted = balance1Adjusted.sub(amount1InFee);\n                    collectedFee1 = uint112(uint256(collectedFee1).add(amount1InFee));\n                }\n                uint32 _tokenWeight0 = tokenWeight0; // gas savings\n                if (_tokenWeight0 == 50) {\n                    // gas savings for pair 50/50\n                    require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(10000**2), \"REQLP: K\");\n                } else {\n                    require(IRequiemFormula(formula).ensureConstantValue(uint256(_reserve0).mul(10000), uint256(_reserve1).mul(10000), balance0Adjusted, balance1Adjusted, _tokenWeight0), \"REQLP: K\");\n                }\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n}\n"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract RequiemERC20 is IRequiemERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Requiem Liquidity Provider\";\n    string public constant symbol = \"RLP\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    constructor() {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"RLP: EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"RLP: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/test/UniswapV2ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract RequiemERC20Wrapper is RequiemERC20 {\n    constructor(uint256 _totalSupply) {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract TestERC20 is RequiemERC20 {\n    constructor(uint256 _totalSupply) {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemWeightedPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\nimport \"./IRequiemSwapInterface.sol\";\n\ninterface IRequiemWeightedPair is IRequiemERC20, IRequiemSwapInterface {\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    // function getReserves()\n    //     external\n    //     view\n    //     returns (\n    //         uint112 reserve0,\n    //         uint112 reserve1,\n    //         uint32 blockTimestampLast\n    //     );\n\n    // function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwapInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\ninterface IRequiemSwapInterface {\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n\n\n    function tokens() external view returns (address[] memory);\n\n    function swapStruct(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        uint index0,\n        uint index1,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256[] memory reserves,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint256[] memory _collectedFees);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiem2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\nimport \"./IMinimalSwapInfo.sol\";\n\ninterface IRequiem2Pool is IRequiemERC20, IMinimalSwapInfo {\n    event PaidProtocolFee(uint256 collectedFee0, uint256 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 reserve0,\n            uint256 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint256 _collectedFee0, uint256 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint256 tokenWeight0, uint256 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    struct NewPoolParams {\n        string name;\n        string symbol;\n        address token0;\n        address token1;\n        uint256 normalizedWeight0;\n        uint256 normalizedWeight1;\n        uint32 swapFeePercentage;\n    }\n\n    function initialize(\n        address token0,\n        address token1,\n        uint256 normalizedWeight0,\n        uint32 swapFeePercentage\n    ) external;\n}\n"
    },
    "contracts/interfaces/IMinimalSwapInfo.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\n *\n * This is called by the Router when a user calls `IRouter.swap` or `IRouter.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\n * to the pool in a 'given out' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Router.\n */\ninterface IMinimalSwapInfo {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\n    //\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\n    //\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\n    // some Pools.\n    //\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\n    // one Pool.\n    //\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\n    //    balance.\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\n    //\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\n    // where the Pool sends the outgoing tokens.\n    //\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\n    struct SwapRequest {\n        SwapKind kind;\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        address from;\n        address to;\n    }\n\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/RequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./RequiemPair.sol\";\n\n// solhint-disable no-inline-assembly\n\ncontract RequiemFactory is IRequiemFactory {\n    address public feeTo;\n    address public formula;\n    uint256 public protocolFee;\n    address public feeToSetter;\n    bytes32 public constant INIT_CODE_HASH = keccak256(abi.encodePacked(type(RequiemPair).creationCode));\n\n    mapping(bytes32 => address) private _pairSalts;\n    address[] public allPairs;\n    mapping(address => uint64) private _pairs;\n\n    constructor(address _feeToSetter, address _formula) {\n        feeToSetter = _feeToSetter;\n        formula = _formula;\n    }\n\n    function isPair(address b) external view returns (bool) {\n        return _pairs[b] > 0;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external view returns (address pair) {\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        pair = _pairSalts[salt];\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"RLP: IDENTICAL_ADDRESSES\");\n        require(tokenWeightA >= 2 && tokenWeightA <= 98 && (tokenWeightA % 2) == 0, \"RLP: INVALID_TOKEN_WEIGHT\");\n        // swap fee from [0.01% - 20%]\n        require(swapFee >= 1 && swapFee <= 2000, \"RLP: INVALID_SWAP_FEE\");\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        require(token0 != address(0), \"RLP: ZERO_ADDRESS\");\n        // single check is sufficient\n        bytes memory bytecode = type(RequiemPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        require(_pairSalts[salt] == address(0), \"RLP: PAIR_EXISTS\");\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IRequiemPair(pair).initialize(token0, token1, tokenWeight0, swapFee);\n        _pairSalts[salt] = address(pair);\n        allPairs.push(pair);\n        uint64 weightAndFee = uint64(swapFee);\n        weightAndFee |= uint64(tokenWeight0) << 32;\n        _pairs[address(pair)] = weightAndFee;\n        emit PairCreated(token0, token1, pair, tokenWeight0, swapFee, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n\n    function setProtocolFee(uint256 _protocolFee) external {\n        require(msg.sender == feeToSetter, \"RLP: FORBIDDEN\");\n        require(_protocolFee == 0 || (_protocolFee >= 10000 && _protocolFee <= 100000), \"RLP: Invalid Protocol fee\");\n        protocolFee = _protocolFee;\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        uint64 weightAndFee = _pairs[pair];\n        if (weightAndFee > 0) {\n            swapFee = uint32(weightAndFee);\n            tokenWeight0 = uint32(weightAndFee >> 32);\n            tokenWeight1 = 100 - tokenWeight0;\n        } else {\n            // Default is 0.3%\n            return (50, 50, 30);\n        }\n    }\n}\n"
    },
    "contracts/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/Initializable.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./RequiemStableSwapRouter.sol\";\n\ncontract FeeDistributor is Initializable, Ownable {\n    using SafeERC20 for IERC20;\n\n    enum SwapPoolType {\n        plain,\n        meta\n    }\n\n    struct SwapConfig {\n        SwapPoolType poolType;\n        address pool;\n        address basePool;\n    }\n\n    /// @dev convert all fee to this token\n    address public target;\n\n    /// @dev fromToken => routerAddress\n    mapping(address => SwapConfig) public getSwapConfig;\n    mapping(address => bool) public operators;\n\n    RequiemStableSwapRouter public swapRouter;\n    address[] public whiteListedTokens;\n    uint256 constant swapTimeout = 3600;\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function transfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external {\n        if (operators[msg.sender] == true) {\n            uint256 _before = token.balanceOf(address(this));\n            if (_before >= amount) {\n                token.safeTransfer(to, amount);\n                uint256 _after = token.balanceOf(address(this));\n                require(_before - _after == amount, \"transfer-fail\");\n                emit TransferFee(msg.sender, to, token, amount);\n            }\n        }\n    }\n\n    function swap() external {\n        if (operators[msg.sender] == true) {\n            for (uint256 i = 0; i < whiteListedTokens.length; i++) {\n                address fromToken = whiteListedTokens[i];\n                SwapConfig storage swapConfig = getSwapConfig[fromToken];\n\n                if (swapConfig.poolType == SwapPoolType.plain) {\n                    swapPlainPool(swapConfig, fromToken);\n                } else if (swapConfig.poolType == SwapPoolType.meta) {\n                    swapMetaPool(swapConfig, fromToken);\n                }\n            }\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function swapPlainPool(SwapConfig storage config, address fromTokenAddress) internal {\n        IERC20 fromToken = IERC20(fromTokenAddress);\n        uint256 inAmount = fromToken.balanceOf(address(this));\n        if (inAmount > 0) {\n            IRequiemStableSwap pool = IRequiemStableSwap(config.pool);\n            uint8 fromIndex = pool.getTokenIndex(fromTokenAddress);\n            uint8 toIndex = pool.getTokenIndex(target);\n            fromToken.safeIncreaseAllowance(config.pool, inAmount);\n            pool.swap(fromIndex, toIndex, inAmount, 0, address(this), block.timestamp + swapTimeout);\n        }\n    }\n\n    function swapMetaPool(SwapConfig storage config, address fromTokenAddress) internal {\n        IERC20 fromToken = IERC20(fromTokenAddress);\n        uint256 inAmount = fromToken.balanceOf(address(this));\n\n        if (inAmount > 0) {\n            IRequiemStableSwap pool = IRequiemStableSwap(config.pool);\n            IRequiemStableSwap basePool = IRequiemStableSwap(config.basePool);\n            uint8 tokenIndexFrom = pool.getTokenIndex(fromTokenAddress);\n            uint8 tokenIndexTo = basePool.getTokenIndex(target);\n            fromToken.safeIncreaseAllowance(address(swapRouter), inAmount);\n            swapRouter.swapToBase(pool, basePool, tokenIndexFrom, tokenIndexTo, inAmount, 0, block.timestamp + swapTimeout);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(address _target, address _swapRouter) external onlyOwner initializer {\n        target = _target;\n        swapRouter = RequiemStableSwapRouter(_swapRouter);\n    }\n\n    function toggleOperator(address _operator) external onlyOwner {\n        operators[_operator] = !operators[_operator];\n    }\n\n    function setSwapConfig(\n        address _fromToken,\n        SwapPoolType poolType,\n        address pool,\n        address basePool\n    ) external onlyOwner {\n        require(_fromToken != address(0), \"zeroFromTokenAddress\");\n        require(pool != address(0), \"zeroPoolAddress\");\n\n        if (poolType == SwapPoolType.meta) {\n            require(basePool != address(0), \"zeroBasePoolAddress\");\n        }\n\n        if (getSwapConfig[_fromToken].pool == address(0)) {\n            whiteListedTokens.push(_fromToken);\n        }\n\n        getSwapConfig[_fromToken] = SwapConfig({poolType: poolType, pool: pool, basePool: basePool});\n    }\n\n    /* =============== EVENTS ==================== */\n\n    event TransferFee(address caller, address to, IERC20 token, uint256 amount);\n}\n"
    },
    "contracts/RequiemStableSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemStableSwapRouter {\n    using SafeERC20 for IERC20;\n\n    function calculateConvert(\n        IRequiemStableSwap fromPool,\n        IRequiemStableSwap toPool,\n        uint256 amount\n    ) external view returns (uint256) {\n        uint256 fromPoolLength = fromPool.getNumberOfTokens();\n        uint256[] memory amounts = fromPool.calculateRemoveLiquidity(address(this), amount);\n        uint256[] memory meta_amounts = new uint256[](fromPoolLength);\n        for (uint8 i = 0; i < fromPoolLength; i++) {\n            IERC20 fromCoin = fromPool.getToken(i);\n            uint256 toCoinIndex = toPool.getTokenIndex(address(fromCoin));\n            meta_amounts[toCoinIndex] = amounts[i];\n        }\n        return toPool.calculateTokenAmount(meta_amounts, true);\n    }\n\n    function convert(\n        IRequiemStableSwap fromPool,\n        IRequiemStableSwap toPool,\n        uint256 amount,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256) {\n        uint256 fromPoolLength = fromPool.getNumberOfTokens();\n        uint256 toPoolLength = toPool.getNumberOfTokens();\n        require(address(fromPool) != address(toPool), \"fromPool = toPool\");\n        require(fromPoolLength == toPoolLength, \"poolTokensLengthMissmatch\");\n        IERC20 fromToken = fromPool.getLpToken();\n        IERC20 toToken = toPool.getLpToken();\n        uint256[] memory min_amounts = new uint256[](fromPoolLength);\n        // validate token\n        for (uint8 i = 0; i < fromPoolLength; i++) {\n            IERC20 coin = fromPool.getToken(i);\n            toPool.getTokenIndex(address(coin));\n        }\n        fromToken.transferFrom(msg.sender, address(this), amount);\n        fromToken.safeIncreaseAllowance(address(fromPool), amount);\n        fromPool.removeLiquidity(amount, min_amounts, deadline);\n\n        uint256[] memory meta_amounts = new uint256[](toPoolLength);\n\n        for (uint8 i = 0; i < toPoolLength; i++) {\n            IERC20 coin = toPool.getToken(i);\n            uint256 addBalance = coin.balanceOf(address(this));\n            coin.safeIncreaseAllowance(address(toPool), addBalance);\n            meta_amounts[i] = addBalance;\n        }\n        toPool.addLiquidity(meta_amounts, minToMint, deadline);\n\n        uint256 lpAmount = toToken.balanceOf(address(this));\n        toToken.transfer(msg.sender, lpAmount);\n        return lpAmount;\n    }\n\n    function addLiquidity(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint256[] memory meta_amounts,\n        uint256[] memory base_amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256) {\n        IERC20 token = IERC20(pool.getLpToken());\n        require(base_amounts.length == basePool.getNumberOfTokens(), \"invalidBaseAmountsLength\");\n        require(meta_amounts.length == pool.getNumberOfTokens(), \"invalidMetaAmountsLength\");\n        bool deposit_base = false;\n        for (uint8 i = 0; i < base_amounts.length; i++) {\n            uint256 amount = base_amounts[i];\n            if (amount > 0) {\n                deposit_base = true;\n                IERC20 coin = basePool.getToken(i);\n                coin.safeTransferFrom(msg.sender, address(this), amount);\n                uint256 transferred = coin.balanceOf(address(this));\n                coin.safeIncreaseAllowance(address(basePool), transferred);\n                base_amounts[i] = transferred;\n            }\n        }\n        if (deposit_base) {\n            basePool.addLiquidity(base_amounts, 0, deadline);\n        }\n\n        for (uint8 i = 0; i < meta_amounts.length; i++) {\n            IERC20 coin = pool.getToken(i);\n            if (meta_amounts[i] > 0) {\n                coin.safeTransferFrom(msg.sender, address(this), meta_amounts[i]);\n            }\n            uint256 transferred = coin.balanceOf(address(this));\n            coin.safeIncreaseAllowance(address(pool), transferred);\n            meta_amounts[i] = transferred;\n        }\n        pool.addLiquidity(meta_amounts, minToMint, deadline);\n        uint256 lpAmount = token.balanceOf(address(this));\n        token.transfer(msg.sender, lpAmount);\n        return lpAmount;\n    }\n\n    function removeLiquidity(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint256 _amount,\n        uint256[] calldata min_amounts_meta,\n        uint256[] calldata min_amounts_base,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts, uint256[] memory base_amounts) {\n        IERC20 token = pool.getLpToken();\n        IERC20 baseToken = basePool.getLpToken();\n        token.transferFrom(msg.sender, address(this), _amount);\n        token.safeIncreaseAllowance(address(pool), _amount);\n        pool.removeLiquidity(_amount, min_amounts_meta, deadline);\n        uint256 _base_amount = baseToken.balanceOf(address(this));\n        baseToken.safeIncreaseAllowance(address(basePool), _base_amount);\n\n        basePool.removeLiquidity(_base_amount, min_amounts_base, deadline);\n        // Transfer all coins out\n        amounts = new uint256[](pool.getNumberOfTokens());\n        for (uint8 i = 0; i < pool.getNumberOfTokens(); i++) {\n            IERC20 coin = pool.getToken(i);\n            amounts[i] = coin.balanceOf(address(this));\n            if (amounts[i] > 0) {\n                coin.safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n\n        base_amounts = new uint256[](basePool.getNumberOfTokens());\n        for (uint8 i = 0; i < basePool.getNumberOfTokens(); i++) {\n            IERC20 coin = basePool.getToken(i);\n            base_amounts[i] = coin.balanceOf(address(this));\n            if (base_amounts[i] > 0) {\n                coin.safeTransfer(msg.sender, base_amounts[i]);\n            }\n        }\n    }\n\n    function calculateTokenAmount(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint256[] memory meta_amounts,\n        uint256[] memory base_amounts,\n        bool is_deposit\n    ) external view returns (uint256) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        uint256 _base_tokens = basePool.calculateTokenAmount(base_amounts, is_deposit);\n        meta_amounts[baseTokenIndex] = meta_amounts[baseTokenIndex] + _base_tokens;\n        return pool.calculateTokenAmount(meta_amounts, is_deposit);\n    }\n\n    function calculateRemoveLiquidity(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint256 amount\n    ) external view returns (uint256[] memory meta_amounts, uint256[] memory base_amounts) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        meta_amounts = pool.calculateRemoveLiquidity(address(this), amount);\n        uint256 lpAmount = meta_amounts[baseTokenIndex];\n        meta_amounts[baseTokenIndex] = 0;\n        base_amounts = basePool.calculateRemoveLiquidity(address(this), lpAmount);\n    }\n\n    function swapFromBase(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        uint256[] memory base_amounts = new uint256[](basePool.getNumberOfTokens());\n        base_amounts[tokenIndexFrom] = dx;\n        IERC20 coin = basePool.getToken(tokenIndexFrom);\n        coin.safeTransferFrom(msg.sender, address(this), dx);\n        coin.safeIncreaseAllowance(address(basePool), dx);\n        uint256 baseLpAmount = basePool.addLiquidity(base_amounts, 0, deadline);\n        if (baseTokenIndex != tokenIndexTo) {\n            baseToken.safeIncreaseAllowance(address(pool), baseLpAmount);\n            pool.swap(baseTokenIndex, tokenIndexTo, baseLpAmount, minDy, address(this),deadline);\n        }\n        IERC20 coinTo = pool.getToken(tokenIndexTo);\n        uint256 amountOut = coinTo.balanceOf(address(this));\n        coinTo.safeTransfer(msg.sender, amountOut);\n        return amountOut;\n    }\n\n    function calculateSwapFromBase(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        uint256[] memory base_amounts = new uint256[](basePool.getNumberOfTokens());\n        base_amounts[tokenIndexFrom] = dx;\n        uint256 baseLpAmount = basePool.calculateTokenAmount(base_amounts, true);\n        if (baseTokenIndex == tokenIndexTo) {\n            return baseLpAmount;\n        }\n        return pool.calculateSwap(baseTokenIndex, tokenIndexTo, baseLpAmount);\n    }\n\n    function swapToBase(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        IERC20 coin = pool.getToken(tokenIndexFrom);\n        coin.safeTransferFrom(msg.sender, address(this), dx);\n        uint256 tokenLPAmount = dx;\n        if (baseTokenIndex != tokenIndexFrom) {\n            coin.safeIncreaseAllowance(address(pool), dx);\n            tokenLPAmount = pool.swap(tokenIndexFrom, baseTokenIndex, dx, 0,address(this), deadline);\n        }\n        baseToken.safeIncreaseAllowance(address(basePool), tokenLPAmount);\n        basePool.removeLiquidityOneToken(tokenLPAmount, tokenIndexTo, minDy, deadline);\n        IERC20 coinTo = basePool.getToken(tokenIndexTo);\n        uint256 amountOut = coinTo.balanceOf(address(this));\n        coinTo.safeTransfer(msg.sender, amountOut);\n        return amountOut;\n    }\n\n    function calculateSwapToBase(\n        IRequiemStableSwap pool,\n        IRequiemStableSwap basePool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        IERC20 baseToken = basePool.getLpToken();\n        uint8 baseTokenIndex = pool.getTokenIndex(address(baseToken));\n        uint256 tokenLPAmount = dx;\n        if (baseTokenIndex != tokenIndexFrom) {\n            tokenLPAmount = pool.calculateSwap(tokenIndexFrom, baseTokenIndex, dx);\n        }\n        return basePool.calculateRemoveLiquidityOneToken(address(this), tokenLPAmount, tokenIndexTo);\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/ERC20.sol\";\n\n/**\n * @dev THIS CONTRACT IS FOR TESTING PURPOSES ONLY.\n */\ncontract MockERC20 is ERC20 {\n    uint8 internal decimals_;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        super._mint(msg.sender, 1e27);\n        decimals_ = _decimals;\n    }\n\n    function mint(address _receiver, uint256 _amount) external {\n        _mint(_receiver, _amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return decimals_;\n    }\n}\n"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Permit.sol\";\nimport \"./EIP712.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    mapping(address => uint256) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"EXPIRED_PERMIT\");\n\n        uint256 nonce = _nonces[owner];\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ecrecover(hash, v, r, s);\n        require((signer != address(0)) && (signer == owner), \"INVALID_SIGNATURE\");\n\n        _nonces[owner] = nonce + 1;\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/SignaturesValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"../../interfaces/ISignaturesValidator.sol\";\nimport \"../EIP712.sol\";\n\n/**\n * @dev Utility for signing Solidity function calls.\n *\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\n *\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\n */\nabstract contract SignaturesValidator is ISignaturesValidator, EIP712 {\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\n    // for each of these values, even if 'v' is typically an 8 bit value.\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\n\n    // Replay attack prevention for each user.\n    mapping(address => uint256) internal _nextNonce;\n\n    constructor(string memory name) EIP712(name, \"1\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function getDomainSeparator() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getNextNonce(address user) external view override returns (uint256) {\n        return _nextNonce[user];\n    }\n\n    /**\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\n     */\n    function _validateSignature(address user, uint256 errorCode) internal {\n        uint256 nextNonce = _nextNonce[user]++;\n        RequiemErrors._require(_isSignatureValid(user, nextNonce), errorCode);\n    }\n\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\n        uint256 deadline = _deadline();\n\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (deadline < block.timestamp) {\n            return false;\n        }\n\n        bytes32 typeHash = _typeHash();\n        if (typeHash == bytes32(0)) {\n            // Prevent accidental signature validation for functions that don't have an associated type hash.\n            return false;\n        }\n\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\n        return recoveredAddress != address(0) && recoveredAddress == user;\n    }\n\n    /**\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\n     * selector (available as `msg.sig`).\n     *\n     * The type hash must conform to the following format:\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\n     *\n     * If 0x00, all signatures will be considered invalid.\n     */\n    function _typeHash() internal view virtual returns (bytes32);\n\n    /**\n     * @dev Extracts the signature deadline from extra calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _deadline() internal pure returns (uint256) {\n        // The deadline is the first extra argument at the end of the original calldata.\n        return uint256(_decodeExtraCalldataWord(0));\n    }\n\n    /**\n     * @dev Extracts the signature parameters from extra calldata.\n     *\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\n     * be considered a valid signature in the first place.\n     */\n    function _signature()\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // v, r and s are appended after the signature deadline, in that order.\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\n        r = _decodeExtraCalldataWord(0x40);\n        s = _decodeExtraCalldataWord(0x60);\n    }\n\n    /**\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _calldata() internal pure returns (bytes memory result) {\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We simply overwrite the array length with the reduced one.\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\n            }\n        }\n    }\n\n    /**\n     * @dev Returns a 256 bit word from 'extra' calldata, at some offset from the expected end of the original calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ISignaturesValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidator {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n"
    },
    "contracts/ProtocolFeeRemover.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract ProtocolFeeRemover {\n    address public receiver;\n    address public governance;\n\n    event RemoveLiquidity(address indexed pair, uint256 token0, uint256 token1);\n    event ChangeGovernance(address changeValue);\n    event ChangeReceiver(address changeValue);\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    function setReceiver(address _receiver) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        receiver = _receiver;\n        emit ChangeReceiver(_receiver);\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function transfer(address _token, uint256 _value) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        TransferHelper.safeTransfer(_token, receiver, _value);\n    }\n\n    function transferAllTokens(address[] calldata _tokens) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC20(_tokens[i]).balanceOf(address(this));\n            TransferHelper.safeTransfer(_tokens[i], receiver, _balance);\n        }\n    }\n\n    function remove(address[] calldata pairs) external {\n        address _receiver = receiver;\n        // save gas\n        require(_receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IRequiemPair pair = IRequiemPair(pairs[i]);\n            uint256 liquidity = pair.balanceOf(address(this));\n            if (liquidity > 0) {\n                pair.transfer(address(pair), liquidity);\n                (uint256 amount0, uint256 amount1) = pair.burn(_receiver);\n                emit RemoveLiquidity(address(pair), amount0, amount1);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the EnumerableMap library from OpenZeppelin Contracts, altered to include the following:\n//  * a map from IERC20 to bytes32\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\n//  * unchecked_at and unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\n//  * indexOf, unchecked_indexOf and unchecked_setAt, which allow for more gas efficient data writes in some scenarios\n//\n// Additionally, the base private functions that work on bytes32 were removed and replaced with a native implementation\n// for IERC20 keys, to reduce bytecode size and runtime costs.\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n */\nlibrary EnumerableMap {\n    // The original OpenZeppelin implementation uses a generic Map type with bytes32 keys: this was replaced with\n    // IERC20ToBytes32Map and IERC20ToUint256Map, resulting in more dense bytecode (as long as each contract only uses\n    // one of these - there'll otherwise be duplicated code).\n\n    // IERC20ToBytes32Map\n\n    struct IERC20ToBytes32MapEntry {\n        IERC20 _key;\n        bytes32 _value;\n    }\n\n    struct IERC20ToBytes32Map {\n        // Number of entries in the map\n        uint256 _length;\n        // Storage of map keys and values\n        mapping(uint256 => IERC20ToBytes32MapEntry) _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(IERC20 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        bytes32 value\n    ) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to !contains(map, key)\n        if (keyIndex == 0) {\n            uint256 previousLength = map._length;\n            map._entries[previousLength] = IERC20ToBytes32MapEntry({ _key: key, _value: value });\n            map._length = previousLength + 1;\n\n            // The entry is stored at previousLength, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = previousLength + 1;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\n     *\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_setAt(\n        IERC20ToBytes32Map storage map,\n        uint256 index,\n        bytes32 value\n    ) internal {\n        map._entries[index]._value = value;\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to contains(map, key)\n        if (keyIndex != 0) {\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the pseudo-array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                IERC20ToBytes32MapEntry storage lastEntry = map._entries[lastIndex];\n\n                // Move the last entry to the index where the entry to delete is\n                map._entries[toDeleteIndex] = lastEntry;\n                // Update the index for the moved entry\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved entry was stored\n            delete map._entries[lastIndex];\n            map._length = lastIndex;\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\n        return map._length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        RequiemErrors._require(map._length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(map, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        IERC20ToBytes32MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\n     * read). O(1).\n     */\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\n        return map._entries[index]._value;\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\n     */\n    function get(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (bytes32) {\n        uint256 index = map._indexes[key];\n        RequiemErrors._require(index > 0, errorCode);\n        return unchecked_valueAt(map, index - 1);\n    }\n\n    /**\n     * @dev Returns the index for `key`.\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function indexOf(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\n        RequiemErrors._require(uncheckedIndex != 0, errorCode);\n        return uncheckedIndex - 1;\n    }\n\n    /**\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\n     * instead.\n     */\n    function unchecked_indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\n        return map._indexes[key];\n    }\n\n    // IERC20ToUint256Map\n\n    struct IERC20ToUint256MapEntry {\n        IERC20 _key;\n        uint256 _value;\n    }\n\n    struct IERC20ToUint256Map {\n        // Number of entries in the map\n        uint256 _length;\n        // Storage of map keys and values\n        mapping(uint256 => IERC20ToUint256MapEntry) _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(IERC20 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 value\n    ) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to !contains(map, key)\n        if (keyIndex == 0) {\n            uint256 previousLength = map._length;\n            map._entries[previousLength] = IERC20ToUint256MapEntry({ _key: key, _value: value });\n            map._length = previousLength + 1;\n\n            // The entry is stored at previousLength, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = previousLength + 1;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\n     *\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_setAt(\n        IERC20ToUint256Map storage map,\n        uint256 index,\n        uint256 value\n    ) internal {\n        map._entries[index]._value = value;\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(IERC20ToUint256Map storage map, IERC20 key) internal returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to contains(map, key)\n        if (keyIndex != 0) {\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the pseudo-array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._length - 1;\n\n            // The swap is only necessary if we're not removing the last element\n            if (toDeleteIndex != lastIndex) {\n                IERC20ToUint256MapEntry storage lastEntry = map._entries[lastIndex];\n\n                // Move the last entry to the index where the entry to delete is\n                map._entries[toDeleteIndex] = lastEntry;\n                // Update the index for the moved entry\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the slot where the moved entry was stored\n            delete map._entries[lastIndex];\n            map._length = lastIndex;\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(IERC20ToUint256Map storage map, IERC20 key) internal view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(IERC20ToUint256Map storage map) internal view returns (uint256) {\n        return map._length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\n        RequiemErrors._require(map._length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(map, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\n        IERC20ToUint256MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\n     * read). O(1).\n     */\n    function unchecked_valueAt(IERC20ToUint256Map storage map, uint256 index) internal view returns (uint256) {\n        return map._entries[index]._value;\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\n     */\n    function get(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 index = map._indexes[key];\n        RequiemErrors._require(index > 0, errorCode);\n        return unchecked_valueAt(map, index - 1);\n    }\n\n    /**\n     * @dev Returns the index for `key`.\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function indexOf(\n        IERC20ToUint256Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (uint256) {\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\n        RequiemErrors._require(uncheckedIndex != 0, errorCode);\n        return uncheckedIndex - 1;\n    }\n\n    /**\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\n     * instead.\n     */\n    function unchecked_indexOf(IERC20ToUint256Map storage map, IERC20 key) internal view returns (uint256) {\n        return map._indexes[key];\n    }\n}\n"
    },
    "contracts/interfaces/ISwapCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface ISwapCreator {\n\n    function create(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address timeLock\n    ) external returns (address);\n}"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface ISwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getTokenLength() external view returns (uint);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function swapStorage() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, address);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n}\n"
    },
    "contracts/interfaces/IStableSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IStableSwapFactory {\n    event SwapCreated(IERC20[] pooledTokens, address indexed swap, uint256 length);\n    event SetFeeTo(address indexed feeTo);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function allPools(uint256) external view returns (address pool);\n\n    function isPool(address) external view returns (bool);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function isTimelock(address) external view returns (bool);\n\n    function createPool(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        uint256 delayTimeLock\n    ) external returns (address pool);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n}\n"
    },
    "contracts/interfaces/IRewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IRewardToken is IERC20 {\n    function mint(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IRewarder {\n\n    function onReward(uint256 pid, address user, address recipient, uint256 rewardAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 rewardAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n"
    },
    "contracts/interfaces/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IPoolSwapStructs {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\n    // IMinimalSwapInfoPool.\n    //\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\n    //\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\n    //\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\n    // some Pools.\n    //\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\n    // one Pool.\n    //\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\n    //    balance.\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\n    //\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\n    // where the Pool sends the outgoing tokens.\n    //\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\n    struct SwapRequest {\n        SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n"
    },
    "contracts/test/StakePoolRewardMultiplierMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/stakePool/IStakePoolRewardMultiplier.sol\";\nimport \"../libraries/SafeMath.sol\";\n\n// solhint-disable state-visibility\n\ncontract StakePoolRewardMultiplierMock is IStakePoolRewardMultiplier {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) {\n        rate = _rate;\n    }\n    function getRewardMultiplier(uint, uint, uint _from, uint _to, uint _rewardPerBlock) external override view returns (uint) {\n        return _to.sub(_from).mul(_rewardPerBlock) .mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/test/DeflatingERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeMath.sol\";\n\n// solhint-disable func-name-mixedcase, var-name-mixedcase, no-inline-assembly, max-line-length, not-rely-on-time\n\ncontract DeflatingERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Deflating Test Token\";\n    string public constant symbol = \"DTT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _totalSupply) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        uint256 burnAmount = value / 100;\n        _burn(from, burnAmount);\n        uint256 transferAmount = value.sub(burnAmount);\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\n        balanceOf[to] = balanceOf[to].add(transferAmount);\n        emit Transfer(from, to, transferAmount);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IRequiemRouter.sol\";\n\n// solhint-disable avoid-low-level-calls, no-empty-blocks\n\ncontract RouterEventEmitter {\n    event Amounts(uint[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForTokens.selector, tokenIn, tokenOut, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactTokens.selector, tokenIn, tokenOut, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactETHForTokens.selector, tokenOut, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        address tokenIn,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactETH.selector, tokenIn, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForETH.selector, tokenIn, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapETHForExactTokens.selector, tokenOut, amountOut, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        RequiemErrors._require(value < 2**255, Errors.SAFE_CAST_VALUE_CANT_FIT_INT256);\n        return int256(value);\n    }\n}\n"
    },
    "contracts/libraries/helpers/TemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"../../interfaces/ITemporarilyPausable.sol\";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausable is ITemporarilyPausable {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        RequiemErrors._require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\n        RequiemErrors._require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPaused() {\n        _ensureNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedState()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPaused();\n        pauseWindowEndTime = _getPauseWindowEndTime();\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPaused(bool paused) internal {\n        if (paused) {\n            RequiemErrors._require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\n        } else {\n            RequiemErrors._require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\n        }\n\n        _paused = paused;\n        emit PausedStateChanged(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPaused() internal view {\n        RequiemErrors._require(_isNotPaused(), Errors.PAUSED);\n    }\n\n    /**\n     * @dev Reverts if the contract is not paused.\n     */\n    function _ensurePaused() internal view {\n        RequiemErrors._require(!_isNotPaused(), Errors.NOT_PAUSED);\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPaused() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTime() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTime() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n"
    },
    "contracts/interfaces/ITemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausable {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChanged(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedState()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n"
    },
    "contracts/libraries/helpers/Authentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./RequiemErrors.sol\";\nimport \"./IAuthentication.sol\";\n\n/**\n * @dev Building block for performing access control on external functions.\n *\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\n * to external functions to only make them callable by authorized accounts.\n *\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\n */\nabstract contract Authentication is IAuthentication {\n    bytes32 private immutable _actionIdDisambiguator;\n\n    /**\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\n     * multi contract systems.\n     *\n     * There are two main uses for it:\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\n     *    unique. The contract's own address is a good option.\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\n     *    shared by the entire family (and no other contract) should be used instead.\n     */\n    constructor(bytes32 actionIdDisambiguator) {\n        _actionIdDisambiguator = actionIdDisambiguator;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\n     */\n    modifier authenticate() {\n        _authenticateCaller();\n        _;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call the entry point function.\n     */\n    function _authenticateCaller() internal view {\n        bytes32 actionId = getActionId(msg.sig);\n        RequiemErrors._require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\n    }\n\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\n        // multiple contracts.\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\n}\n"
    },
    "contracts/libraries/helpers/IAuthentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\ninterface IAuthentication {\n    /**\n     * @dev Returns the action identifier associated with the external function described by `selector`.\n     */\n    function getActionId(bytes4 selector) external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the Address library from OpenZeppelin Contracts, altered by removing the `isContract` checks on\n// `functionCall` and `functionDelegateCall` in order to save gas, as the recipients are known to be contracts.\n\npragma solidity ^0.8.10;\n\nimport \"./helpers/RequiemErrors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        RequiemErrors._require(address(this).balance >= amount, Errors.ADDRESS_INSUFFICIENT_BALANCE);\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        RequiemErrors._require(success, Errors.ADDRESS_CANNOT_SEND_VALUE);\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling up the\n     * revert reason or using the one provided.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                RequiemErrors._revert(Errors.LOW_LEVEL_CALL_FAILED);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/LogCompression.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"./math/LogExpMath.sol\";\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n */\nlibrary LogCompression {\n    int256 private constant _LOG_COMPRESSION_FACTOR = 1e14;\n    int256 private constant _HALF_LOG_COMPRESSION_FACTOR = 0.5e14;\n\n    /**\n     * @dev Returns the natural logarithm of `value`, dropping most of the decimal places to arrive at a value that,\n     * when passed to `fromLowResLog`, will have a maximum relative error of ~0.05% compared to `value`.\n     *\n     * Values returned from this function should not be mixed with other fixed-point values (as they have a different\n     * number of digits), but can be added or subtracted. Use `fromLowResLog` to undo this process and return to an\n     * 18 decimal places fixed point value.\n     *\n     * Because so much precision is lost, the logarithmic values can be stored using much fewer bits than the original\n     * value required.\n     */\n    function toLowResLog(uint256 value) internal pure returns (int256) {\n        int256 ln = LogExpMath.ln(int256(value));\n\n        // Rounding division for signed numerator\n        int256 lnWithError = (ln > 0 ? ln + _HALF_LOG_COMPRESSION_FACTOR : ln - _HALF_LOG_COMPRESSION_FACTOR);\n        return lnWithError / _LOG_COMPRESSION_FACTOR;\n    }\n\n    /**\n     * @dev Restores `value` from logarithmic space. `value` is expected to be the result of a call to `toLowResLog`,\n     * any other function that returns 4 decimals fixed point logarithms, or the sum of such values.\n     */\n    function fromLowResLog(int256 value) internal pure returns (uint256) {\n        return uint256(LogExpMath.exp(value * _LOG_COMPRESSION_FACTOR));\n    }\n}\n"
    },
    "contracts/libraries/oracle/QueryProcessor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../LogCompression.sol\";\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\n\n/**\n * @dev Auxiliary library for PoolPriceOracle, offloading most of the query code to reduce bytecode size by using this\n * as a linked library. The downside is an extra DELEGATECALL is added (2600 gas as of the Berlin hardfork), but the\n * bytecode size gains are so big (specially of the oracle contract does not use `LogCompression.fromLowResLog`) that\n * it is worth it.\n */\nlibrary QueryProcessor {\n    using Buffer for uint256;\n    using Samples for bytes32;\n    using LogCompression for int256;\n\n    /**\n     * @dev Returns the value for `variable` at the indexed sample.\n     */\n    function getInstantValue(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 index\n    ) external view returns (uint256) {\n        bytes32 sample = samples[index];\n        require(sample.timestamp() > 0, \"ORACLE_NOT_INITIALIZED\");\n\n        int256 rawInstantValue = sample.instant(variable);\n        return LogCompression.fromLowResLog(rawInstantValue);\n    }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to `query`.\n     */\n    function getTimeWeightedAverage(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.OracleAverageQuery memory query,\n        uint256 latestIndex\n    ) external view returns (uint256) {\n        require(query.secs != 0, \"ORACLE_BAD_SECS\");\n\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int256(query.secs));\n    }\n\n    /**\n     * @dev Returns the value of the accumulator for `variable` `ago` seconds ago. `latestIndex` must be the index of\n     * the latest sample in the buffer.\n     *\n     * Reverts under the following conditions:\n     *  - if the buffer is empty.\n     *  - if querying past information and the buffer has not been fully initialized.\n     *  - if querying older information than available in the buffer. Note that a full buffer guarantees queries for the\n     *    past 34 hours will not revert.\n     *\n     * If requesting information for a timestamp later than the latest one, it is extrapolated using the latest\n     * available data.\n     *\n     * When no exact information is available for the requested past timestamp (as usually happens, since at most one\n     * timestamp is stored every two minutes), it is estimated by performing linear interpolation using the closest\n     * values. This process is guaranteed to complete performing at most 10 storage reads.\n     */\n    function getPastAccumulator(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) public view returns (int256) {\n        // solhint-disable not-rely-on-time\n        // `ago` must not be before the epoch.\n        require(block.timestamp >= ago, \"ORACLE_INVALID_SECONDS_QUERY\");\n        uint256 lookUpTime = block.timestamp - ago;\n\n        bytes32 latestSample = samples[latestIndex];\n        uint256 latestTimestamp = latestSample.timestamp();\n\n        // The latest sample only has a non-zero timestamp if no data was ever processed and stored in the buffer.\n        require(latestTimestamp > 0, \"ORACLE_NOT_INITIALIZED\");\n\n        if (latestTimestamp <= lookUpTime) {\n            // The accumulator at times ahead of the latest one are computed by extrapolating the latest data. This is\n            // equivalent to the instant value not changing between the last timestamp and the look up time.\n\n            // We can use unchecked arithmetic since the accumulator can be represented in 53 bits, timestamps in 31\n            // bits, and the instant value in 22 bits.\n            uint256 elapsed = lookUpTime - latestTimestamp;\n            return latestSample.accumulator(variable) + (latestSample.instant(variable) * int256(elapsed));\n        } else {\n            // The look up time is before the latest sample, but we need to make sure that it is not before the oldest\n            // sample as well.\n\n            // Since we use a circular buffer, the oldest sample is simply the next one.\n            uint256 bufferLength;\n            uint256 oldestIndex = latestIndex.next();\n            {\n                // Local scope used to prevent stack-too-deep \"\n                bytes32 oldestSample = samples[oldestIndex];\n                uint256 oldestTimestamp = oldestSample.timestamp();\n\n                if (oldestTimestamp > 0) {\n                    // If the oldest timestamp is not zero, it means the buffer was fully initialized.\n                    bufferLength = Buffer.SIZE;\n                } else {\n                    // If the buffer was not fully initialized, we haven't wrapped around it yet,\n                    // and can treat it as a regular array where the oldest index is the first one,\n                    // and the length the number of samples.\n                    bufferLength = oldestIndex; // Equal to latestIndex.next()\n                    oldestIndex = 0;\n                    oldestTimestamp = samples[0].timestamp();\n                }\n\n                // Finally check that the look up time is not previous to the oldest timestamp.\n                require(oldestTimestamp <= lookUpTime, \"ORACLE_QUERY_TOO_OLD\");\n            }\n\n            // Perform binary search to find nearest samples to the desired timestamp.\n            (bytes32 prev, bytes32 next) = findNearestSample(samples, lookUpTime, oldestIndex, bufferLength);\n\n            // `next`'s timestamp is guaranteed to be larger than `prev`'s, so we can skip checked arithmetic.\n            uint256 samplesTimeDiff = next.timestamp() - prev.timestamp();\n\n            if (samplesTimeDiff > 0) {\n                // We estimate the accumulator at the requested look up time by interpolating linearly between the\n                // previous and next accumulators.\n\n                // We can use unchecked arithmetic since the accumulators can be represented in 53 bits, and timestamps\n                // in 31 bits.\n                int256 samplesAccDiff = next.accumulator(variable) - prev.accumulator(variable);\n                uint256 elapsed = lookUpTime - prev.timestamp();\n                return prev.accumulator(variable) + ((samplesAccDiff * int256(elapsed)) / int256(samplesTimeDiff));\n            } else {\n                // Rarely, one of the samples will have the exact requested look up time, which is indicated by `prev`\n                // and `next` being the same. In this case, we simply return the accumulator at that point in time.\n                return prev.accumulator(variable);\n            }\n        }\n    }\n\n    /**\n     * @dev Finds the two samples with timestamps before and after `lookUpDate`. If one of the samples matches exactly,\n     * both `prev` and `next` will be it. `offset` is the index of the oldest sample in the buffer. `length` is the size\n     * of the samples list.\n     *\n     * Assumes `lookUpDate` is greater or equal than the timestamp of the oldest sample, and less or equal than the\n     * timestamp of the latest sample.\n     */\n    function findNearestSample(\n        mapping(uint256 => bytes32) storage samples,\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) public view returns (bytes32 prev, bytes32 next) {\n        // We're going to perform a binary search in the circular buffer, which requires it to be sorted. To achieve\n        // this, we offset all buffer accesses by `offset`, making the first element the oldest one.\n\n        // Auxiliary variables in a typical binary search: we will look at some value `mid` between `low` and `high`,\n        // periodically increasing `low` or decreasing `high` until we either find a match or determine the element is\n        // not in the array.\n        uint256 low = 0;\n        uint256 high = length - 1;\n        uint256 mid;\n\n        // If the search fails and no sample has a timestamp of `lookUpDate` (as is the most common scenario), `sample`\n        // will be either the sample with the largest timestamp smaller than `lookUpDate`, or the one with the smallest\n        // timestamp larger than `lookUpDate`.\n        bytes32 sample;\n        uint256 sampleTimestamp;\n\n        while (low <= high) {\n            // Mid is the floor of the average.\n            uint256 midWithoutOffset = (high + low) / 2;\n\n            // Recall that the buffer is not actually sorted: we need to apply the offset to access it in a sorted way.\n            mid = midWithoutOffset.add(offset);\n            sample = samples[mid];\n            sampleTimestamp = sample.timestamp();\n\n            if (sampleTimestamp < lookUpDate) {\n                // If the mid sample is bellow the look up date, then increase the low index to start from there.\n                low = midWithoutOffset + 1;\n            } else if (sampleTimestamp > lookUpDate) {\n                // If the mid sample is above the look up date, then decrease the high index to start from there.\n\n                // We can skip checked arithmetic: it is impossible for `high` to ever be 0, as a scenario where `low`\n                // equals 0 and `high` equals 1 would result in `low` increasing to 1 in the previous `if` clause.\n                high = midWithoutOffset - 1;\n            } else {\n                // sampleTimestamp == lookUpDate\n                // If we have an exact match, return the sample as both `prev` and `next`.\n                return (sample, sample);\n            }\n        }\n\n        // In case we reach here, it means we didn't find exactly the sample we where looking for.\n        return sampleTimestamp < lookUpDate ? (sample, samples[mid.next()]) : (samples[mid.prev()], sample);\n    }\n}\n"
    },
    "contracts/interfaces/oracle/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\n *\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\n * can be used to compare two different price sources, and choose the most liquid one.\n *\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\n * is not older than the largest safe query window.\n */\ninterface IPriceOracle {\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(Variable variable) external view returns (uint256);\n\n    /**\n     * @dev Information for a Time Weighted Average query.\n     *\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n     */\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\n     * able to produce a result and not revert.\n     *\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\n     * value for 'safe' queries.\n     */\n    function getLargestSafeQueryWindow() external view returns (uint256);\n\n    /**\n     * @dev Returns the accumulators corresponding to each of `queries`.\n     */\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        returns (int256[] memory results);\n\n    /**\n     * @dev Information for an Accumulator query.\n     *\n     * Each query estimates the accumulator at a time `ago` seconds ago.\n     */\n    struct OracleAccumulatorQuery {\n        Variable variable;\n        uint256 ago;\n    }\n}\n"
    },
    "contracts/libraries/oracle/Buffer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nlibrary Buffer {\n    // The buffer is a circular storage structure with 1024 slots.\n    // solhint-disable-next-line private-vars-leading-underscore\n    uint256 internal constant SIZE = 1024;\n\n    /**\n     * @dev Returns the index of the element before the one pointed by `index`.\n     */\n    function prev(uint256 index) internal pure returns (uint256) {\n        return sub(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of the element after the one pointed by `index`.\n     */\n    function next(uint256 index) internal pure returns (uint256) {\n        return add(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots after the one pointed by `index`.\n     */\n    function add(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + offset) % SIZE;\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots before the one pointed by `index`.\n     */\n    function sub(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + SIZE - offset) % SIZE;\n    }\n}\n"
    },
    "contracts/libraries/oracle/Samples.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\nimport \"../helpers/WordCodec.sol\";\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\n\n/**\n * @dev This library provides functions to help manipulating samples for Pool Price Oracles. It handles updates,\n * encoding, and decoding of samples.\n *\n * Each sample holds the timestamp of its last update, plus information about three pieces of data: the price pair, the\n * price of BPT (the associated Pool token), and the invariant.\n *\n * Prices and invariant are not stored directly: instead, we store their logarithm. These are known as the 'instant'\n * values: the exact value at that timestamp.\n *\n * Additionally, for each value we keep an accumulator with the sum of all past values, each weighted by the time\n * elapsed since the previous update. This lets us later subtract accumulators at different points in time and divide by\n * the time elapsed between them, arriving at the geometric mean of the values (also known as log-average).\n *\n * All samples are stored in a single 256 bit word with the following structure:\n *\n * [    log pair price     |        bpt price      |       invariant       |  timestamp ]\n * [ instant | accumulator | instant | accumulator | instant | accumulator |            ]\n * [  int22  |    int53    |  int22  |    int53    |  int22  |    int53    |    uint31  ]\n * MSB                                                                                LSB\n *\n * Assuming the timestamp doesn't overflow (which holds until the year 2038), the largest elapsed time is 2^31, which\n * means the largest possible accumulator value is 2^21 * 2^31, which can be represented using a signed 53 bit integer.\n */\nlibrary Samples {\n    using WordCodec for int256;\n    using WordCodec for uint256;\n    using WordCodec for bytes32;\n\n    uint256 internal constant _TIMESTAMP_OFFSET = 0;\n    uint256 internal constant _ACC_LOG_INVARIANT_OFFSET = 31;\n    uint256 internal constant _INST_LOG_INVARIANT_OFFSET = 84;\n    uint256 internal constant _ACC_LOG_BPT_PRICE_OFFSET = 106;\n    uint256 internal constant _INST_LOG_BPT_PRICE_OFFSET = 159;\n    uint256 internal constant _ACC_LOG_PAIR_PRICE_OFFSET = 181;\n    uint256 internal constant _INST_LOG_PAIR_PRICE_OFFSET = 234;\n\n    /**\n     * @dev Updates a sample, accumulating the new data based on the elapsed time since the previous update. Returns the\n     * updated sample.\n     *\n     * IMPORTANT: This function does not perform any arithmetic checks. In particular, it assumes the caller will never\n     * pass values that cannot be represented as 22 bit signed integers. Additionally, it also assumes\n     * `currentTimestamp` is greater than `sample`'s timestamp.\n     */\n    function update(\n        bytes32 sample,\n        int256 instLogPairPrice,\n        int256 instLogBptPrice,\n        int256 instLogInvariant,\n        uint256 currentTimestamp\n    ) internal pure returns (bytes32) {\n        // Because elapsed can be represented as a 31 bit unsigned integer, and the received values can be represented\n        // as 22 bit signed integers, we don't need to perform checked arithmetic.\n\n        int256 elapsed = int256(currentTimestamp - timestamp(sample));\n        int256 accLogPairPrice = _accLogPairPrice(sample) + instLogPairPrice * elapsed;\n        int256 accLogBptPrice = _accLogBptPrice(sample) + instLogBptPrice * elapsed;\n        int256 accLogInvariant = _accLogInvariant(sample) + instLogInvariant * elapsed;\n\n        return\n            pack(\n                instLogPairPrice,\n                accLogPairPrice,\n                instLogBptPrice,\n                accLogBptPrice,\n                instLogInvariant,\n                accLogInvariant,\n                currentTimestamp\n            );\n    }\n\n    /**\n     * @dev Returns the instant value stored in `sample` for `variable`.\n     */\n    function instant(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _instLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _instLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _instLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns the accumulator value stored in `sample` for `variable`.\n     */\n    function accumulator(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _accLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _accLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _accLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns `sample`'s timestamp.\n     */\n    function timestamp(bytes32 sample) internal pure returns (uint256) {\n        return sample.decodeUint31(_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the pair price.\n     */\n    function _instLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the pair price.\n     */\n    function _accLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the BPT price.\n     */\n    function _instLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the BPT price.\n     */\n    function _accLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the invariant.\n     */\n    function _instLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the invariant.\n     */\n    function _accLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns a sample created by packing together its components.\n     */\n    function pack(\n        int256 instLogPairPrice,\n        int256 accLogPairPrice,\n        int256 instLogBptPrice,\n        int256 accLogBptPrice,\n        int256 instLogInvariant,\n        int256 accLogInvariant,\n        uint256 _timestamp\n    ) internal pure returns (bytes32) {\n        return\n            instLogPairPrice.encodeInt22(_INST_LOG_PAIR_PRICE_OFFSET) |\n            accLogPairPrice.encodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET) |\n            instLogBptPrice.encodeInt22(_INST_LOG_BPT_PRICE_OFFSET) |\n            accLogBptPrice.encodeInt53(_ACC_LOG_BPT_PRICE_OFFSET) |\n            instLogInvariant.encodeInt22(_INST_LOG_INVARIANT_OFFSET) |\n            accLogInvariant.encodeInt53(_ACC_LOG_INVARIANT_OFFSET) |\n            _timestamp.encodeUint(_TIMESTAMP_OFFSET); // Using 31 bits\n    }\n\n    /**\n     * @dev Unpacks a sample into its components.\n     */\n    function unpack(bytes32 sample)\n        internal\n        pure\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 _timestamp\n        )\n    {\n        logPairPrice = _instLogPairPrice(sample);\n        accLogPairPrice = _accLogPairPrice(sample);\n        logBptPrice = _instLogBptPrice(sample);\n        accLogBptPrice = _accLogBptPrice(sample);\n        logInvariant = _instLogInvariant(sample);\n        accLogInvariant = _accLogInvariant(sample);\n        _timestamp = timestamp(sample);\n    }\n}\n"
    },
    "contracts/libraries/helpers/WordCodec.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n *\n * We could use Solidity structs to pack values together in a single storage slot instead of relying on a custom and\n * error-prone library, but unfortunately Solidity only allows for structs to live in either storage, calldata or\n * memory. Because a memory struct uses not just memory but also a slot in the stack (to store its memory location),\n * using memory for word-sized values (i.e. of 256 bits or less) is strictly less gas performant, and doesn't even\n * prevent stack-too-deep issues. This is compounded by the fact that Balancer contracts typically are memory-intensive,\n * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and\n * unpacking is therefore the preferred approach.\n */\nlibrary WordCodec {\n    // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,\n    // or to insert a new one replacing the old.\n    uint256 private constant _MASK_1 = 2**(1) - 1;\n    uint256 private constant _MASK_5 = 2**(5) - 1;\n    uint256 private constant _MASK_7 = 2**(7) - 1;\n    uint256 private constant _MASK_10 = 2**(10) - 1;\n    uint256 private constant _MASK_16 = 2**(16) - 1;\n    uint256 private constant _MASK_22 = 2**(22) - 1;\n    uint256 private constant _MASK_31 = 2**(31) - 1;\n    uint256 private constant _MASK_32 = 2**(32) - 1;\n    uint256 private constant _MASK_53 = 2**(53) - 1;\n    uint256 private constant _MASK_64 = 2**(64) - 1;\n    uint256 private constant _MASK_128 = 2**(128) - 1;\n    uint256 private constant _MASK_192 = 2**(192) - 1;\n\n    // Largest positive values that can be represented as N bits signed integers.\n    int256 private constant _MAX_INT_22 = 2**(21) - 1;\n    int256 private constant _MAX_INT_53 = 2**(52) - 1;\n\n    // In-place insertion\n\n    /**\n     * @dev Inserts a boolean value shifted by an offset into a 256 bit word, replacing the old value. Returns the new\n     * word.\n     */\n    function insertBool(\n        bytes32 word,\n        bool value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));\n        return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Inserts a 5 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 5 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint5(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_5 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 7 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 7 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint7(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_7 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 10 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 10 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint10(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_10 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 16 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value.\n     * Returns the new word.\n     *\n     * Assumes `value` only uses its least significant 16 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint16(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_16 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 31 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 31 bits.\n     */\n    function insertUint31(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_31 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 32 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 32 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint32(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_32 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 64 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 64 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint64(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_64 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Inserts a 22 bits signed integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 22 bits.\n     */\n    function insertInt22(\n        bytes32 word,\n        int256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_22 << offset));\n        // Integer values need masking to remove the upper bits of negative values.\n        return clearedWord | bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    // Bytes\n\n    /**\n     * @dev Inserts 192 bit shifted by an offset into a 256 bit word, replacing the old value. Returns the new word.\n     *\n     * Assumes `value` can be represented using 192 bits.\n     */\n    function insertBits192(\n        bytes32 word,\n        bytes32 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));\n        return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);\n    }\n\n    // Encoding\n\n    // Unsigned\n\n    /**\n     * @dev Encodes an unsigned integer shifted by an offset. This performs no size checks: it is up to the caller to\n     * ensure that the values are bounded.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeUint(uint256 value, uint256 offset) internal pure returns (bytes32) {\n        return bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Encodes a 22 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt22(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    /**\n     * @dev Encodes a 53 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt53(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_53) << offset);\n    }\n\n    // Decoding\n\n    /**\n     * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.\n     */\n    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {\n        return (uint256(word >> offset) & _MASK_1) == 1;\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Decodes and returns a 5 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint5(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_5;\n    }\n\n    /**\n     * @dev Decodes and returns a 7 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint7(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_7;\n    }\n\n    /**\n     * @dev Decodes and returns a 10 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint10(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_10;\n    }\n\n    /**\n     * @dev Decodes and returns a 16 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint16(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_16;\n    }\n\n    /**\n     * @dev Decodes and returns a 31 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint31(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_31;\n    }\n\n    /**\n     * @dev Decodes and returns a 32 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint32(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_32;\n    }\n\n    /**\n     * @dev Decodes and returns a 64 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint64(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_64;\n    }\n\n    /**\n     * @dev Decodes and returns a 128 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint128(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_128;\n    }\n\n    // Signed\n\n    /**\n     * @dev Decodes and returns a 22 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt22(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_22);\n        // In case the decoded value is greater than the max positive integer that can be represented with 22 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n        return value > _MAX_INT_22 ? (value | int256(~_MASK_22)) : value;\n    }\n\n    /**\n     * @dev Decodes and returns a 53 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt53(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_53);\n        // In case the decoded value is greater than the max positive integer that can be represented with 53 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n\n        return value > _MAX_INT_53 ? (value | int256(~_MASK_53)) : value;\n    }\n}\n"
    },
    "contracts/libraries/oracle/PoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n\nimport \"../../interfaces/oracle/IPriceOracle.sol\";\nimport \"../../interfaces/oracle/IPoolPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\nimport \"./QueryProcessor.sol\";\n\n/**\n * @dev This module allows Pools to access historical pricing information.\n *\n * It uses a 1024 long circular buffer to store past data, where the data within each sample is the result of\n * accumulating live data for no more than two minutes. Therefore, assuming the worst case scenario where new data is\n * updated in every single block, the oldest samples in the buffer (and therefore largest queryable period) will\n * be slightly over 34 hours old.\n *\n * Usage of this module requires the caller to keep track of two variables: the latest circular buffer index, and the\n * timestamp when the index last changed. Aditionally, access to the latest circular buffer index must be exposed by\n * implementing `_getOracleIndex`.\n *\n * This contract relies on the `QueryProcessor` linked library to reduce bytecode size.\n */\nabstract contract PoolPriceOracle is IPoolPriceOracle, IPriceOracle {\n    using Buffer for uint256;\n    using Samples for bytes32;\n\n    // Each sample in the buffer accumulates information for up to 2 minutes. This is simply to reduce the size of the\n    // buffer: small time deviations will not have any significant effect.\n    // solhint-disable not-rely-on-time\n    uint256 private constant _MAX_SAMPLE_DURATION = 2 minutes;\n\n    // We use a mapping to simulate an array: the buffer won't grow or shrink, and since we will always use valid\n    // indexes using a mapping saves gas by skipping the bounds checks.\n    mapping(uint256 => bytes32) internal _samples;\n\n    // IPoolPriceOracle\n\n    function getSample(uint256 index)\n        external\n        view\n        override\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        )\n    {\n        require(index < Buffer.SIZE, \"ORACLE_INVALID_INDEX\");\n\n        bytes32 sample = _getSample(index);\n        return sample.unpack();\n    }\n\n    function getTotalSamples() external pure override returns (uint256) {\n        return Buffer.SIZE;\n    }\n\n    /**\n     * @dev Manually dirty oracle sample storage slots with dummy data, to reduce the gas cost of the future swaps\n     * that will initialize them. This function is only useful before the oracle has been fully initialized.\n     *\n     * `endIndex` is non-inclusive.\n     */\n    function dirtyUninitializedOracleSamples(uint256 startIndex, uint256 endIndex) external {\n        require(startIndex < endIndex && endIndex <= Buffer.SIZE, \"OUT_OF_BOUNDS\");\n\n        // Uninitialized samples are identified by a zero timestamp -- all other fields are ignored,\n        // so any non-zero value with a zero timestamp suffices.\n        bytes32 initSample = Samples.pack(1, 0, 0, 0, 0, 0, 0);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            if (_samples[i].timestamp() == 0) {\n                _samples[i] = initSample;\n            }\n        }\n    }\n\n    // IPriceOracle\n\n    function getLargestSafeQueryWindow() external pure override returns (uint256) {\n        return 34 hours;\n    }\n\n    function getLatest(Variable variable) external view override returns (uint256) {\n        return QueryProcessor.getInstantValue(_samples, variable, _getOracleIndex());\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        override\n        returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i], latestIndex);\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        override\n        returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, latestIndex, query.ago);\n        }\n    }\n\n    // Internal functions\n\n    /**\n     * @dev Processes new price and invariant data, updating the latest sample or creating a new one.\n     *\n     * Receives the new logarithms of values to store: `logPairPrice`, `logBptPrice` and `logInvariant`, as well the\n     * index of the latest sample and the timestamp of its creation.\n     *\n     * Returns the index of the latest sample. If different from `latestIndex`, the caller should also store the\n     * timestamp, and pass it on future calls to this function.\n     */\n    function _processPriceData(\n        uint256 latestSampleCreationTimestamp,\n        uint256 latestIndex,\n        int256 logPairPrice,\n        int256 logBptPrice,\n        int256 logInvariant\n    ) internal returns (uint256) {\n        // Read latest sample, and compute the next one by updating it with the newly received data.\n        bytes32 sample = _getSample(latestIndex).update(logPairPrice, logBptPrice, logInvariant, block.timestamp);\n\n        // We create a new sample if more than _MAX_SAMPLE_DURATION seconds have elapsed since the creation of the\n        // latest one. In other words, no sample accumulates data over a period larger than _MAX_SAMPLE_DURATION.\n        bool newSample = block.timestamp - latestSampleCreationTimestamp >= _MAX_SAMPLE_DURATION;\n        latestIndex = newSample ? latestIndex.next() : latestIndex;\n\n        // Store the updated or new sample.\n        _samples[latestIndex] = sample;\n\n        return latestIndex;\n    }\n\n    function _getPastAccumulator(\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) internal view returns (int256) {\n        return QueryProcessor.getPastAccumulator(_samples, variable, latestIndex, ago);\n    }\n\n    function _findNearestSample(\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) internal view returns (bytes32 prev, bytes32 next) {\n        return QueryProcessor.findNearestSample(_samples, lookUpDate, offset, length);\n    }\n\n    /**\n     * @dev Returns the sample that corresponds to a given `index`.\n     *\n     * Using this function instead of accessing storage directly results in denser bytecode (since the storage slot is\n     * only computed here).\n     */\n    function _getSample(uint256 index) internal view returns (bytes32) {\n        return _samples[index];\n    }\n\n    /**\n     * @dev Virtual function to be implemented by derived contracts. Must return the current index of the oracle\n     * circular buffer.\n     */\n    function _getOracleIndex() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/oracle/IPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\n\ninterface IPoolPriceOracle {\n    /**\n     * @dev Returns the raw data of the sample at `index`.\n     */\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    /**\n     * @dev Returns the total number of samples.\n     */\n    function getTotalSamples() external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 12500
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}