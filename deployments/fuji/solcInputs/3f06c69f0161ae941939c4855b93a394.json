{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\ninterface IEpochController {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/test/SimpleEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IStakePoolEpochReward.sol\";\nimport \"../libraries/TransferHelper.sol\";\ncontract SimpleEpochController is IEpochController {\n    uint256 public _epoch = 0;\n    uint256 public epochLength = 5 minutes;\n    uint256 public lastEpochTime;\n    address public allocator;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        allocator = msg.sender;\n    }\n\n    function epoch() external override view returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external override view returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        owner = _owner;\n    }\n\n    function setAllocator(address _allocator) external {\n        require(msg.sender == owner, \"SimpleEpochController: FORBIDDEN\");\n        allocator = _allocator;\n    }\n    function nextEpochLength() public override view returns (uint256) {\n        return epochLength;\n    }\n\n    function allocateReward(address pool) external {\n        require(msg.sender == allocator, \"SimpleEpochController: FORBIDDEN\");\n        uint256 _amount = nextEpochAllocatedReward(pool);\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        TransferHelper.safeApprove(rewardToken, pool, _amount);\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IStakePoolEpochReward(pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address pool) public override view returns (uint256) {\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/interfaces/IStakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePoolEpochReward {\n    event AllocateReward(uint256 blocktime, uint256 amount);\n    event Deposit(address indexed account, uint256 amount);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event Withdraw(address indexed account, uint256 amount);\n\n    function version() external view returns (uint256);\n    function stakeToken() external view returns (address);\n    function rewardToken() external view returns (address);\n    function rewardFund() external view returns (address);\n    function epochController() external view returns (address);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward() external view returns (uint256);\n\n    function earned(address _account) external view returns (uint256);\n\n    function unlockWithdrawEpoch(address _account) external view returns (uint256);\n\n    function unlockRewardEpoch(address _account) external view returns (uint256);\n\n    function stake(uint256) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint256) external;\n\n    function claimReward() external;\n\n    function emergencyWithdraw() external;\n\n    function setEpochController(address) external;\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\n\n    function allocateReward(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.16;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/StakePoolEpochRewardCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePoolEpochReward.sol\";\n\ncontract StakePoolEpochRewardCreator is IStakePoolCreator {\n    uint256 public override version = 4001;\n    struct PoolRewardInfo {\n        address epochController;\n        uint256 withdrawLockupEpochs;\n        uint256 rewardLockupEpochs;\n    }\n\n    function create() external override returns (address) {\n        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\n        //\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.initialize(pair, address(stakePoolRewardFund), address(timelock), poolRewardInfo.epochController, rewardToken, poolRewardInfo.withdrawLockupEpochs, poolRewardInfo.rewardLockupEpochs);\n    }\n}\n"
    },
    "contracts/interfaces/IStakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity ^0.8.10;\n\ninterface IStakePoolCreator {\n    function version() external returns (uint);\n\n    function create() external returns (address);\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external;\n}"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./libraries/SafeMath.sol\";\n\ncontract TimeLock {\n    using SafeMath for uint256;\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 1 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n    bool private _initialized;\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n    bool public admin_initialized;\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() {\n        admin_initialized = false;\n        _initialized = false;\n    }\n\n    function initialize(address _admin, uint256 _delay) public {\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        admin = _admin;\n        _initialized = true;\n        emit NewAdmin(admin);\n        emit NewDelay(delay);\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 _delay) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/StakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IEpochController.sol\";\nimport \"./interfaces/IStakePoolEpochReward.sol\";\nimport \"./interfaces/IStakePoolController.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IStakePoolRewardFund.sol\";\n\n// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\ncontract StakePoolEpochReward is IStakePoolEpochReward {\n    using SafeMath for uint256;\n    uint256 public override version;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastSnapshotIndex;\n        uint256 rewardEarned;\n        uint256 epochTimerStart;\n    }\n\n    struct Snapshot {\n        uint256 time;\n        uint256 rewardReceived;\n        uint256 rewardPerShare;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public override epochController;\n    address public override rewardToken;\n\n    uint256 public withdrawLockupEpochs;\n    uint256 public rewardLockupEpochs;\n\n    mapping(address => UserInfo) public userInfo;\n    Snapshot[] public snapshotHistory;\n\n    address public override stakeToken;\n    address public override rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 private _unlocked = 1;\n    bool private _initialized = false;\n    uint256 public constant BLOCKS_PER_DAY = 28800;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n        Snapshot memory genesisSnapshot = Snapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\n        snapshotHistory.push(genesisSnapshot);\n    }\n\n    modifier lock() {\n        require(_unlocked == 1, \"SPER: LOCKED\");\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SPER: !timelock\");\n        _;\n    }\n\n    modifier onlyEpochController() {\n        require(msg.sender == epochController, \"SPER: !epochController\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        if (_account != address(0)) {\n            UserInfo storage user = userInfo[_account];\n            user.rewardEarned = earned(_account);\n            user.lastSnapshotIndex = latestSnapshotIndex();\n        }\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        address _rewardFund,\n        address _timelock,\n        address _epochController,\n        address _rewardToken,\n        uint256 _withdrawLockupEpochs,\n        uint256 _rewardLockupEpochs\n    ) external {\n        require(_initialized == false, \"SPER: Initialize must be false.\");\n        stakeToken = _stakeToken;\n        rewardToken = _rewardToken;\n        rewardFund = _rewardFund;\n        setEpochController(_epochController);\n        setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setEpochController(address _epochController) public override lock onlyTimeLock {\n        epochController = _epochController;\n        epoch();\n        nextEpochPoint();\n        nextEpochLength();\n        nextEpochAllocatedReward();\n    }\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) public override lock onlyTimeLock {\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: range\"); // <= 2 week\n        withdrawLockupEpochs = _withdrawLockupEpochs;\n        rewardLockupEpochs = _rewardLockupEpochs;\n    }\n\n    function allocateReward(uint256 _amount) external override lock onlyEpochController {\n        require(_amount > 0, \"SPER: Cannot allocate 0\");\n        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\n        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\n        if (balance > 0) {\n            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\n            _amount = _after.sub(_before);\n\n            // Create & add new snapshot\n            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\n            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\n\n            Snapshot memory _newSnapshot = Snapshot({time: block.number, rewardReceived: _amount, rewardPerShare: _nextRPS});\n            emit AllocateReward(block.number, _amount);\n            snapshotHistory.push(_newSnapshot);\n        }\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        if (rewardToken == _token) {\n            // do not allow to drain reward token if less than 1 week after LatestSnapshot\n            if (block.number < (getLatestSnapshot().time + (BLOCKS_PER_DAY * 7))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // =========== Epoch getters\n\n    function epoch() public view override returns (uint256) {\n        return IEpochController(epochController).epoch();\n    }\n\n    function nextEpochPoint() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochPoint();\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochLength();\n    }\n\n    function nextEpochAllocatedReward() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\n    }\n\n    // =========== Snapshot getters\n\n    function latestSnapshotIndex() public view returns (uint256) {\n        return snapshotHistory.length.sub(1);\n    }\n\n    function getLatestSnapshot() internal view returns (Snapshot memory) {\n        return snapshotHistory[latestSnapshotIndex()];\n    }\n\n    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\n        return userInfo[_account].lastSnapshotIndex;\n    }\n\n    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\n        return snapshotHistory[getLastSnapshotIndexOf(_account)];\n    }\n\n    // =========== _account getters\n\n    function rewardPerShare() public view returns (uint256) {\n        return getLatestSnapshot().rewardPerShare;\n    }\n\n    function earned(address _account) public view override returns (uint256) {\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\n        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\n\n        UserInfo memory user = userInfo[_account];\n        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\n    }\n\n    function canWithdraw(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\n    }\n\n    function canClaimReward(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\n    }\n\n    function unlockWithdrawEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\n    }\n\n    function unlockRewardEpoch(address _account) public view override returns (uint256) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SPER: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SPER: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        user.epochTimerStart = epoch(); // reset timer\n        user.amount = user.amount.add(_amount);\n        emit Deposit(_account, _amount);\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _epoch = epoch();\n        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, \"SPER: still in withdraw lockup\");\n        require(user.amount >= _amount, \"SPER: invalid withdraw amount\");\n        _claimReward(false);\n        balance = balance.sub(_amount);\n        user.epochTimerStart = _epoch; // reset timer\n        user.amount = user.amount.sub(_amount);\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _reward = user.rewardEarned;\n        if (_reward > 0) {\n            if (_lockChecked) {\n                uint256 _epoch = epoch();\n                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, \"SPER: still in reward lockup\");\n                user.epochTimerStart = _epoch; // reset timer\n            }\n            user.rewardEarned = 0;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\n            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\n            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\n        }\n    }\n\n    function claimReward() public override {\n        _claimReward(true);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SPER: Not allowed\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        user.rewardEarned = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0, \"ds-math-division-by-zero\");\n        c = a / b;\n    }\n}\n"
    },
    "contracts/interfaces/IStakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity ^0.8.10;\n\ninterface IStakePoolController {\n    event MasterCreated(address indexed farm, address indexed stakeToken, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n    event ChangeGovernance(address indexed governance);\n    event SetFeeCollector(address indexed feeCollector);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n    event SetExtraFeeRate(uint256 indexed amount);\n\n    function allStakePools(uint256) external view returns (address stakePool);\n\n    function isStakePool(address contractAddress) external view returns (bool);\n\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n\n    function setStakePoolVerifier(address contractAddress, bool state) external;\n\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\n\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\n\n    function addStakePoolCreator(address contractAddress) external;\n\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n\n    function setEnableWhitelistRewardRebaser(bool value) external;\n\n    function setEnableWhitelistRewardMultiplier(bool value) external;\n\n    function allStakePoolsLength() external view returns (uint256);\n\n    function create(\n        uint256 version,\n        address stakeToken,\n        address rewardToken,\n        uint256 rewardFundAmount,\n        uint256 delayTimeLock,\n        bytes calldata data\n    ) external returns (address);\n\n    function setGovernance(address) external;\n\n    function setFeeCollector(address _address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n\n    function setExtraFeeRate(uint256 _extraFeeRate) external;\n}\n"
    },
    "contracts/interfaces/IStakePoolRewardRebaser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardRebaser {\n    function getRebaseAmount(address rewardToken, uint baseAmount) external view returns (uint);\n}"
    },
    "contracts/interfaces/IStakePoolRewardMultiplier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardMultiplier {\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n}"
    },
    "contracts/interfaces/IStakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IStakePoolRewardFund {\n    function initialize(address _stakePool, address _timelock) external;\n\n    function safeTransfer(address _token, address _to, uint _value) external;\n}"
    },
    "contracts/StakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IStakePoolRewardFund.sol\";\nimport \"./interfaces/IStakePool.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IStakePool.sol\";\n\ncontract StakePoolRewardFund is IStakePoolRewardFund {\n    address public stakePool;\n    address public timelock;\n    bool private _initialized;\n\n    function initialize(address _stakePool, address _timelock) external override {\n        require(_initialized == false, \"StakePoolRewardFund: already initialized\");\n        stakePool = _stakePool;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) external override {\n        require(msg.sender == stakePool, \"StakePoolRewardFund: !stakePool\");\n        TransferHelper.safeTransfer(_token, _to, _value);\n    }\n\n    function allowRecoverRewardToken(address _token) public view returns (bool){\n        return IStakePool(stakePool).allowRecoverRewardToken(_token);\n    }\n\n    function recoverAllRewardToken(\n        address _token,\n        address _to\n    ) external {\n        recoverRewardToken(_token, _to, IERC20(address(_token)).balanceOf(address(this)));\n    }\n\n    function recoverRewardToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) public {\n        require(msg.sender == timelock, \"StakePoolRewardFund: !timelock\");\n        require(allowRecoverRewardToken(_token), \"StakePoolRewardFund: not allow recover reward token\");\n        TransferHelper.safeTransfer(_token, _to, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/IStakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IStakePool {\n    event Deposit(address indexed account, uint256 amount);\n    event AddRewardPool(uint256 indexed poolId);\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardTime, uint256 rewardPerSecond);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n    event Withdraw(address indexed account, uint256 amount);\n    function version() external view returns (uint);\n    function stakeToken() external view returns (address);\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external;\n\n    function stake(uint) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint) external;\n\n    function getReward(uint8 _pid, address _account) external;\n\n    function getAllRewards(address _account) external;\n    function claimReward() external;\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n    function getRewardPerSecond(uint8 pid) external view returns (uint);\n    function rewardPoolInfoLength() external view returns (uint);\n\n    function unfrozenStakeTime(address _account) external view returns (uint);\n\n    function emergencyWithdraw() external;\n\n    function updateReward() external;\n\n    function updateReward(uint8 _pid) external;\n\n    function updateRewardPool(uint8 _pid, uint256 _endRewardTime, uint256 _rewardPerSecond) external;\n    function stopRewardPool(uint8 _pid) external;\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\n\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) external view returns (uint);\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n\n    function getUserInfo(uint8 _pid, address _account) external view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased);\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external;\n}\n"
    },
    "contracts/test/StakePoolRewardRebaserMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/IStakePoolRewardRebaser.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardRebaserMock is IStakePoolRewardRebaser {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRebaseAmount(address rewardToken, uint baseAmount) external override view returns (uint) {\n        return baseAmount.mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/StakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IStakePool.sol\";\nimport \"./interfaces/IStakePoolController.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IStakePoolRewardFund.sol\";\n\ncontract StakePool is IStakePool {\n    using SafeMath for uint256;\n    uint256 public override version;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        mapping(uint8 => uint256) rewardDebt;\n        mapping(uint8 => uint256) reward;\n        mapping(uint8 => uint256) accumulatedEarned; // will accumulate every time user harvest\n        mapping(uint8 => uint256) lockReward;\n        mapping(uint8 => uint256) lockRewardReleased;\n        uint256 lastStakeTime;\n    }\n\n    // Info of each rewardPool funding.\n    struct RewardPoolInfo {\n        address rewardToken; // Address of rewardPool token contract.\n        address rewardRebaser; // Address of rewardRebaser contract.\n        address rewardMultiplier; // Address of rewardMultiplier contract.\n        uint256 startRewardTime; // Start reward block number that rewardPool distribution occurs.\n        uint256 lastRewardTime; // Last block number that rewardPool distribution occurs.\n        uint256 endRewardTime; // Block time which rewardPool distribution ends.\n        uint256 rewardPerSecond; // Reward token amount to distribute per block.\n        uint256 accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n        uint256 lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n        uint256 startVestingTime; // Block time which vesting starts.\n        uint256 endVestingTime; // Block time which vesting ends.\n        uint256 vestingDuration;\n        uint256 totalPaidRewards;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n    RewardPoolInfo[] public rewardPoolInfo;\n    address public override stakeToken;\n    address public rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 public unstakingFrozenTime = 3 days;\n    uint256 private unlocked = 1;\n    bool private _initialized = false;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n    }\n\n    modifier lock() {\n        require(unlocked == 1, \"SP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"SP: !timelock\");\n        _;\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\n            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n            if (rewardPool.rewardToken == _token) {\n                // do not allow to drain reward token if less than 3 days after pool ends\n                if (block.timestamp < (rewardPool.endRewardTime + (3 days))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _stakeToken,\n        uint256 _unstakingFrozenTime,\n        address _rewardFund,\n        address _timelock\n    ) external override {\n        require(_initialized == false, \"SP: Initialize must be false.\");\n        require(unstakingFrozenTime <= 30 days, \"SP: unstakingFrozenTime > 30 days\");\n        stakeToken = _stakeToken;\n        unstakingFrozenTime = _unstakingFrozenTime;\n        rewardFund = _rewardFund;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startTime,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingTime,\n        uint256 _endVestingTime\n    ) external override lock onlyTimeLock {\n        require(rewardPoolInfo.length <= 16, \"SP: Reward pool length > 16\");\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        require(_startVestingTime <= _endVestingTime, \"SP: startVestingTime > endVestingTime\");\n        _startTime = (block.timestamp > _startTime) ? block.timestamp : _startTime;\n        require(_startTime < _endRewardTime, \"SP: startTime >= endRewardTime\");\n        require(_lockRewardPercent <= 100, \"SP: invalid lockRewardPercent\");\n        updateReward();\n        rewardPoolInfo.push(\n            RewardPoolInfo({\n                rewardToken: _rewardToken,\n                rewardRebaser: _rewardRebaser,\n                startRewardTime: _startTime,\n                rewardMultiplier: _rewardMultiplier,\n                lastRewardTime: _startTime,\n                endRewardTime: _endRewardTime,\n                rewardPerSecond: _rewardPerSecond,\n                accRewardPerShare: 0,\n                lockRewardPercent: _lockRewardPercent,\n                startVestingTime: _startVestingTime,\n                endVestingTime: _endVestingTime,\n                vestingDuration: _endVestingTime - _startVestingTime,\n                totalPaidRewards: 0\n            })\n        );\n        emit AddRewardPool(rewardPoolInfo.length - 1);\n    }\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"SP: Invalid reward multiplier\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardMultiplier = _rewardMultiplier;\n        updateReward(_pid);\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n    }\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"SP: Invalid reward rebaser\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardRebaser = _rewardRebaser;\n        updateReward(_pid);\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getRewardMultiplier(\n        uint8 _pid,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerSecond\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardMultiplier = rewardPool.rewardMultiplier;\n        if (rewardMultiplier == address(0)) {\n            return _to.sub(_from).mul(_rewardPerSecond);\n        }\n        return IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(rewardPool.startRewardTime, rewardPool.endRewardTime, _from, _to, _rewardPerSecond);\n    }\n\n    function getRewardRebase(\n        uint8 _pid,\n        address _rewardToken,\n        uint256 _pendingReward\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardRebaser = rewardPool.rewardRebaser;\n        if (rewardRebaser == address(0)) {\n            return _pendingReward;\n        }\n        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n    }\n\n    function getRewardPerSecond(\n        uint8 pid,\n        uint256 from,\n        uint256 to\n    ) public view returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n        uint256 rewardPerSecond = rewardPool.rewardPerSecond;\n        if (from < rewardPool.startRewardTime || from > rewardPool.endRewardTime) return 0;\n        uint256 reward = getRewardMultiplier(pid, from, to, rewardPerSecond);\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n    }\n\n    function getRewardPerSecond(uint8 pid) external view override returns (uint256) {\n        return getRewardPerSecond(pid, block.timestamp, block.timestamp + 1);\n    }\n\n    function updateRewardPool(\n        uint8 _pid,\n        uint256 _endRewardTime,\n        uint256 _rewardPerSecond\n    ) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        require(block.timestamp <= rewardPool.endRewardTime && block.timestamp <= _endRewardTime, \"SP: blockTime > endRewardTime\");\n        updateReward(_pid);\n        rewardPool.endRewardTime = _endRewardTime;\n        rewardPool.rewardPerSecond = _rewardPerSecond;\n        emit UpdateRewardPool(_pid, _endRewardTime, _rewardPerSecond);\n    }\n\n    function stopRewardPool(uint8 _pid) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        updateReward(_pid);\n        rewardPool.endRewardTime = block.timestamp;\n        rewardPool.rewardPerSecond = 0;\n        emit UpdateRewardPool(_pid, rewardPool.endRewardTime, rewardPool.rewardPerSecond);\n    }\n\n    function stake(uint256 _amount) external override lock {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"SP: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"SP: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        getAllRewards(_account);\n        user.amount = user.amount.add(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n        user.lastStakeTime = block.timestamp;\n        emit Deposit(_account, _amount);\n    }\n\n    function rewardPoolInfoLength() public view override returns (uint256) {\n        return rewardPoolInfo.length;\n    }\n\n    function unfrozenStakeTime(address _account) public view override returns (uint256) {\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"SP: invalid withdraw amount\");\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"SP: frozen\");\n        getAllRewards(msg.sender);\n        balance = balance.sub(_amount);\n        user.amount = user.amount.sub(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n    }\n\n    function withdraw(uint256 _amount) public override lock {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function getAllRewards(address _account) public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            getReward(_pid, _account);\n        }\n    }\n\n    function claimReward() external override {\n        getAllRewards(msg.sender);\n    }\n\n    function getReward(uint8 _pid, address _account) public override {\n        updateReward(_pid);\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n        uint256 _lockRewardPercent = rewardPool.lockRewardPercent;\n        if (_lockRewardPercent > 0) {\n            if (block.timestamp > rewardPool.endVestingTime) {\n                uint256 _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n                if (_unlockReward > 0) {\n                    _pendingReward = _pendingReward.add(_unlockReward);\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n                }\n            } else {\n                if (_pendingReward > 0) {\n                    uint256 _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n                    _pendingReward = _pendingReward.sub(_toLocked);\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n                }\n                uint256 _startVestingTime = rewardPool.startVestingTime;\n                if (block.timestamp > _startVestingTime) {\n                    uint256 _toReleased = user.lockReward[_pid].mul(block.timestamp.sub(_startVestingTime)).div(rewardPool.vestingDuration);\n                    uint256 _lockRewardReleased = user.lockRewardReleased[_pid];\n                    if (_toReleased > _lockRewardReleased) {\n                        uint256 _unlockReward = _toReleased.sub(_lockRewardReleased);\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n                        _pendingReward = _pendingReward.add(_unlockReward);\n                    }\n                }\n            }\n        }\n        if (_pendingReward > 0) {\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\n            uint256 reward = user.reward[_pid].add(_pendingReward);\n            user.reward[_pid] = reward;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            address rewardToken = rewardPool.rewardToken;\n            uint256 rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            if (rewardBalance > 0) {\n                user.reward[_pid] = 0;\n                uint256 rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\n                uint256 paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\n                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\n            }\n        }\n    }\n\n    function pendingReward(uint8 _pid, address _account) external view override returns (uint256) {\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime && lpSupply != 0) {\n            uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n        }\n        uint256 pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        require(unstakingFrozenTime == 0 || IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"SP: Not allow emergencyWithdraw\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = 0;\n            user.reward[_pid] = 0;\n        }\n    }\n\n    function getUserInfo(uint8 _pid, address _account)\n        public\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 accumulatedEarned,\n            uint256 lockReward,\n            uint256 lockRewardReleased\n        )\n    {\n        UserInfo storage user = userInfo[_account];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt[_pid];\n        accumulatedEarned = user.accumulatedEarned[_pid];\n        lockReward = user.lockReward[_pid];\n        lockRewardReleased = user.lockRewardReleased[_pid];\n    }\n\n    function updateReward() public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            updateReward(_pid);\n        }\n    }\n\n    function updateReward(uint8 _pid) public override {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _endRewardTime = rewardPool.endRewardTime;\n        uint256 _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\n        uint256 _lastRewardTime = rewardPool.lastRewardTime;\n        if (_endRewardTimeApplicable > _lastRewardTime) {\n            uint256 lpSupply = IERC20(stakeToken).balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint256 _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n            }\n            rewardPool.lastRewardTime = _endRewardTimeApplicable;\n        }\n    }\n}\n"
    },
    "contracts/StakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IStakePoolCreator.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./StakePool.sol\";\n\ncontract StakePoolCreator is IStakePoolCreator {\n    uint256 public override version = 3001;\n\n    struct PoolRewardInfo {\n        address rewardRebaser;\n        address rewardMultiplier;\n        uint256 startBlock;\n        uint256 endRewardBlock;\n        uint256 rewardPerBlock;\n        uint256 lockRewardPercent;\n        uint256 startVestingBlock;\n        uint256 endVestingBlock;\n        uint256 unstakingFrozenTime;\n    }\n\n    function create() external override returns (address) {\n        StakePool pool = new StakePool(msg.sender, version);\n        return address(pool);\n    }\n\n    function initialize(\n        address poolAddress,\n        address pair,\n        address rewardToken,\n        address timelock,\n        address stakePoolRewardFund,\n        bytes calldata data\n    ) external override {\n        StakePool pool = StakePool(poolAddress);\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.addRewardPool(\n            rewardToken,\n            poolRewardInfo.rewardRebaser,\n            poolRewardInfo.rewardMultiplier,\n            poolRewardInfo.startBlock,\n            poolRewardInfo.endRewardBlock,\n            poolRewardInfo.rewardPerBlock,\n            poolRewardInfo.lockRewardPercent,\n            poolRewardInfo.startVestingBlock,\n            poolRewardInfo.endVestingBlock\n        );\n        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\n    }\n}\n"
    },
    "contracts/StakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IStakePoolCreator.sol\";\nimport \"./interfaces/IStakePoolController.sol\";\nimport \"./interfaces/IIsPair.sol\";\nimport \"./interfaces/IStakePool.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./TimeLock.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./StakePoolRewardFund.sol\";\n\ncontract StakePoolController is IStakePoolController {\n    IIsPair public swapFactory;\n    address public governance;\n\n    address public feeCollector;\n    address public feeToken;\n    uint public  feeAmount;\n\n    mapping(address => bool) private _stakePools;\n    mapping(address => bool) private _whitelistStakingFor;\n    mapping(address => bool) private _whitelistRewardRebaser;\n    mapping(address => bool) private _whitelistRewardMultiplier;\n    mapping(address => int8) private _whitelistStakePools;\n    mapping(address => bool) public _stakePoolVerifiers;\n    mapping(uint => address) public stakePoolCreators;\n    address[] public override allStakePools;\n    bool public enableWhitelistRewardRebaser = true;\n    bool public enableWhitelistRewardMultiplier = true;\n    bool private _initialized = false;\n\n    mapping(address => bool) public allowEmergencyWithdrawStakePools;\n\n    uint public extraFeeRate;\n\n    function initialize(address _swapFactory) public {\n        require(_initialized == false, \"SPC: initialized\");\n        governance = msg.sender;\n        swapFactory = IIsPair(_swapFactory);\n        _initialized = true;\n    }\n\n    function isStakePool(address b) external override view returns (bool){\n        return _stakePools[b];\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"SPC: !governance\");\n        _;\n    }\n\n    function setFeeCollector(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        feeCollector = _address;\n        emit SetFeeCollector(_address);\n    }\n    function setEnableWhitelistRewardRebaser(bool value) external onlyGovernance override {\n        enableWhitelistRewardRebaser = value;\n    }\n    function setEnableWhitelistRewardMultiplier(bool value) external onlyGovernance override {\n        enableWhitelistRewardMultiplier = value;\n    }\n    function setFeeToken(address _token) external onlyGovernance override {\n        require(_token != address(0), \"SPC: invalid _token\");\n        feeToken = _token;\n        emit SetFeeToken(_token);\n    }\n    function getCreationFee(address token) public view returns (uint) {\n        if (swapFactory.isPair(token)) {\n            return feeAmount;\n        }\n        return feeAmount * extraFeeRate / 1000;\n    }\n    function setFeeAmount(uint _feeAmount) external onlyGovernance override {\n        feeAmount = _feeAmount;\n        emit SetFeeAmount(_feeAmount);\n    }\n    function setExtraFeeRate(uint _extraFeeRate) external onlyGovernance override {\n        require(_extraFeeRate >= 1000 && _extraFeeRate <= 50000, \"SPC: invalid _extraFeeRate\");\n        extraFeeRate = _extraFeeRate;\n        emit SetExtraFeeRate(_extraFeeRate);\n    }\n    function isWhitelistStakingFor(address _address) external override view returns (bool){\n        return _whitelistStakingFor[_address];\n    }\n\n    function isWhitelistStakePool(address _address) external override view returns (int8){\n        return _whitelistStakePools[_address];\n    }\n    function isStakePoolVerifier(address _address) external override view returns (bool){\n        return _stakePoolVerifiers[_address];\n    }\n    function isAllowEmergencyWithdrawStakePool(address _address) external override view returns (bool){\n        return allowEmergencyWithdrawStakePools[_address];\n    }\n    function setWhitelistStakingFor(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistStakingFor[_address] = state;\n        emit SetWhitelistStakingFor(_address, state);\n    }\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        allowEmergencyWithdrawStakePools[_address] = state;\n    }\n\n    function setStakePoolVerifier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _stakePoolVerifiers[_address] = state;\n        emit SetStakePoolVerifier(_address, state);\n    }\n\n    function setWhitelistStakePool(address _address, int8 state) external override {\n        require(_address != address(0), \"SPC: invalid address\");\n        require(_stakePoolVerifiers[msg.sender] == true, \"SPC: invalid stake pool verifier\");\n        _whitelistStakePools[_address] = state;\n        emit SetWhitelistStakePool(_address, state);\n    }\n\n    function addStakePoolCreator(address _address) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        uint version = IStakePoolCreator(_address).version();\n        require(version >= 1000, \"Invalid stake pool creator version\");\n        stakePoolCreators[version] = _address;\n        emit SetStakePoolCreator(_address, version);\n    }\n\n    function isWhitelistRewardRebaser(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardRebaser) return true;\n        return _address == address(0) ? true : _whitelistRewardRebaser[_address];\n    }\n\n    function setWhitelistRewardRebaser(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardRebaser[_address] = state;\n        emit SetWhitelistRewardRebaser(_address, state);\n    }\n\n    function isWhitelistRewardMultiplier(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardMultiplier) return true;\n        return _address == address(0) ? true : _whitelistRewardMultiplier[_address];\n    }\n\n    function setWhitelistRewardMultiplier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"SPC: invalid address\");\n        _whitelistRewardMultiplier[_address] = state;\n        emit SetWhitelistRewardMultiplier(_address, state);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance override {\n        require(_governance != address(0), \"SPC: invalid governance\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function allStakePoolsLength() external override view returns (uint) {\n        return allStakePools.length;\n    }\n    function createInternal(address stakePoolCreator, address stakeToken, address stakePoolRewardFund, address rewardToken, uint delayTimeLock, bytes calldata data) internal returns (address) {\n        TimeLock timelock = new TimeLock();\n        IStakePool pool = IStakePool(IStakePoolCreator(stakePoolCreator).create());\n        allStakePools.push(address(pool));\n        _stakePools[address(pool)] = true;\n        emit MasterCreated(address(pool), stakeToken, pool.version(), address(timelock), stakePoolRewardFund, allStakePools.length);\n        IStakePoolCreator(stakePoolCreator).initialize(address(pool), stakeToken, rewardToken, address(timelock), address(stakePoolRewardFund), data);\n        StakePoolRewardFund(stakePoolRewardFund).initialize(address(pool), address(timelock));\n        timelock.initialize(msg.sender, delayTimeLock);\n        return address(pool);\n    }\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) public override returns (address) {\n        address stakePoolCreator = stakePoolCreators[version];\n        require(stakePoolCreator != address(0), \"SPC: Invalid stake pool creator version\");\n        uint creationFee = getCreationFee(stakeToken);\n        if (feeCollector != address(0) && feeToken != address(0) && creationFee > 0) {\n            TransferHelper.safeTransferFrom(feeToken, msg.sender, feeCollector, creationFee);\n        }\n\n        StakePoolRewardFund stakePoolRewardFund = new StakePoolRewardFund();\n        if (rewardFundAmount > 0) {\n            require(IERC20(rewardToken).balanceOf(msg.sender) >= rewardFundAmount , \"SPC: Not enough rewardFundAmount\");\n            TransferHelper.safeTransferFrom(rewardToken, msg.sender, address(stakePoolRewardFund), rewardFundAmount);\n        }\n        return createInternal(stakePoolCreator, stakeToken, address(stakePoolRewardFund), rewardToken, delayTimeLock, data);\n    }\n}\n"
    },
    "contracts/interfaces/IIsPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IIsPair {\n    function isPair(address) external view returns (bool);\n}\n"
    },
    "contracts/test/EpochControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IStakePoolEpochReward.sol\";\n\ncontract EpochControllerMock is IEpochController {\n    uint256 private _epoch = 0;\n    address public rewardToken;\n    uint256 public lastEpochTime;\n\n    constructor(address _rewardToken) {\n        rewardToken = _rewardToken;\n    }\n\n    function epoch() external view override returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external view override returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function nextEpochLength() public view override returns (uint256) {\n        return 12 hours;\n    }\n\n    function resetEpochTime() external {\n        lastEpochTime = block.timestamp;\n    }\n\n    function updateEpochTime(uint256 _lastEpochTime) external {\n        lastEpochTime = _lastEpochTime;\n    }\n\n    function allocateSeigniorage(uint256 _amount, address _pool) external {\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(rewardToken).approve(_pool, 0);\n        IERC20(rewardToken).approve(_pool, _amount);\n        IStakePoolEpochReward(_pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address _pool) external view override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/RequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9;\npragma abicoder v2;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IRequiemRouter.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract RequiemRouter is IRequiemRouter {\n    using SafeMath for uint256;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        formula = IRequiemFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = IRequiemFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = IRequiemFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        address to\n    ) public virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IRequiemPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to\n    )\n        internal\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IRequiemPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function createPairETH(\n        address token,\n        uint256 amountToken,\n        uint32 tokenWeight,\n        uint32 swapFee,\n        address to\n    ) public payable virtual override returns (uint256 liquidity) {\n        address pair = IRequiemFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address tokenIn,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            IRequiemPair pairV2 = IRequiemPair(path[i]);\n            address token0 = pairV2.token0();\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out, address output) = input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        address input = tokenIn;\n        for (uint256 i; i < path.length; i++) {\n            IRequiemPair pair = IRequiemPair(path[i]);\n\n            uint256 amountInput;\n            uint256 amountOutput;\n            address currentOutput;\n            {\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                    factory,\n                    address(pair),\n                    input\n                );\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint256 balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountOut;\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline\n    ) public payable virtual override ensure(deadline) returns (uint256 totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint256 i = 0; i < swapSequences.length; i++) {\n            uint256 tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n                uint256 intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(\n        address tokenIn,\n        address pair,\n        uint256 targetSwapAmount,\n        uint256 targetOutAmount\n    ) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IRequiemPair pairV2 = IRequiemPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0 ? (uint256(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint256(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        address pool,\n        uint256 swapAmount,\n        uint256 limitReturnAmount\n    ) internal returns (uint256 tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint256 amountOutput;\n        {\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n                factory,\n                pool,\n                tokenIn\n            );\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IRequiemFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IRequiemPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n        IRequiemPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal view returns (uint256[] memory amounts) {\n        amounts = IRequiemFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n    }\n\n    function transferETHTo(uint256 amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n        (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this));\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(pair, token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IRequiemPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n}\n"
    },
    "contracts/interfaces/IRequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint);\n    function feeTo() external view returns (address);\n    function formula() external view returns (address);\n    function protocolFee() external view returns (uint);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function isPair(address) external view returns (bool);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external returns (address pair);\n    function getWeightsAndSwapFee(address pair) external view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setProtocolFee(uint) external;\n}\n"
    },
    "contracts/interfaces/IRequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity >=0.5.16;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n\n    function getReserveAndWeights(address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountIn);\n\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external view returns (uint amountIn);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountOut);\n\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external view returns (uint amountOut);\n\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external view returns (bool);\n    function getReserves(address pair, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n    function mintLiquidityFee(\n        uint totalLiquidity,\n        uint112 reserve0,\n        uint112  reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112  collectedFee0,\n        uint112 collectedFee1) external view returns (uint amount);\n}\n"
    },
    "contracts/interfaces/IRequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\ninterface IRequiemPair is IRequiemERC20 {\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IRequiemRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint swapAmount; // tokenInAmount / tokenOutAmount\n        uint limitReturnAmount; // minAmountOut / maxAmountIn\n        uint maxPrice;\n    }\n    function factory() external view returns (address);\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut,\n        uint deadline\n    )\n    external payable returns (uint totalAmountOut);\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint maxTotalAmountIn,\n        uint deadline\n    ) external payable returns (uint totalAmountIn);\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/RequiemZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./interfaces/IRequiemRouterLite.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/Babylonian.sol\";\n\ncontract RequiemZap is ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    // governance\n    address public governance;\n    address public WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    IUniswapV2Router public uniRouter;\n    IRequiemRouter public requiemRouter;\n    IRequiemFactory public requiemFactory;\n    IRequiemFormula public requiemFormula;\n\n    mapping(address => mapping(address => address[])) public RequiemPairs; // [input -> output] => requiem pair\n    uint public maxResidual = 100; // 1%, set 10000 to disable\n    address[] public tokensResidual;\n\n    event ZapIn(address indexed sender, address from, uint256 amtFrom, address pool, uint256 amtLp);\n    event ZapOut(address indexed sender, address pool, uint256 amtLp, address to, uint256 amtTo);\n    event Withdraw(address indexed token, uint256 amount, address to);\n    event LogGovernance(address governance);\n\n    receive() external payable {\n        require(msg.sender != tx.origin, \"Zap: Do not send ETH directly\");\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"Zap: !governance\");\n        _;\n    }\n\n    constructor(IUniswapV2Router _uniRouter, IRequiemRouter _requiemRouter) {\n        governance = msg.sender;\n        uniRouter = _uniRouter;\n        requiemRouter = _requiemRouter;\n        requiemFactory = IRequiemFactory(_requiemRouter.factory());\n        requiemFormula = IRequiemFormula(_requiemRouter.formula());\n        WETH = _requiemRouter.WETH();\n    }\n\n    /* ========== External Functions ========== */\n\n    // _to: must be a pair lp\n    // _from: must be in lp\n    // _amounts: amount_from, _minTokenB, _minLp\n    function zapInToken(address _from, uint[] calldata amounts, address _to, bool transferResidual) external nonReentrant returns (uint256 lpAmt) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amounts[0]);\n        _approveTokenIfNeeded(_from);\n\n        if (_from == IRequiemPair(_to).token0() || _from == IRequiemPair(_to).token1()) {\n            // swap half amount for other\n            address other;\n            uint256 sellAmount;\n            {\n                address token0 = IRequiemPair(_to).token0();\n                address token1 = IRequiemPair(_to).token1();\n                other = _from == token0 ? token1 : token0;\n                sellAmount = calculateSwapInAmount(_to, _from, amounts[0], token0);\n            }\n            uint otherAmount = _swap(_from, sellAmount, other, address(this), _to);\n            require(otherAmount >= amounts[1], \"Zap: Insufficient Receive Amount\");\n\n            lpAmt = _pairDeposit(_to, _from, other, amounts[0].sub(sellAmount), otherAmount, msg.sender, requiemFactory.isPair(_to), transferResidual);\n        } else {\n            uint bnbAmount = _swapTokenForBNB(_from, amounts[0], address(this), address(0));\n            lpAmt = _swapETHToLp(IRequiemPair(_to), bnbAmount, msg.sender, 0, transferResidual);\n        }\n\n        require(lpAmt >= amounts[2], \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, _from, amounts[0], _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _to: must be a pair lp\n    function zapIn(address _to, uint _minTokenB, uint _minLp, bool transferResidual) external payable nonReentrant returns (uint256) {\n        uint256 lpAmt = _swapETHToLp(IRequiemPair(_to), msg.value, msg.sender, _minTokenB, transferResidual);\n        require(lpAmt >= _minLp, \"Zap: High Slippage In\");\n        emit ZapIn(msg.sender, WETH, msg.value, _to, lpAmt);\n        return lpAmt;\n    }\n\n    // _from: must be a pair lp\n    // _toToken: must be in lp\n    function zapOut(address _from, uint amount, address _toToken, uint256 _minTokensRec) public nonReentrant returns (uint256) {\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amount);\n        _approveTokenIfNeeded(_from);\n\n        address token0;\n        address token1;\n        uint256 amountA;\n        uint256 amountB;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            token0 = pair.token0();\n            token1 = pair.token1();\n            bool isRequiemPair = requiemFactory.isPair(_from);\n            if (isRequiemPair) {\n                (amountA, amountB) = requiemRouter.removeLiquidity(_from, token0, token1, amount, 1, 1, address(this), block.timestamp);\n            } else {\n                (amountA, amountB) = uniRouter.removeLiquidity(token0, token1, amount, 1, 1, address(this), block.timestamp);\n            }\n        }\n\n        uint256 tokenBought;\n        _approveTokenIfNeeded(token0);\n        _approveTokenIfNeeded(token1);\n        if (_toToken == ETH_ADDRESS) {\n            address _lpOfFromAndTo = WETH == token0 || WETH == token1 ? _from : address(0);\n            tokenBought = _swapTokenForBNB(token0, amountA, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swapTokenForBNB(token1, amountB, address(this), _lpOfFromAndTo));\n        } else {\n            address _lpOfFromAndTo = _toToken == token0 || _toToken == token1 ? _from : address(0);\n            tokenBought = _swap(token0, amountA, _toToken, address(this), _lpOfFromAndTo);\n            tokenBought = tokenBought.add(_swap(token1, amountB, _toToken, address(this), _lpOfFromAndTo));\n        }\n\n        require(tokenBought >= _minTokensRec, \"Zap: High Slippage Out\");\n        if (_toToken == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(msg.sender, tokenBought);\n        } else {\n            IERC20(_toToken).safeTransfer(msg.sender, tokenBought);\n        }\n\n        emit ZapOut(msg.sender, _from, amount, _toToken, tokenBought);\n        return tokenBought;\n    }\n\n    function zapOutWithPermit(\n        address _from,\n        uint256 amount,\n        address _toToken,\n        uint256 _minTokensRec,\n        uint256 _approvalAmount,\n        uint256 _deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        // permit\n        IRequiemPair(_from).permit(\n            msg.sender,\n            address(this),\n            _approvalAmount,\n            _deadline,\n            v,\n            r,\n            s\n        );\n\n        return zapOut(_from, amount, _toToken, _minTokensRec);\n    }\n\n    /* ========== View Functions ===========*/\n    // _from: token A\n    // return amount B that will be convert from A to perform zap in\n    // return amount A that will be convert to B to perform zap in\n    function getAmountBToZapIn(address _from, uint _fromAmount, address lp) external view returns (uint256 amountBConverted, uint256 amountASell) {\n        address other;\n        uint sellAmount;\n        {\n            IRequiemPair pair = IRequiemPair(lp);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _from == token0 ? token1 : token0;\n            sellAmount = calculateSwapInAmount(lp, _from, _fromAmount, token0);\n        }\n\n        address[] memory path = new address[](1);\n        path[0] = lp;\n        uint[] memory amounts = requiemFormula.getFactoryAmountsOut(address(requiemFactory), _from, other, sellAmount, path);\n        return (amounts[amounts.length - 1], sellAmount);\n    }\n\n    // _from: lp pair\n    // return amountOtherSell _otherToken that will be removed from pair\n    // return amountToConverted _toToken that will be converted from other\n    // return amountToOrigin _toToken that will be removed from pair\n    function getAmountToZapOut(address _from, uint amount, address _toToken) external view\n    returns (uint256 amountOtherSell, uint256 amountToConverted, uint256 amountToOrigin) {\n        address other;\n        {\n            IRequiemPair pair = IRequiemPair(_from);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            other = _toToken == token0 ? token1 : token0;\n        }\n        uint sellAmount;\n        uint amountToRemoved;\n        {\n            uint _totalSupply = IERC20(_from).totalSupply();\n            sellAmount = amount.mul(IERC20(other).balanceOf(_from)) / _totalSupply;\n            amountToRemoved = amount.mul(IERC20(_toToken).balanceOf(_from)) / _totalSupply;\n        }\n\n        uint _amountOut = _getRemovedReserveAmountOut(_from, other, sellAmount, amountToRemoved);\n        return (sellAmount, _amountOut, amountToRemoved);\n    }\n\n    function calculateSwapInAmount(address pair, address tokenIn, uint256 userIn, address pairToken0) internal view returns (uint256) {\n        (uint32 tokenWeight0, uint32 tokenWeight1,) = requiemFactory.getWeightsAndSwapFee(pair);\n\n        if (tokenWeight0 == 50) {\n            (uint256 res0, uint256 res1,) = IRequiemPair(pair).getReserves();\n            uint reserveIn = tokenIn == pairToken0 ? res0 : res1;\n            return Babylonian\n                .sqrt(reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009)))\n                .sub(reserveIn.mul(1997)) / 1994;\n        } else {\n            uint256 otherWeight = tokenIn == pairToken0 ? uint(tokenWeight1) : uint(tokenWeight0);\n            return userIn.mul(otherWeight).div(100);\n        }\n    }\n\n    /* ========== Private Functions ========== */\n    function _getRemovedReserveAmountOut(address pair, address tokenIn, uint sellAmount, uint amountToRemoved) internal view returns (uint) {\n        (, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) =\n        requiemFormula.getFactoryReserveAndWeights(address(requiemFactory), pair, tokenIn);\n        return requiemFormula.getAmountOut(sellAmount, reserveIn.sub(sellAmount), reserveOut.sub(amountToRemoved), tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    function _approveTokenIfNeeded(address token) private {\n        if (IERC20(token).allowance(address(this), address(uniRouter)) == 0) {\n            IERC20(token).safeApprove(address(uniRouter), type(uint).max);\n        }\n        if (IERC20(token).allowance(address(this), address(requiemRouter)) == 0) {\n            IERC20(token).safeApprove(address(requiemRouter), type(uint).max);\n        }\n    }\n\n    function _pairDeposit(\n        address _pair,\n        address _poolToken0,\n        address _poolToken1,\n        uint256 token0Bought,\n        uint256 token1Bought,\n        address receiver,\n        bool isRequiemPair,\n        bool transferResidual\n    ) internal returns (uint256 lpAmt) {\n        _approveTokenIfNeeded(_poolToken0);\n        _approveTokenIfNeeded(_poolToken1);\n\n        uint256 amountA;\n        uint256 amountB;\n        if (isRequiemPair) {\n            (amountA, amountB, lpAmt) = requiemRouter.addLiquidity(_pair, _poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        } else {\n            (amountA, amountB, lpAmt) = uniRouter.addLiquidity(_poolToken0, _poolToken1, token0Bought, token1Bought, 1, 1, receiver, block.timestamp);\n        }\n\n        uint amountAResidual = token0Bought.sub(amountA);\n        if (transferResidual || amountAResidual > token0Bought.mul(maxResidual).div(10000)) {\n            if (amountAResidual > 0) {\n                //Returning Residue in token0, if any.\n                _transferToken(_poolToken0, msg.sender, amountAResidual);\n            }\n        }\n\n        uint amountBRedisual = token1Bought.sub(amountB);\n        if (transferResidual || amountBRedisual > token1Bought.mul(maxResidual).div(10000)) {\n            if (amountBRedisual > 0) {\n                //Returning Residue in token1, if any\n                _transferToken(_poolToken1, msg.sender, amountBRedisual);\n            }\n        }\n\n        return lpAmt;\n    }\n\n    function _swapETHToLp(IRequiemPair pair, uint amount, address receiver, uint _minTokenB, bool transferResidual) private returns (uint256 lpAmt) {\n        address lp = address(pair);\n\n        // Lp\n        if (pair.token0() == WETH || pair.token1() == WETH) {\n            address token = pair.token0() == WETH ? pair.token1() : pair.token0();\n            uint swapValue = calculateSwapInAmount(lp, WETH, amount, pair.token0());\n            uint tokenAmount = _swapETHForToken(token, swapValue, address(this), lp);\n            require(tokenAmount >= _minTokenB, \"Zap: Insufficient Receive Amount\");\n\n            uint256 WETHAmount = amount.sub(swapValue);\n            IWETH(WETH).deposit{value : WETHAmount}();\n            lpAmt = _pairDeposit(lp, WETH, token, WETHAmount, tokenAmount, receiver, requiemFactory.isPair(lp), transferResidual);\n        } else {\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            uint token0Amount;\n            uint token1Amount;\n            {\n                (uint32 tokenWeight0,,) = requiemFactory.getWeightsAndSwapFee(lp);\n                uint swap0Value = amount.mul(uint(tokenWeight0)).div(100);\n                token0Amount = _swapETHForToken(token0, swap0Value, address(this), address(0));\n                token1Amount = _swapETHForToken(token1, amount.sub(swap0Value), address(this), address(0));\n            }\n\n            lpAmt = _pairDeposit(lp, token0, token1, token0Amount, token1Amount, receiver, requiemFactory.isPair(lp), transferResidual);\n        }\n    }\n\n    function _swapETHForToken(address token, uint value, address _receiver, address lpBNBToken) private returns (uint) {\n        if (token == WETH) {\n            IWETH(WETH).deposit{value : value}();\n            if (_receiver != address(this)) {\n                IERC20(WETH).safeTransfer(_receiver, value);\n            }\n            return value;\n        }\n        address[] memory path = RequiemPairs[WETH][token];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else if (lpBNBToken != address(0)) {\n            path = new address[](1);\n            path[0] = lpBNBToken;\n            amounts = requiemRouter.swapExactETHForTokens{value : value}(token, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path BNBToken\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swapTokenForBNB(address token, uint amount, address _receiver, address lpTokenBNB) private returns (uint) {\n        if (token == WETH) {\n            _transferToken(WETH, _receiver, amount);\n            return amount;\n        }\n        address[] memory path = RequiemPairs[token][WETH];\n        uint[] memory amounts;\n        if (path.length > 0) {\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else if (lpTokenBNB != address(0)) {\n            path = new address[](1);\n            path[0] = lpTokenBNB;\n            amounts = requiemRouter.swapExactTokensForETH(token, amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path TokenBNB\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _swap(address _from, uint _amount, address _to, address _receiver, address _lpOfFromTo) internal returns (uint) {\n        if (_from == _to) {\n            if (_receiver != address(this)) {\n                IERC20(_from).safeTransfer(_receiver, _amount);\n            }\n            return _amount;\n        }\n        address[] memory path = RequiemPairs[_from][_to];\n        uint[] memory amounts;\n        if (path.length > 0) {// use requiem\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else if (_lpOfFromTo != address(0)) {\n            path = new address[](1);\n            path[0] = _lpOfFromTo;\n            amounts = requiemRouter.swapExactTokensForTokens(_from, _to, _amount, 1, path, _receiver, block.timestamp);\n        } else {\n            revert(\"RequiemZap: !path swap\");\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _transferToken(address token, address to, uint amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token == WETH) {\n            IWETH(WETH).withdraw(amount);\n            if (to != address(this)) {\n                TransferHelper.safeTransferETH(to, amount);\n            }\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n        return;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n    function withdraw(address to) external onlyGovernance {\n        address[] memory _tokens = tokensResidual;\n        withdrawToken(_tokens, to);\n    }\n\n    function withdrawToken(address[] memory tokens, address to) public onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _withdraw(tokens[i], to);\n        }\n    }\n\n    function withdrawTokenAmount(address token, address to, uint256 amount) external onlyGovernance {\n        require(to != address(0), \"Zap: Invalid Receiver Address\");\n        IERC20(token).safeTransfer(to, amount);\n        emit Withdraw(token, amount, to);\n    }\n\n    function _withdraw(address _token, address _to) internal {\n        if (_token == ETH_ADDRESS) {\n            TransferHelper.safeTransferETH(_to, address(this).balance);\n            emit Withdraw(_token, address(this).balance, _to);\n            return;\n        }\n\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, _balance);\n        emit Withdraw(_token, _balance, _to);\n    }\n\n    function setTokensResidual(address[] memory _tokensResidual) external onlyGovernance {\n        tokensResidual = _tokensResidual;\n    }\n\n    function addTokensResidual(address _token) external onlyGovernance {\n        tokensResidual.push(_token);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n        emit LogGovernance(governance);\n    }\n\n    function setRequiemPairs(address _input, address _output, address [] memory _pair) external onlyGovernance {\n        RequiemPairs[_input][_output] = _pair;\n    }\n\n    function setMaxResidual(uint _maxResidual) external onlyGovernance {\n        maxResidual = _maxResidual;\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemRouterLite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IRequiemRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./Babylonian.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n    uint256 private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z;\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"../interfaces/IRequiemPair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IRequiemPair(pair).price0CumulativeLast();\n        price1Cumulative = IRequiemPair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IRequiemPair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            (uint32 _tokenWeight0, uint32 _tokenWeight1) = IRequiemPair(pair).getTokenWeights();\n            uint112 mReserve0 = reserve0 * _tokenWeight1;\n            uint112 mReserve1 = reserve1 * _tokenWeight0;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(mReserve1, mReserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(mReserve0, mReserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/RequiemFormula.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract RequiemFormula is IRequiemFormula {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE = 1;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\n\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n    uint256[128] private maxExpArray;\n\n    function initMaxExpArray() internal {\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    constructor() {\n        initMaxExpArray();\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count;\n            // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1;\n                // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1;\n                    // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n        // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\n        // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n        // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\n        // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000;\n        // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\n        // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n        // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000;\n        // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\n        // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n        // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\n        // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000;\n        // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000;\n        // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000;\n        // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000;\n        // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000;\n        // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000;\n        // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000;\n        // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000;\n        // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000;\n        // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000;\n        // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000;\n        // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00;\n        // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00;\n        // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900;\n        // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00;\n        // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340;\n        // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40;\n        // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0;\n        // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420;\n        // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021;\n        // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001;\n        // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n     * Auto-generated via \"PrintFunctionOptimalLog.py\"\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        }\n        // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        }\n        // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        }\n        // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        }\n        // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        }\n        // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        }\n        // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        }\n        // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        }\n        // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^01 / 01 - y^02 / 02\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^03 / 03 - y^04 / 04\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^05 / 05 - y^06 / 06\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^07 / 07 - y^08 / 08\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^09 / 09 - y^10 / 10\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^11 / 11 - y^12 / 12\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^13 / 13 - y^14 / 14\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via \"PrintFunctionOptimalExp.py\"\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000;\n        // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000;\n        // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000;\n        // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000;\n        // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000;\n        // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000;\n        // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800;\n        // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800;\n        // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00;\n        // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400;\n        // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300;\n        // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00;\n        // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480;\n        // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380;\n        // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638;\n        // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8;\n        // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c;\n        // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014;\n        // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001;\n        // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea;\n        // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n        // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function getReserveAndWeights(address pair, address tokenA)\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    function getFactoryReserveAndWeights(\n        address factory,\n        address pair,\n        address tokenA\n    )\n        public\n        view\n        override\n        returns (\n            address tokenB,\n            uint256 reserveA,\n            uint256 reserveB,\n            uint32 tokenWeightA,\n            uint32 tokenWeightB,\n            uint32 swapFee\n        )\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(factory, pair);\n\n        if (tokenA == IRequiemPair(pair).token0()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else if (tokenA == IRequiemPair(pair).token1()) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IRequiemPair(pair).token0(), reserve1, reserve0, tokenWeight1, tokenWeight0);\n        } else {\n            revert(\"RequiemFormula: Invalid tokenA\");\n        }\n    }\n\n    /**\n     * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n     *\n     * Formula:\n     * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n     *\n     * @param amountIn                  source reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountOut\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountOut) {\n        // validate input\n        require(amountIn > 0, \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(10000 - swapFee);\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            return reserveOut.mul(amountInWithFee) / (reserveIn.mul(10000).add(amountInWithFee));\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = reserveIn.mul(10000).add(amountInWithFee);\n        (result, precision) = power(baseN, reserveIn.mul(10000), tokenWeightIn, tokenWeightOut);\n\n        uint256 temp1 = reserveOut.mul(result);\n        uint256 temp2 = reserveOut << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     *\n     * Formula:\n     * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n     *\n     * @param amountOut     target reserve amount\n     * @param reserveIn    source reserve balance\n     * @param reserveOut    target reserve balance\n     * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n     * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n     * @param swapFee                  swap fee of the conversion\n     *\n     * @return amountIn\n     */\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public view override returns (uint256 amountIn) {\n        // validate input\n        require(amountOut > 0, \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            uint256 numerator = reserveIn.mul(amountOut).mul(10000);\n            uint256 denominator = reserveOut.sub(amountOut).mul(10000 - swapFee);\n            return (numerator / denominator).add(1);\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = reserveOut.sub(amountOut);\n        (result, precision) = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n        uint256 baseReserveIn = reserveIn.mul(10000);\n        uint256 temp1 = baseReserveIn.mul(result);\n        uint256 temp2 = baseReserveIn << precision;\n        return (((temp1 - temp2) >> precision) / (10000 - swapFee)).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint256 i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i],\n                currentTokenIn\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, \"RequiemFormula: INVALID_TOKEN_OUT_PATH\");\n    }\n\n    function getPairAmountOut(\n        address pair,\n        address tokenIn,\n        uint256 amountIn\n    ) external view override returns (uint256 amountOut) {\n        (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountOut = getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path\n    ) external view override returns (uint256[] memory amounts) {\n        require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n        amounts = new uint256[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint256 i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(\n                factory,\n                path[i - 1],\n                currentTokenIn\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n    }\n\n    function getPairAmountIn(\n        address pair,\n        address tokenIn,\n        uint256 amountOut\n    ) external view override returns (uint256 amountIn) {\n        (address currentTokenOut, uint256 reserveIn, uint256 reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountIn = getAmountIn(amountOut, reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        try IRequiemPair(pair).getTokenWeights() returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n            return (_tokenWeight0, _tokenWeight1, IRequiemPair(pair).getSwapFee());\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (\n            bytes memory /*lowLevelData*/\n        ) {\n            return (50, 50, 30);\n        }\n    }\n\n    function getFactoryWeightsAndSwapFee(address factory, address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        return IRequiemFactory(factory).getWeightsAndSwapFee(pair);\n    }\n\n    // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n    //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n    //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n    function ensureConstantValue(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 balance0Adjusted,\n        uint256 balance1Adjusted,\n        uint32 tokenWeight0\n    ) external view override returns (bool) {\n        if (tokenWeight0 == 50) {\n            return balance0Adjusted.mul(balance1Adjusted) >= reserve0.mul(reserve1);\n        }\n        if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n            return true;\n        }\n        if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n            return false;\n        }\n        uint32 w0 = tokenWeight0;\n        uint32 w1 = 100 - w0;\n\n        uint256 r0;\n        uint256 p0;\n        uint256 r1;\n        uint256 p1;\n        if (balance0Adjusted >= reserve0) {\n            (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n            (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n        } else {\n            (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n            (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n        }\n        uint256 minP = p0 < p1 ? p0 : p1;\n        p0 = p0 - minP;\n        p1 = p1 - minP;\n        return (r0 >> p0) <= (r1 >> p1);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\n        require(tokenA != tokenB, \"RequiemFormula: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"RequiemFormula: ZERO_ADDRESS\");\n    }\n\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n        require(token0 == IRequiemPair(pair).token0() && token1 == IRequiemPair(pair).token1(), \"RequiemFormula: Invalid token\");\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function getOtherToken(address pair, address tokenA) external view override returns (address tokenB) {\n        address token0 = IRequiemPair(pair).token0();\n        address token1 = IRequiemPair(pair).token1();\n        require(token0 == tokenA || token1 == tokenA, \"RequiemFormula: Invalid tokenA\");\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure override returns (uint256 amountB) {\n        require(amountA > 0, \"RequiemFormula: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    function mintLiquidityFee(\n        uint256 totalLiquidity,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112 collectedFee0,\n        uint112 collectedFee1\n    ) external view override returns (uint256 amount) {\n        if (collectedFee0 > 0) {\n            (uint256 r0, uint256 p0) = power(uint256(collectedFee0).add(reserve0), reserve0, tokenWeight0, 100);\n            amount = amount.add(totalLiquidity.mul(r0) >> p0).sub(totalLiquidity);\n        }\n        if (collectedFee1 > 0) {\n            (uint256 r1, uint256 p1) = power(uint256(collectedFee1).add(reserve1), reserve1, tokenWeight1, 100);\n            amount = amount.add(totalLiquidity.mul(r1) >> p1).sub(totalLiquidity);\n        }\n    }\n}\n"
    },
    "contracts/RequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemFormula.sol\";\nimport \"./RequiemERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./interfaces/IUniswapV2Callee.sol\";\n\ncontract RequiemPair is IRequiemPair, RequiemERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    \n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint private unlocked = 1;\n    address public formula;\n\n    uint112 private collectedFee0;           // uses single storage slot, accessible via getReserves\n    uint112 private collectedFee1;           // uses single storage slot, accessible via getReserves\n    uint32 private tokenWeight0;\n\n    uint32 private swapFee;\n\n    modifier lock() {\n        require(unlocked == 1, \"REQLP: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function getCollectedFees() public view returns (uint112 _collectedFee0, uint112 _collectedFee1) {\n        _collectedFee0 = collectedFee0;\n        _collectedFee1 = collectedFee1;\n    }\n\n    function getTokenWeights() public view returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n        _tokenWeight0 = tokenWeight0;\n        _tokenWeight1 = 100 - tokenWeight0;\n    }\n\n    function getSwapFee() public view returns (uint32 _swapFee) {\n        _swapFee = swapFee;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"REQLP: TRANSFER_FAILED\");\n    }\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1, uint32 _tokenWeight0, uint32 _swapFee) external {\n        require(msg.sender == factory, \"REQLP: FORBIDDEN\");\n        // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        tokenWeight0 = _tokenWeight0;\n        swapFee = _swapFee;\n        formula = IRequiemFactory(factory).formula();\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 _tokenWeight0 = tokenWeight0;\n        require(balance0 * (100 - _tokenWeight0) <= type(uint112).max && balance1 * _tokenWeight0 <= type(uint112).max, \"REQLP: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            uint112 mReserve0 = _reserve0 * (100 - _tokenWeight0);\n            uint112 mReserve1 = _reserve1 * _tokenWeight0;\n            price0CumulativeLast += uint(UQ112x112.encode(mReserve1).uqdiv(mReserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(mReserve0).uqdiv(mReserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IRequiemFactory(factory).feeTo();\n        uint112 protocolFee = uint112(IRequiemFactory(factory).protocolFee());\n        feeOn = feeTo != address(0);\n        (uint112 _collectedFee0, uint112 _collectedFee1) = getCollectedFees();\n        if (protocolFee > 0 && feeOn && (_collectedFee0 > 0 || _collectedFee1 > 0)) {\n            uint32 _tokenWeight0 = tokenWeight0;\n            uint liquidity = IRequiemFormula(formula).mintLiquidityFee(\n                totalSupply, _reserve0, _reserve1,\n                _tokenWeight0, 100 - _tokenWeight0,\n                _collectedFee0 / protocolFee, _collectedFee1 / protocolFee\n            );\n            if (liquidity > 0) _mint(feeTo, liquidity);\n        }\n        if (_collectedFee0 > 0) collectedFee0 = 0;\n        if (_collectedFee1 > 0) collectedFee1 = 0;\n    }\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply;\n        // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply;// using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply;// using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"REQLP: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, \"REQLP: INSUFFICIENT_OUTPUT_AMOUNT\");\n        uint112 _reserve0 = reserve0; // gas savings\n        uint112 _reserve1 = reserve1; // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: INSUFFICIENT_LIQUIDITY\");\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, \"REQLP: INVALID_TO\");\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"REQLP: INSUFFICIENT_INPUT_AMOUNT\");\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(10000);\n            uint balance1Adjusted = balance1.mul(10000);\n            { // avoids stack too deep errors\n                if (amount0In > 0) {\n                    uint amount0InFee = amount0In.mul(swapFee);\n                    balance0Adjusted = balance0Adjusted.sub(amount0InFee);\n                    collectedFee0 = uint112(uint(collectedFee0).add(amount0InFee));\n                }\n                if (amount1In > 0) {\n                    uint amount1InFee = amount1In.mul(swapFee);\n                    balance1Adjusted = balance1Adjusted.sub(amount1InFee);\n                    collectedFee1 = uint112(uint(collectedFee1).add(amount1InFee));\n                }\n                uint32 _tokenWeight0 = tokenWeight0;// gas savings\n                if (_tokenWeight0 == 50) { // gas savings for pair 50/50\n                    require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000**2), \"REQLP: K\");\n                } else {\n                    require(IRequiemFormula(formula).ensureConstantValue(uint(_reserve0).mul(10000), uint(_reserve1).mul(10000), balance0Adjusted, balance1Adjusted, _tokenWeight0), \"REQLP: K\");\n                }\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract RequiemERC20 is IRequiemERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Requiem Liquidity Provider\";\n    string public constant symbol = \"FLP\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    constructor() {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"FLP: EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"FLP: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/test/UniswapV2ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract RequiemERC20Wrapper is RequiemERC20 {\n    constructor(uint _totalSupply) public {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../RequiemERC20.sol\";\n\ncontract TestERC20 is RequiemERC20 {\n    constructor(uint _totalSupply) public {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/RequiemFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemFactory.sol\";\nimport \"./RequiemPair.sol\";\n\ncontract RequiemFactory is IRequiemFactory {\n    address public feeTo;\n    address public formula;\n    uint256 public protocolFee;\n    address public feeToSetter;\n\n    mapping(bytes32 => address) private _pairSalts;\n    address[] public allPairs;\n    mapping(address => uint64) private _pairs;\n\n    constructor(address _feeToSetter, address _formula) {\n        feeToSetter = _feeToSetter;\n        formula = _formula;\n    }\n\n    function isPair(address b) external view returns (bool) {\n        return _pairs[b] > 0;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external view returns (address pair) {\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        pair = _pairSalts[salt];\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"FLP: IDENTICAL_ADDRESSES\");\n        require(tokenWeightA >= 2 && tokenWeightA <= 98 && (tokenWeightA % 2) == 0, \"FLP: INVALID_TOKEN_WEIGHT\");\n        // swap fee from [0.01% - 20%]\n        require(swapFee >= 1 && swapFee <= 2000, \"FLP: INVALID_SWAP_FEE\");\n        (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB ? (tokenA, tokenB, tokenWeightA) : (tokenB, tokenA, 100 - tokenWeightA);\n        require(token0 != address(0), \"FLP: ZERO_ADDRESS\");\n        // single check is sufficient\n        bytes memory bytecode = type(RequiemPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, tokenWeight0, swapFee));\n        require(_pairSalts[salt] == address(0), \"FLP: PAIR_EXISTS\");\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IRequiemPair(pair).initialize(token0, token1, tokenWeight0, swapFee);\n        _pairSalts[salt] = address(pair);\n        allPairs.push(pair);\n        uint64 weightAndFee = uint64(swapFee);\n        weightAndFee |= uint64(tokenWeight0) << 32;\n        _pairs[address(pair)] = weightAndFee;\n        emit PairCreated(token0, token1, pair, tokenWeight0, swapFee, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"FLP: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"FLP: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n\n    function setProtocolFee(uint256 _protocolFee) external {\n        require(msg.sender == feeToSetter, \"FLP: FORBIDDEN\");\n        require(_protocolFee == 0 || (_protocolFee >= 10000 && _protocolFee <= 100000), \"FLP: Invalid Protocol fee\");\n        protocolFee = _protocolFee;\n    }\n\n    function getWeightsAndSwapFee(address pair)\n        public\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        )\n    {\n        uint64 weightAndFee = _pairs[pair];\n        if (weightAndFee > 0) {\n            swapFee = uint32(weightAndFee);\n            tokenWeight0 = uint32(weightAndFee >> 32);\n            tokenWeight1 = 100 - tokenWeight0;\n        } else {\n            // Default is 0.3%\n            return (50, 50, 30);\n        }\n    }\n}\n"
    },
    "contracts/ProtocolFeeRemover.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract ProtocolFeeRemover {\n    address public receiver;\n    address public governance;\n\n    event RemoveLiquidity(address indexed pair, uint256 token0, uint256 token1);\n    event ChangeGovernance(address changeValue);\n    event ChangeReceiver(address changeValue);\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    function setReceiver(address _receiver) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        receiver = _receiver;\n        emit ChangeReceiver(_receiver);\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function transfer(address _token, uint256 _value) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        TransferHelper.safeTransfer(_token, receiver, _value);\n    }\n\n    function transferAllTokens(address[] calldata _tokens) external {\n        require(msg.sender == governance, \"ProtocolFeeRemover: FORBIDDEN\");\n        require(receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC20(_tokens[i]).balanceOf(address(this));\n            TransferHelper.safeTransfer(_tokens[i], receiver, _balance);\n        }\n    }\n\n    function remove(address[] calldata pairs) external {\n        address _receiver = receiver;\n        // save gas\n        require(_receiver != address(0), \"ProtocolFeeRemover: Invalid Receiver address\");\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IRequiemPair pair = IRequiemPair(pairs[i]);\n            uint256 liquidity = pair.balanceOf(address(this));\n            if (liquidity > 0) {\n                pair.transfer(address(pair), liquidity);\n                (uint256 amount0, uint256 amount1) = pair.burn(_receiver);\n                emit RemoveLiquidity(address(pair), amount0, amount1);\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IRequiemRouter.sol\";\n\ncontract RouterEventEmitter {\n    event Amounts(uint[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForTokens.selector, tokenIn, tokenOut, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactTokens.selector, tokenIn, tokenOut, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactETHForTokens.selector, tokenOut, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        address tokenIn,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapTokensForExactETH.selector, tokenIn, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapExactTokensForETH.selector, tokenIn, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IRequiemRouter(router).swapETHForExactTokens.selector, tokenOut, amountOut, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n}\n"
    },
    "contracts/interfaces/ISwapCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./IERC20.sol\";\n\ninterface ISwapCreator {\n\n    function create(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address timeLock\n    ) external returns (address);\n}"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/ERC20.sol\";\n\n/**\n * @dev THIS CONTRACT IS FOR TESTING PURPOSES ONLY.\n */\ncontract MockERC20 is ERC20 {\n    uint8 internal decimals_;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        super._mint(msg.sender, 1e27);\n        decimals_ = _decimals;\n    }\n\n    function mint(address _receiver, uint256 _amount) external {\n        _mint(_receiver, _amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return decimals_;\n    }\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./../libraries/ERC20.sol\";\n\ninterface ISwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getTokenLength() external view returns (uint);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function swapStorage() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, address);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n}\n"
    },
    "contracts/interfaces/IStableSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface IStableSwapFactory {\n    event SwapCreated(IERC20[] pooledTokens, address indexed swap, uint256 length);\n    event SetFeeTo(address indexed feeTo);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function allPools(uint256) external view returns (address pool);\n\n    function isPool(address) external view returns (bool);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function isTimelock(address) external view returns (bool);\n\n    function createPool(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        uint256 delayTimeLock\n    ) external returns (address pool);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n}\n"
    },
    "contracts/test/FireBirdFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IIsPair.sol\";\n\ncontract RequiemMock is IIsPair {\n    mapping(address => bool) public override isPair;\n\n    function setIsPair(address pair, bool val) external {\n        isPair[pair] = val;\n    }\n}\n"
    },
    "contracts/test/StakePoolRewardMultiplierMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardMultiplierMock is IStakePoolRewardMultiplier {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerBlock) external override view returns (uint) {\n        return _to.sub(_from).mul(_rewardPerBlock) .mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/test/DeflatingERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract DeflatingERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"Deflating Test Token\";\n    string public constant symbol = \"DTT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _totalSupply) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        uint256 burnAmount = value / 100;\n        _burn(from, burnAmount);\n        uint256 transferAmount = value.sub(burnAmount);\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\n        balanceOf[to] = balanceOf[to].add(transferAmount);\n        emit Transfer(from, to, transferAmount);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}