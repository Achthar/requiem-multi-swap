{
  "address": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
  "abi": [
    {
      "inputs": [],
      "name": "_MAX_INVARIANT_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_MAX_IN_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_MAX_OUT_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_MAX_WEIGHTED_TOKENS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_MIN_INVARIANT_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_MIN_WEIGHT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "bptAmountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalBPT",
          "type": "uint256"
        }
      ],
      "name": "_calcAllTokensInGivenExactBptOut",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "normalizedWeights",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amountsOut",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "bptTotalSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "_calcBptInGivenExactTokensOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "normalizedWeights",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amountsIn",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "bptTotalSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "_calcBptOutGivenExactTokensIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "normalizedWeight",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "previousInvariant",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentInvariant",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "protocolSwapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "_calcDueTokenProtocolSwapFeeAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balanceIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "weightIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balanceOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "weightOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "_calcInGivenOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balanceIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "weightIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balanceOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "weightOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "name": "_calcOutGivenIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "normalizedWeight",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bptAmountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bptTotalSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "_calcTokenInGivenExactBptOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "normalizedWeight",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bptAmountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bptTotalSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "_calcTokenOutGivenExactBptIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "bptAmountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalBPT",
          "type": "uint256"
        }
      ],
      "name": "_calcTokensOutGivenExactBptIn",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "normalizedWeights",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        }
      ],
      "name": "_calculateInvariant",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "invariant",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x6ba4347877626061a2bf62cf4216050f007f77bd9b6bee9638da8206d2838b41",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
    "transactionIndex": 0,
    "gasUsed": "2205053",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x723f920d014547abe604a2ef360930dff0236f278a5a317d7284f83cc17a549f",
    "transactionHash": "0x6ba4347877626061a2bf62cf4216050f007f77bd9b6bee9638da8206d2838b41",
    "logs": [],
    "blockNumber": 11,
    "cumulativeGasUsed": "2205053",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "805deb118869de4d09a8d2c6ccdde3e0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"_MAX_INVARIANT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_WEIGHTED_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MIN_INVARIANT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBPT\",\"type\":\"uint256\"}],\"name\":\"_calcAllTokensInGivenExactBptOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"normalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"_calcBptInGivenExactTokensOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"normalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"_calcBptOutGivenExactTokensIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalizedWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousInvariant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvariant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSwapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"_calcDueTokenProtocolSwapFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"_calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"_calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalizedWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"_calcTokenInGivenExactBptOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalizedWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"_calcTokenOutGivenExactBptIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBPT\",\"type\":\"uint256\"}],\"name\":\"_calcTokensOutGivenExactBptIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"normalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"_calculateInvariant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_calcTokenInGivenExactBptOut(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Intermediate function to avoid stack-too-deep \\\"\"},\"_calcTokenOutGivenExactBptIn(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Intermediate function to avoid stack-too-deep \\\"\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/weighted/RequiemWeightedMath.sol\":\"RequiemWeightedMath\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/interfaces/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\",\"keccak256\":\"0xb7230835a4efbbbebcb5371d121977e859388b33f3ee5d9a7a44fc4de8d6b970\",\"license\":\"MIT\"},\"contracts/interfaces/pool/IRequiemWeightedMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\\n// should be fixed.\\n// solhint-disable private-vars-leading-underscore\\n\\ninterface IRequiemWeightedMath {\\n    function _MIN_WEIGHT() external pure returns (uint256);\\n\\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\\n    function _MAX_WEIGHTED_TOKENS() external pure returns (uint256);\\n\\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\\n    // ratio).\\n\\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\\n    function _MAX_IN_RATIO() external pure returns (uint256);\\n\\n    function _MAX_OUT_RATIO() external pure returns (uint256);\\n\\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\\n    function _MAX_INVARIANT_RATIO() external pure returns (uint256);\\n\\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\\n    function _MIN_INVARIANT_RATIO() external pure returns (uint256);\\n\\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\\n    // and, because there is a minimum BPT, we round down the invariant.\\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances) external pure returns (uint256 invariant);\\n\\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\\n    // current balances and weights.\\n    function _calcOutGivenIn(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountIn\\n    ) external pure returns (uint256);\\n\\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\\n    // current balances and weights.\\n    function _calcInGivenOut(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountOut\\n    ) external pure returns (uint256);\\n\\n    function _calcBptOutGivenExactTokensIn(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256, uint256[] memory);\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    // function _computeJoinExactTokensInInvariantRatio(\\n    //     uint256[] memory balances,\\n    //     uint256[] memory normalizedWeights,\\n    //     uint256[] memory amountsIn,\\n    //     uint256[] memory balanceRatiosWithFee,\\n    //     uint256 invariantRatioWithFees,\\n    //     uint256 swapFeePercentage\\n    // ) external pure returns (uint256 invariantRatio, uint256[] memory swapFees);\\n\\n    function _calcTokenInGivenExactBptOut(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256 amountIn, uint256 swapFee);\\n\\n    function _calcAllTokensInGivenExactBptOut(\\n        uint256[] memory balances,\\n        uint256 bptAmountOut,\\n        uint256 totalBPT\\n    ) external pure returns (uint256[] memory);\\n\\n    function _calcBptInGivenExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256, uint256[] memory);\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    // function _computeExitExactTokensOutInvariantRatio(\\n    //     uint256[] memory balances,\\n    //     uint256[] memory normalizedWeights,\\n    //     uint256[] memory amountsOut,\\n    //     uint256[] memory balanceRatiosWithoutFee,\\n    //     uint256 invariantRatioWithoutFees,\\n    //     uint256 swapFeePercentage\\n    // ) external pure returns (uint256 invariantRatio, uint256[] memory swapFees);\\n\\n    function _calcTokenOutGivenExactBptIn(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256 amountOut, uint256 swapFee);\\n\\n    function _calcTokensOutGivenExactBptIn(\\n        uint256[] memory balances,\\n        uint256 bptAmountIn,\\n        uint256 totalBPT\\n    ) external pure returns (uint256[] memory);\\n\\n    function _calcDueTokenProtocolSwapFeeAmount(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 previousInvariant,\\n        uint256 currentInvariant,\\n        uint256 protocolSwapFeePercentage\\n    ) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0xeb00a346482e063ba62ee101bb558199d634663c556d7d0b7aaeb9fcce181c05\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/helpers/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../../interfaces/ERC20/IERC20.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        require(a == b, \\\"INPUT_LENGTH_MISMATCH\\\");\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        require(a == b && b == c, \\\"INPUT_LENGTH_MISMATCH\\\");\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            require(previous < current, \\\"UNSORTED_ARRAY\\\");\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1937824f5a6544d5495d6c8eb0228bd6d0ae362449858a479214e229f8df77bf\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/helpers/RequiemErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\n// solhint-disable\\nlibrary RequiemErrors {\\n    /**\\n     * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n     * supported.\\n     */\\n    function _require(bool condition, uint256 errorCode) internal pure {\\n        if (!condition) RequiemErrors._revert(errorCode);\\n    }\\n\\n    /**\\n     * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n     */\\n    function _revert(uint256 errorCode) internal pure {\\n        // We're going to dynamically create a revert string based on the error code, with the following format:\\n        // 'REQ#{errorCode}'\\n        // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n        //\\n        // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n        // number (8 to 16 bits) than the individual string characters.\\n        //\\n        // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n        // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n        // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n        assembly {\\n            // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n            // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n            // the '0' character.\\n\\n            let units := add(mod(errorCode, 10), 0x30)\\n\\n            errorCode := div(errorCode, 10)\\n            let tenths := add(mod(errorCode, 10), 0x30)\\n\\n            errorCode := div(errorCode, 10)\\n            let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n            // With the individual characters, we can now construct the full string. The \\\"REQ#\\\" part is a known constant\\n            // (0x52455123): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n            // characters to it, each shifted by a multiple of 8.\\n            // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n            // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n            // array).\\n\\n            let revertReason := shl(200, add(0x52455123000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n            // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n            // message will have the following layout:\\n            // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n            // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n            // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n            mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n            // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n            mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n            // The string length is fixed: 7 characters.\\n            mstore(0x24, 7)\\n            // Finally, the string itself is stored.\\n            mstore(0x44, revertReason)\\n\\n            // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n            // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n            revert(0, 100)\\n        }\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n    uint256 internal constant NOT_PAUSED = 431;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\",\"keccak256\":\"0x37ebaca1c58a9daf307229c45122f12d603a95d1d92c1a8e7648b1910755bfa0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./LogExpMath.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        require(b <= a, \\\"SUB_OVERFLOW\\\");\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        require(a == 0 || product / a == b, \\\"MUL_OVERFLOW\\\");\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        require(a == 0 || product / a == b, \\\"MUL_OVERFLOW\\\");\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0xe2959bd91a7efbccc2258eb94d48a5fc1602fa52d51dc43799b0c38fccd9f60d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/math/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \\u201cSoftware\\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \\u201cAS IS\\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.10;\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        require(x < 2**255, \\\"X_OUT_OF_BOUNDS\\\");\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        require(y < MILD_EXPONENT_BOUND, \\\"Y_OUT_OF_BOUNDS\\\");\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            \\\"PRODUCT_OUT_OF_BOUNDS\\\"\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \\\"INVALID_EXPONENT\\\");\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        require(a > 0, \\\"OUT_OF_BOUNDS\\\");\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\\n\",\"keccak256\":\"0x0eea00e060292852106f9a7db75300fc12112f4638fb657668955bd4491f074d\",\"license\":\"MIT\"},\"contracts/libraries/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SUB_OVERFLOW\\\");\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SUB_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        return roundUp ? divUp(a, b) : divDown(a, b);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07a18ca0ff454e4adbdb6bd509df38e4b0198c5118ff2494bf0f010fa3b8909c\",\"license\":\"MIT\"},\"contracts/libraries/weighted/RequiemWeightedMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./../math/FixedPoint.sol\\\";\\nimport \\\"./../math/Math.sol\\\";\\nimport \\\"../helpers/InputHelpers.sol\\\";\\nimport \\\"../helpers/RequiemErrors.sol\\\";\\nimport \\\"../../interfaces/pool/IRequiemWeightedMath.sol\\\";\\n\\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\\n// should be fixed.\\n// solhint-disable private-vars-leading-underscore\\n\\ncontract RequiemWeightedMath is IRequiemWeightedMath {\\n    using FixedPoint for uint256;\\n    // A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\\n    // implementation of the power function, as these ratios are often exponents.\\n    uint256 public constant _MIN_WEIGHT = 0.01e18;\\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\\n    uint256 public constant _MAX_WEIGHTED_TOKENS = 100;\\n\\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\\n    // ratio).\\n\\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\\n    uint256 public constant _MAX_IN_RATIO = 0.3e18;\\n    uint256 public constant _MAX_OUT_RATIO = 0.3e18;\\n\\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\\n    uint256 public constant _MAX_INVARIANT_RATIO = 3e18;\\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\\n    uint256 public constant _MIN_INVARIANT_RATIO = 0.7e18;\\n\\n    // About swap fees on joins and exits:\\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\\n    // swap fees, it follows that (some) joins and exits should as well.\\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\\n    // is the one to which swap fees are applied.\\n\\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\\n    // and, because there is a minimum BPT, we round down the invariant.\\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances) external pure returns (uint256 invariant) {\\n        /**********************************************************************************************\\n        // invariant               _____                                                             //\\n        // wi = weight index i      | |      wi                                                      //\\n        // bi = balance index i     | |  bi ^   = i                                                  //\\n        // i = invariant                                                                             //\\n        **********************************************************************************************/\\n\\n        invariant = FixedPoint.ONE;\\n        for (uint256 i = 0; i < normalizedWeights.length; i++) {\\n            invariant = invariant.mulDown(balances[i].powDown(normalizedWeights[i]));\\n        }\\n\\n        RequiemErrors._require(invariant > 0, Errors.ZERO_INVARIANT);\\n    }\\n\\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\\n    // current balances and weights.\\n    function _calcOutGivenIn(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountIn\\n    ) external pure returns (uint256) {\\n        /**********************************************************************************************\\n        // outGivenIn                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /      /            bI             \\\\    (wI / wO) \\\\           //\\n        // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\\n        // wI = weightIn               \\\\      \\\\       ( bI + aI )         /              /           //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount out, so we round down overall.\\n\\n        // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\\n        // Because bI / (bI + aI) <= 1, the exponent rounds down.\\n\\n        // Cannot exceed maximum in ratio\\n        RequiemErrors._require(amountIn <= balanceIn.mulDown(_MAX_IN_RATIO), Errors.MAX_IN_RATIO);\\n\\n        uint256 denominator = balanceIn + amountIn;\\n        uint256 base = balanceIn.divUp(denominator);\\n        uint256 exponent = weightIn.divDown(weightOut);\\n        uint256 power = base.powUp(exponent);\\n\\n        return balanceOut.mulDown(power.complement());\\n    }\\n\\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\\n    // current balances and weights.\\n    function _calcInGivenOut(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountOut\\n    ) external pure returns (uint256) {\\n        /**********************************************************************************************\\n        // inGivenOut                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /  /            bO             \\\\    (wO / wI)      \\\\          //\\n        // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\\n        // wI = weightIn               \\\\  \\\\       ( bO - aO )         /                   /          //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount in, so we round up overall.\\n\\n        // The multiplication rounds up, and the power rounds up (so the base rounds up too).\\n        // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\\n\\n        // Cannot exceed maximum out ratio\\n        RequiemErrors._require(amountOut <= balanceOut.mulDown(_MAX_OUT_RATIO), Errors.MAX_OUT_RATIO);\\n\\n        uint256 base = balanceOut.divUp(balanceOut - amountOut);\\n        uint256 exponent = weightOut.divUp(weightIn);\\n        uint256 power = base.powUp(exponent);\\n\\n        // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\\n        // the following subtraction should never revert.\\n        uint256 ratio = power - FixedPoint.ONE;\\n\\n        return balanceIn.mulUp(ratio);\\n    }\\n\\n    function _calcBptOutGivenExactTokensIn(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256, uint256[] memory) {\\n        // BPT out, so we round down overall.\\n\\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\\n\\n        uint256 invariantRatioWithFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithFee[i] = (balances[i] + amountsIn[i]).divDown(balances[i]);\\n            invariantRatioWithFees = invariantRatioWithFees + (balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeJoinExactTokensInInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsIn,\\n            balanceRatiosWithFee,\\n            invariantRatioWithFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptOut = (invariantRatio > FixedPoint.ONE) ? bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE) : 0;\\n        return (bptOut, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    function _computeJoinExactTokensInInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256[] memory balanceRatiosWithFee,\\n        uint256 invariantRatioWithFees,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\\n        // increase.\\n        swapFees = new uint256[](amountsIn.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 amountInWithoutFee;\\n\\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees - FixedPoint.ONE);\\n                uint256 taxableAmount = amountsIn[i] - nonTaxableAmount;\\n                uint256 swapFee = taxableAmount.mulUp(swapFeePercentage);\\n\\n                amountInWithoutFee = nonTaxableAmount + (taxableAmount - swapFee);\\n                swapFees[i] = swapFee;\\n            } else {\\n                amountInWithoutFee = amountsIn[i];\\n            }\\n\\n            uint256 balanceRatio = (balances[i] + amountInWithoutFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenInGivenExactBptOut(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256 amountIn, uint256 swapFee) {\\n        /******************************************************************************************\\n        // tokenInForExactBPTOut                                                                 //\\n        // a = amountIn                                                                          //\\n        // b = balance                      /  /    totalBPT + bptOut      \\\\    (1 / w)       \\\\  //\\n        // bptOut = bptAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\\n        // bpt = totalBPT                   \\\\  \\\\       totalBPT            /                  /  //\\n        // w = weight                                                                            //\\n        ******************************************************************************************/\\n\\n        // Token in, so we round up overall.\\n\\n        // Calculate the factor by which the invariant will increase after minting BPTAmountOut\\n        uint256 invariantRatio = (bptTotalSupply + bptAmountOut).divUp(bptTotalSupply);\\n        RequiemErrors._require(invariantRatio <= _MAX_INVARIANT_RATIO, Errors.MAX_OUT_BPT_FOR_TOKEN_IN);\\n\\n        // Calculate by how much the token balance has to increase to match the invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divUp(normalizedWeight));\\n\\n        uint256 amountInWithoutFee = balance.mulUp(balanceRatio - FixedPoint.ONE);\\n\\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\\n        // accordingly.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountInWithoutFee - taxableAmount;\\n\\n        uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\\n\\n        swapFee = taxableAmountPlusFees - taxableAmount;\\n        amountIn = nonTaxableAmount + taxableAmountPlusFees;\\n    }\\n\\n    function _calcAllTokensInGivenExactBptOut(\\n        uint256[] memory balances,\\n        uint256 bptAmountOut,\\n        uint256 totalBPT\\n    ) external pure returns (uint256[] memory) {\\n        /************************************************************************************\\n        // tokensInForExactBptOut                                                          //\\n        // (per token)                                                                     //\\n        // aI = amountIn                   /   bptOut   \\\\                                  //\\n        // b = balance           aI = b * | ------------ |                                 //\\n        // bptOut = bptAmountOut           \\\\  totalBPT  /                                  //\\n        // bpt = totalBPT                                                                  //\\n        ************************************************************************************/\\n\\n        // Tokens in, so we round up overall.\\n        uint256 bptRatio = bptAmountOut.divUp(totalBPT);\\n\\n        uint256[] memory amountsIn = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsIn[i] = balances[i].mulUp(bptRatio);\\n        }\\n\\n        return amountsIn;\\n    }\\n\\n    function _calcBptInGivenExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256, uint256[] memory) {\\n        // BPT in, so we round up overall.\\n\\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\\n        uint256 invariantRatioWithoutFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithoutFee[i] = (balances[i] - amountsOut[i]).divUp(balances[i]);\\n            invariantRatioWithoutFees = invariantRatioWithoutFees + (balanceRatiosWithoutFee[i].mulUp(normalizedWeights[i]));\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeExitExactTokensOutInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsOut,\\n            balanceRatiosWithoutFee,\\n            invariantRatioWithoutFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptIn = bptTotalSupply.mulUp(invariantRatio.complement());\\n        return (bptIn, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    function _computeExitExactTokensOutInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256[] memory balanceRatiosWithoutFee,\\n        uint256 invariantRatioWithoutFees,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        swapFees = new uint256[](amountsOut.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\\n            // 'token out'. This results in slightly larger price impact.\\n\\n            uint256 amountOutWithFee;\\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\\n                uint256 taxableAmount = amountsOut[i] - nonTaxableAmount;\\n                uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\\n\\n                swapFees[i] = taxableAmountPlusFees - taxableAmount;\\n                amountOutWithFee = nonTaxableAmount + taxableAmountPlusFees;\\n            } else {\\n                amountOutWithFee = amountsOut[i];\\n            }\\n\\n            uint256 balanceRatio = (balances[i] - amountOutWithFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenOutGivenExactBptIn(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) external pure returns (uint256 amountOut, uint256 swapFee) {\\n        /*****************************************************************************************\\n        // exactBPTInForTokenOut                                                                //\\n        // a = amountOut                                                                        //\\n        // b = balance                     /      /    totalBPT - bptIn       \\\\    (1 / w)  \\\\   //\\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\\n        // bpt = totalBPT                  \\\\      \\\\       totalBPT            /             /   //\\n        // w = weight                                                                           //\\n        *****************************************************************************************/\\n\\n        // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\\n        // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\\n\\n        // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\\n        uint256 invariantRatio = (bptTotalSupply - bptAmountIn).divUp(bptTotalSupply);\\n        RequiemErrors._require(invariantRatio >= _MIN_INVARIANT_RATIO, Errors.MIN_BPT_IN_FOR_TOKEN_OUT);\\n\\n        // Calculate by how much the token balance has to decrease to match invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\\n\\n        // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\\n        uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\\n\\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n        // in swap fees.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n\\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountOutWithoutFee - taxableAmount;\\n\\n        swapFee = taxableAmount.mulUp(swapFeePercentage);\\n        amountOut = nonTaxableAmount + (taxableAmount - swapFee);\\n    }\\n\\n    function _calcTokensOutGivenExactBptIn(\\n        uint256[] memory balances,\\n        uint256 bptAmountIn,\\n        uint256 totalBPT\\n    ) external pure returns (uint256[] memory) {\\n        /**********************************************************************************************\\n        // exactBPTInForTokensOut                                                                    //\\n        // (per token)                                                                               //\\n        // aO = amountOut                  /        bptIn         \\\\                                  //\\n        // b = balance           a0 = b * | ---------------------  |                                 //\\n        // bptIn = bptAmountIn             \\\\       totalBPT       /                                  //\\n        // bpt = totalBPT                                                                            //\\n        **********************************************************************************************/\\n\\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\\n        // multiplication and division.\\n\\n        uint256 bptRatio = bptAmountIn.divDown(totalBPT);\\n\\n        uint256[] memory amountsOut = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsOut[i] = balances[i].mulDown(bptRatio);\\n        }\\n\\n        return amountsOut;\\n    }\\n\\n    function _calcDueTokenProtocolSwapFeeAmount(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 previousInvariant,\\n        uint256 currentInvariant,\\n        uint256 protocolSwapFeePercentage\\n    ) external pure returns (uint256) {\\n        /*********************************************************************************\\n        /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\\n        *********************************************************************************/\\n\\n        if (currentInvariant <= previousInvariant) {\\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\\n            return 0;\\n        }\\n\\n        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\\n        // fees to the Vault.\\n\\n        // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\\n        // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\\n\\n        uint256 base = previousInvariant.divUp(currentInvariant);\\n        uint256 exponent = FixedPoint.ONE.divDown(normalizedWeight);\\n\\n        // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\\n        // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\\n        // 1 / min exponent) the Pool will pay less in protocol fees than it should.\\n        base = Math.max(base, FixedPoint.MIN_POW_BASE_FREE_EXPONENT);\\n\\n        uint256 power = base.powUp(exponent);\\n\\n        uint256 tokenAccruedFees = balance.mulDown(power.complement());\\n        return tokenAccruedFees.mulDown(protocolSwapFeePercentage);\\n    }\\n}\\n\",\"keccak256\":\"0xee376ccb23ab074a085117baaa9579519958026e3eafb43b747e98ce0521549a\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506126f7806100206000396000f3fe608060405234801561001057600080fd5b50600436106100d05760003560e01c80631152af7a146100d5578063256fae4c146100ff57806328953058146100ff5780632d09954d1461011c578063418307841461013c578063572c58a31461014a5780635ce3dd581461015d578063906c417514610170578063a62cdb8414610183578063a8c79d6914610192578063cac2832b146101ba578063e89dd41f146101cd578063e9be73ef146101e0578063ea9c12f9146101f3578063f8ce54ae14610202578063ff43734e14610215575b600080fd5b6100e86100e3366004612240565b61021d565b6040516100f6929190612314565b60405180910390f35b61010e670429d069189e000081565b6040519081526020016100f6565b61012f61012a36600461232d565b610394565b6040516100f6919061237a565b61010e662386f26fc1000081565b61010e61015836600461238d565b61045c565b61010e61016b3660046123f0565b6104ea565b61012f61017e36600461232d565b610567565b61010e6729a2241af62c000081565b6101a56101a03660046123f0565b61060f565b604080519283526020830191909152016100f6565b6101a56101c83660046123f0565b6106ec565b6100e86101db366004612240565b6107a2565b61010e6101ee3660046123f0565b610910565b61010e6709b6e64a8ec6000081565b61010e6102103660046123f0565b610986565b61010e606481565b60006060600085516001600160401b0381111561023c5761023c61219b565b604051908082528060200260200182016040528015610265578160200160208202803683370190505b5090506000805b8951811015610357576102d68a828151811061028a5761028a61242b565b60200260200101518983815181106102a4576102a461242b565b60200260200101518c84815181106102be576102be61242b565b60200260200101516102d09190612457565b906109f7565b8382815181106102e8576102e861242b565b6020026020010181815250506103398982815181106103095761030961242b565b60200260200101518483815181106103235761032361242b565b6020026020010151610a9b90919063ffffffff16565b610343908361246e565b91508061034f81612486565b91505061026c565b506000806103698b8b8b87878c610afe565b91509150600061038261037b84610ce3565b8a90610a9b565b9c919b50909950505050505050505050565b606060006103a28484610d0d565b9050600085516001600160401b038111156103bf576103bf61219b565b6040519080825280602002602001820160405280156103e8578160200160208202803683370190505b50905060005b8651811015610452576104238388838151811061040d5761040d61242b565b6020026020010151610d8990919063ffffffff16565b8282815181106104355761043561242b565b60209081029190910101528061044a81612486565b9150506103ee565b5095945050505050565b670de0b6b3a764000060005b83518110156104d4576104c06104b98583815181106104895761048961242b565b60200260200101518584815181106104a3576104a361242b565b6020026020010151610de390919063ffffffff16565b8390610d89565b9150806104cc81612486565b915050610468565b506104e460008211610137610e32565b92915050565b600061050c61050187670429d069189e0000610d89565b831115610130610e32565b6000610518838861246e565b9050600061052688836109f7565b905060006105348887610d0d565b905060006105428383610e44565b905061055761055082610ce3565b8990610d89565b9450505050505b95945050505050565b6060600061057584846109f7565b9050600085516001600160401b038111156105925761059261219b565b6040519080825280602002602001820160405280156105bb578160200160208202803683370190505b50905060005b8651811015610452576105e0838883815181106103235761032361242b565b8282815181106105f2576105f261242b565b60209081029190910101528061060781612486565b9150506105c1565b60008080610621856102d0888261246e565b905061063a6729a2241af62c0000821115610133610e32565b6000610658610651670de0b6b3a76400008a6109f7565b8390610e44565b90506000610678610671670de0b6b3a764000084612457565b8b90610a9b565b905060006106858a610ce3565b905060006106938383610a9b565b905060006106a18285612457565b905060006106c16106ba8b670de0b6b3a7640000612457565b84906109f7565b90506106cd8382612457565b97506106d9818361246e565b9850505050505050509550959350505050565b600080806106fe856102d08882612457565b90506107176709b6e64a8ec60000821015610132610e32565b600061072e610651670de0b6b3a76400008a610d0d565b9050600061074561073e83610ce3565b8b90610d89565b905060006107528a610ce3565b905060006107608383610a9b565b9050600061076e8285612457565b905061077a828a610a9b565b96506107868783612457565b610790908261246e565b97505050505050509550959350505050565b60006060600085516001600160401b038111156107c1576107c161219b565b6040519080825280602002602001820160405280156107ea578160200160208202803683370190505b5090506000805b89518110156108c65761085b8a828151811061080f5761080f61242b565b60200260200101518983815181106108295761082961242b565b60200260200101518c84815181106108435761084361242b565b6020026020010151610855919061246e565b90610d0d565b83828151811061086d5761086d61242b565b6020026020010181815250506108a889828151811061088e5761088e61242b565b602002602001015184838151811061040d5761040d61242b565b6108b2908361246e565b9150806108be81612486565b9150506107f1565b506000806108d88b8b8b87878c610e70565b915091506000670de0b6b3a764000083116108f4576000610382565b610382610909670de0b6b3a764000085612457565b8a90610d89565b600061093261092785670429d069189e0000610d89565b831115610131610e32565b60006109486109418487612457565b86906109f7565b9050600061095685886109f7565b905060006109648383610e44565b9050600061097a670de0b6b3a764000083612457565b90506105578a82610a9b565b60008383116109975750600061055e565b60006109a385856109f7565b905060006109b9670de0b6b3a764000088610d0d565b90506109cd826709b6e64a8ec60000611000565b915060006109db8383610e44565b905060006109eb61073e83610ce3565b90506105578187610d89565b600081610a1f5760405162461bcd60e51b8152600401610a16906124a1565b60405180910390fd5b82610a2c575060006104e4565b6000610a40670de0b6b3a7640000856124c8565b9050670de0b6b3a7640000610a5585836124fd565b14610a725760405162461bcd60e51b8152600401610a1690612511565b82610a7e600183612457565b610a8891906124fd565b610a9390600161246e565b9150506104e4565b600080610aa883856124c8565b9050831580610abf575082610abd85836124fd565b145b610adb5760405162461bcd60e51b8152600401610a1690612537565b80610aea5760009150506104e4565b670de0b6b3a7640000610a7e600183612457565b6000606085516001600160401b03811115610b1b57610b1b61219b565b604051908082528060200260200182016040528015610b44578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015610cd7576000868281518110610b7257610b7261242b565b6020026020010151861115610c27576000610ba1610b8f88610ce3565b8c858151811061040d5761040d61242b565b90506000818a8581518110610bb857610bb861242b565b6020026020010151610bca9190612457565b90506000610bea610be389670de0b6b3a7640000612457565b83906109f7565b9050610bf68282612457565b868681518110610c0857610c0861242b565b6020908102919091010152610c1d818461246e565b9350505050610c44565b878281518110610c3957610c3961242b565b602002602001015190505b6000610c888b8481518110610c5b57610c5b61242b565b6020026020010151838d8681518110610c7657610c7661242b565b60200260200101516108559190612457565b9050610cc0610cb98b8581518110610ca257610ca261242b565b602002602001015183610de390919063ffffffff16565b8690610d89565b945050508080610ccf90612486565b915050610b55565b50965096945050505050565b6000670de0b6b3a76400008210610cfb5760006104e4565b6104e482670de0b6b3a7640000612457565b600081610d2c5760405162461bcd60e51b8152600401610a16906124a1565b82610d39575060006104e4565b6000610d4d670de0b6b3a7640000856124c8565b9050670de0b6b3a7640000610d6285836124fd565b14610d7f5760405162461bcd60e51b8152600401610a1690612511565b610a9383826124fd565b600080610d9683856124c8565b9050831580610dad575082610dab85836124fd565b145b610dc95760405162461bcd60e51b8152600401610a1690612537565b610ddb670de0b6b3a7640000826124fd565b949350505050565b600080610df08484611019565b90506000610e0a610e0383612710610a9b565b600161122a565b905080821015610e1f576000925050506104e4565b610e298282611278565b925050506104e4565b81610e4057610e40816112c5565b5050565b600080610e518484611019565b90506000610e64610e0383612710610a9b565b905061055e828261122a565b6000606085516001600160401b03811115610e8d57610e8d61219b565b604051908082528060200260200182016040528015610eb6578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015610cd757600085878381518110610ee557610ee561242b565b60200260200101511115610f80576000610f0a610b8f670de0b6b3a764000089612457565b90506000818a8581518110610f2157610f2161242b565b6020026020010151610f339190612457565b90506000610f418289610a9b565b9050610f4d8183612457565b610f57908461246e565b935080868681518110610f6c57610f6c61242b565b602002602001018181525050505050610f9d565b878281518110610f9257610f9261242b565b602002602001015190505b6000610fcf8b8481518110610fb457610fb461242b565b6020026020010151838d86815181106108435761084361242b565b9050610fe9610cb98b8581518110610ca257610ca261242b565b945050508080610ff890612486565b915050610ec7565b6000818310156110105781611012565b825b9392505050565b60008161102f5750670de0b6b3a76400006104e4565b8261103c575060006104e4565b600160ff1b83106110815760405162461bcd60e51b815260206004820152600f60248201526e585f4f55545f4f465f424f554e445360881b6044820152606401610a16565b8261109968056bc75e2d63100000600160fe1b6124fd565b83106110d95760405162461bcd60e51b815260206004820152600f60248201526e595f4f55545f4f465f424f554e445360881b6044820152606401610a16565b826000826110f767016345785d8a0000670de0b6b3a764000061255d565b12801561111c5750611119670de0b6b3a764000067016345785d8a000061259c565b83125b1561118557600061112c84611318565b9050670de0b6b3a76400008361114282846125dd565b61114c91906125f1565b6111569190612676565b83611169670de0b6b3a764000084612676565b61117391906125f1565b61117d919061259c565b91505061119c565b8161118f8461154f565b61119991906125f1565b90505b6111ae670de0b6b3a764000082612676565b905080680238fd42c5cf03ffff19131580156111d3575068070c1cc73b00c800008113155b6112175760405162461bcd60e51b815260206004820152601560248201527450524f445543545f4f55545f4f465f424f554e445360581b6044820152606401610a16565b61122081611b31565b9695505050505050565b600080611237838561246e565b9050838110156110125760405162461bcd60e51b815260206004820152600c60248201526b4144445f4f564552464c4f5760a01b6044820152606401610a16565b6000828211156112b95760405162461bcd60e51b815260206004820152600c60248201526b5355425f4f564552464c4f5760a01b6044820152606401610a16565b6000610ddb8385612457565b62461bcd60e51b6000908152602060045260076024526652455123000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b600061132c670de0b6b3a7640000836125f1565b915060006113486a0c097ce7bc90715b34b9f160241b8461259c565b6a0c097ce7bc90715b34b9f160241b611361818661255d565b61136b91906125f1565b6113759190612676565b905060006a0c097ce7bc90715b34b9f160241b61139283806125f1565b61139c9190612676565b905081806a0c097ce7bc90715b34b9f160241b6113b984836125f1565b6113c39190612676565b91506113d0600383612676565b6113da908261259c565b90506a0c097ce7bc90715b34b9f160241b6113f584846125f1565b6113ff9190612676565b915061140c600583612676565b611416908261259c565b90506a0c097ce7bc90715b34b9f160241b61143184846125f1565b61143b9190612676565b9150611448600783612676565b611452908261259c565b90506a0c097ce7bc90715b34b9f160241b61146d84846125f1565b6114779190612676565b9150611484600983612676565b61148e908261259c565b90506a0c097ce7bc90715b34b9f160241b6114a984846125f1565b6114b39190612676565b91506114c0600b83612676565b6114ca908261259c565b90506a0c097ce7bc90715b34b9f160241b6114e584846125f1565b6114ef9190612676565b91506114fc600d83612676565b611506908261259c565b90506a0c097ce7bc90715b34b9f160241b61152184846125f1565b61152b9190612676565b9150611538600f83612676565b611542908261259c565b90506112208160026125f1565b6000670de0b6b3a764000082121561158f5761158682611577670de0b6b3a7640000806125f1565b6115819190612676565b61154f565b6104e4906126a4565b60006115b9670de0b6b3a764000072195e54c5dd42177f53a27172fa9ec63026282760241b6125f1565b83126115f7576115df72195e54c5dd42177f53a27172fa9ec63026282760241b84612676565b92506115f46806f05b59d3b20000008261259c565b90505b611615670de0b6b3a76400006b1425982cf597cd205cef73806125f1565b8312611649576116316b1425982cf597cd205cef738084612676565b92506116466803782dace9d90000008261259c565b90505b6116546064826125f1565b90506116616064846125f1565b92506e01855144814a7ff805980ff008400083126116be576e01855144814a7ff805980ff008400061169c68056bc75e2d63100000856125f1565b6116a69190612676565b92506116bb68ad78ebc5ac620000008261259c565b90505b6b02df0ab5a80a22c61ab5a7008312611713576b02df0ab5a80a22c61ab5a7006116f168056bc75e2d63100000856125f1565b6116fb9190612676565b92506117106856bc75e2d6310000008261259c565b90505b693f1fce3da636ea5cf850831261176457693f1fce3da636ea5cf85061174268056bc75e2d63100000856125f1565b61174c9190612676565b9250611761682b5e3af16b188000008261259c565b90505b690127fa27722cc06cc5e283126117b557690127fa27722cc06cc5e261179368056bc75e2d63100000856125f1565b61179d9190612676565b92506117b26815af1d78b58c4000008261259c565b90505b68280e60114edb805d0383126118045768280e60114edb805d036117e268056bc75e2d63100000856125f1565b6117ec9190612676565b9250611801680ad78ebc5ac62000008261259c565b90505b680ebc5fb41746121110831261185357680ebc5fb4174612111061183168056bc75e2d63100000856125f1565b61183b9190612676565b925061185068056bc75e2d631000008261259c565b90505b6808f00f760a4b2db55d83126118a2576808f00f760a4b2db55d61188068056bc75e2d63100000856125f1565b61188a9190612676565b925061189f6802b5e3af16b18800008261259c565b90505b6806f5f177578893793783126118f1576806f5f17757889379376118cf68056bc75e2d63100000856125f1565b6118d99190612676565b92506118ee68015af1d78b58c400008261259c565b90505b6806248f33704b286603831261193f576806248f33704b28660361191e68056bc75e2d63100000856125f1565b6119289190612676565b925061193c67ad78ebc5ac6200008261259c565b90505b6805c548670b9510e7ac831261198d576805c548670b9510e7ac61196c68056bc75e2d63100000856125f1565b6119769190612676565b925061198a6756bc75e2d63100008261259c565b90505b60006119a268056bc75e2d631000008561259c565b68056bc75e2d631000006119b6818761255d565b6119c091906125f1565b6119ca9190612676565b9050600068056bc75e2d631000006119e283806125f1565b6119ec9190612676565b9050818068056bc75e2d63100000611a0484836125f1565b611a0e9190612676565b9150611a1b600383612676565b611a25908261259c565b905068056bc75e2d63100000611a3b84846125f1565b611a459190612676565b9150611a52600583612676565b611a5c908261259c565b905068056bc75e2d63100000611a7284846125f1565b611a7c9190612676565b9150611a89600783612676565b611a93908261259c565b905068056bc75e2d63100000611aa984846125f1565b611ab39190612676565b9150611ac0600983612676565b611aca908261259c565b905068056bc75e2d63100000611ae084846125f1565b611aea9190612676565b9150611af7600b83612676565b611b01908261259c565b9050611b0e6002826125f1565b90506064611b1c828761259c565b611b269190612676565b979650505050505050565b6000680238fd42c5cf03ffff198212158015611b56575068070c1cc73b00c800008213155b611b955760405162461bcd60e51b815260206004820152601060248201526f1253959053125117d1561413d391539560821b6044820152606401610a16565b6000821215611bcb57611baf611baa836126a4565b611b31565b611bc1670de0b6b3a7640000806125f1565b6104e49190612676565b60006806f05b59d3b20000008312611c1057611bf06806f05b59d3b20000008461255d565b925072195e54c5dd42177f53a27172fa9ec63026282760241b9050611c4d565b6803782dace9d90000008312611c4957611c336803782dace9d90000008461255d565b92506b1425982cf597cd205cef73809050611c4d565b5060015b611c586064846125f1565b925068056bc75e2d6310000068ad78ebc5ac620000008412611cb957611c8768ad78ebc5ac620000008561255d565b935068056bc75e2d63100000611cac6e01855144814a7ff805980ff0084000836125f1565b611cb69190612676565b90505b6856bc75e2d6310000008412611d0b57611cdc6856bc75e2d6310000008561255d565b935068056bc75e2d63100000611cfe6b02df0ab5a80a22c61ab5a700836125f1565b611d089190612676565b90505b682b5e3af16b188000008412611d5b57611d2e682b5e3af16b188000008561255d565b935068056bc75e2d63100000611d4e693f1fce3da636ea5cf850836125f1565b611d589190612676565b90505b6815af1d78b58c4000008412611dab57611d7e6815af1d78b58c4000008561255d565b935068056bc75e2d63100000611d9e690127fa27722cc06cc5e2836125f1565b611da89190612676565b90505b680ad78ebc5ac62000008412611dfa57611dce680ad78ebc5ac62000008561255d565b935068056bc75e2d63100000611ded68280e60114edb805d03836125f1565b611df79190612676565b90505b68056bc75e2d631000008412611e4957611e1d68056bc75e2d631000008561255d565b935068056bc75e2d63100000611e3c680ebc5fb41746121110836125f1565b611e469190612676565b90505b6802b5e3af16b18800008412611e9857611e6c6802b5e3af16b18800008561255d565b935068056bc75e2d63100000611e8b6808f00f760a4b2db55d836125f1565b611e959190612676565b90505b68015af1d78b58c400008412611ee757611ebb68015af1d78b58c400008561255d565b935068056bc75e2d63100000611eda6806f5f1775788937937836125f1565b611ee49190612676565b90505b68056bc75e2d6310000084611efc818361259c565b9150600268056bc75e2d63100000611f1488846125f1565b611f1e9190612676565b611f289190612676565b9050611f34818361259c565b9150600368056bc75e2d63100000611f4c88846125f1565b611f569190612676565b611f609190612676565b9050611f6c818361259c565b9150600468056bc75e2d63100000611f8488846125f1565b611f8e9190612676565b611f989190612676565b9050611fa4818361259c565b9150600568056bc75e2d63100000611fbc88846125f1565b611fc69190612676565b611fd09190612676565b9050611fdc818361259c565b9150600668056bc75e2d63100000611ff488846125f1565b611ffe9190612676565b6120089190612676565b9050612014818361259c565b9150600768056bc75e2d6310000061202c88846125f1565b6120369190612676565b6120409190612676565b905061204c818361259c565b9150600868056bc75e2d6310000061206488846125f1565b61206e9190612676565b6120789190612676565b9050612084818361259c565b9150600968056bc75e2d6310000061209c88846125f1565b6120a69190612676565b6120b09190612676565b90506120bc818361259c565b9150600a68056bc75e2d631000006120d488846125f1565b6120de9190612676565b6120e89190612676565b90506120f4818361259c565b9150600b68056bc75e2d6310000061210c88846125f1565b6121169190612676565b6121209190612676565b905061212c818361259c565b9150600c68056bc75e2d6310000061214488846125f1565b61214e9190612676565b6121589190612676565b9050612164818361259c565b915060648468056bc75e2d6310000061217d85876125f1565b6121879190612676565b61219191906125f1565b6112209190612676565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126121c257600080fd5b813560206001600160401b03808311156121de576121de61219b565b8260051b604051601f19603f830116810181811084821117156122035761220361219b565b60405293845285810183019383810192508785111561222157600080fd5b83870191505b84821015611b2657813583529183019190830190612227565b600080600080600060a0868803121561225857600080fd5b85356001600160401b038082111561226f57600080fd5b61227b89838a016121b1565b9650602088013591508082111561229157600080fd5b61229d89838a016121b1565b955060408801359150808211156122b357600080fd5b506122c0888289016121b1565b9598949750949560608101359550608001359392505050565b600081518084526020808501945080840160005b83811015612309578151875295820195908201906001016122ed565b509495945050505050565b828152604060208201526000610ddb60408301846122d9565b60008060006060848603121561234257600080fd5b83356001600160401b0381111561235857600080fd5b612364868287016121b1565b9660208601359650604090950135949350505050565b60208152600061101260208301846122d9565b600080604083850312156123a057600080fd5b82356001600160401b03808211156123b757600080fd5b6123c3868387016121b1565b935060208501359150808211156123d957600080fd5b506123e6858286016121b1565b9150509250929050565b600080600080600060a0868803121561240857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60008282101561246957612469612441565b500390565b6000821982111561248157612481612441565b500190565b600060001982141561249a5761249a612441565b5060010190565b6020808252600d908201526c2d22a927afa224ab24a9a4a7a760991b604082015260600190565b60008160001904831182151516156124e2576124e2612441565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261250c5761250c6124e7565b500490565b6020808252600c908201526b11125597d25395115493905360a21b604082015260600190565b6020808252600c908201526b4d554c5f4f564552464c4f5760a01b604082015260600190565b60008083128015600160ff1b85018412161561257b5761257b612441565b6001600160ff1b038401831381161561259657612596612441565b50500390565b600080821280156001600160ff1b03849003851316156125be576125be612441565b600160ff1b83900384128116156125d7576125d7612441565b50500190565b6000826125ec576125ec6124e7565b500790565b60006001600160ff1b038184138284138082168684048611161561261757612617612441565b600160ff1b600087128281168783058912161561263657612636612441565b6000871292508782058712848416161561265257612652612441565b8785058712818416161561266857612668612441565b505050929093029392505050565b600082612685576126856124e7565b600160ff1b82146000198414161561269f5761269f612441565b500590565b6000600160ff1b8214156126ba576126ba612441565b506000039056fea2646970667358221220bfd9b5d452de7abebcb4805dc43dbb8d7109723834cd5f938dc421dccbd56cb964736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d05760003560e01c80631152af7a146100d5578063256fae4c146100ff57806328953058146100ff5780632d09954d1461011c578063418307841461013c578063572c58a31461014a5780635ce3dd581461015d578063906c417514610170578063a62cdb8414610183578063a8c79d6914610192578063cac2832b146101ba578063e89dd41f146101cd578063e9be73ef146101e0578063ea9c12f9146101f3578063f8ce54ae14610202578063ff43734e14610215575b600080fd5b6100e86100e3366004612240565b61021d565b6040516100f6929190612314565b60405180910390f35b61010e670429d069189e000081565b6040519081526020016100f6565b61012f61012a36600461232d565b610394565b6040516100f6919061237a565b61010e662386f26fc1000081565b61010e61015836600461238d565b61045c565b61010e61016b3660046123f0565b6104ea565b61012f61017e36600461232d565b610567565b61010e6729a2241af62c000081565b6101a56101a03660046123f0565b61060f565b604080519283526020830191909152016100f6565b6101a56101c83660046123f0565b6106ec565b6100e86101db366004612240565b6107a2565b61010e6101ee3660046123f0565b610910565b61010e6709b6e64a8ec6000081565b61010e6102103660046123f0565b610986565b61010e606481565b60006060600085516001600160401b0381111561023c5761023c61219b565b604051908082528060200260200182016040528015610265578160200160208202803683370190505b5090506000805b8951811015610357576102d68a828151811061028a5761028a61242b565b60200260200101518983815181106102a4576102a461242b565b60200260200101518c84815181106102be576102be61242b565b60200260200101516102d09190612457565b906109f7565b8382815181106102e8576102e861242b565b6020026020010181815250506103398982815181106103095761030961242b565b60200260200101518483815181106103235761032361242b565b6020026020010151610a9b90919063ffffffff16565b610343908361246e565b91508061034f81612486565b91505061026c565b506000806103698b8b8b87878c610afe565b91509150600061038261037b84610ce3565b8a90610a9b565b9c919b50909950505050505050505050565b606060006103a28484610d0d565b9050600085516001600160401b038111156103bf576103bf61219b565b6040519080825280602002602001820160405280156103e8578160200160208202803683370190505b50905060005b8651811015610452576104238388838151811061040d5761040d61242b565b6020026020010151610d8990919063ffffffff16565b8282815181106104355761043561242b565b60209081029190910101528061044a81612486565b9150506103ee565b5095945050505050565b670de0b6b3a764000060005b83518110156104d4576104c06104b98583815181106104895761048961242b565b60200260200101518584815181106104a3576104a361242b565b6020026020010151610de390919063ffffffff16565b8390610d89565b9150806104cc81612486565b915050610468565b506104e460008211610137610e32565b92915050565b600061050c61050187670429d069189e0000610d89565b831115610130610e32565b6000610518838861246e565b9050600061052688836109f7565b905060006105348887610d0d565b905060006105428383610e44565b905061055761055082610ce3565b8990610d89565b9450505050505b95945050505050565b6060600061057584846109f7565b9050600085516001600160401b038111156105925761059261219b565b6040519080825280602002602001820160405280156105bb578160200160208202803683370190505b50905060005b8651811015610452576105e0838883815181106103235761032361242b565b8282815181106105f2576105f261242b565b60209081029190910101528061060781612486565b9150506105c1565b60008080610621856102d0888261246e565b905061063a6729a2241af62c0000821115610133610e32565b6000610658610651670de0b6b3a76400008a6109f7565b8390610e44565b90506000610678610671670de0b6b3a764000084612457565b8b90610a9b565b905060006106858a610ce3565b905060006106938383610a9b565b905060006106a18285612457565b905060006106c16106ba8b670de0b6b3a7640000612457565b84906109f7565b90506106cd8382612457565b97506106d9818361246e565b9850505050505050509550959350505050565b600080806106fe856102d08882612457565b90506107176709b6e64a8ec60000821015610132610e32565b600061072e610651670de0b6b3a76400008a610d0d565b9050600061074561073e83610ce3565b8b90610d89565b905060006107528a610ce3565b905060006107608383610a9b565b9050600061076e8285612457565b905061077a828a610a9b565b96506107868783612457565b610790908261246e565b97505050505050509550959350505050565b60006060600085516001600160401b038111156107c1576107c161219b565b6040519080825280602002602001820160405280156107ea578160200160208202803683370190505b5090506000805b89518110156108c65761085b8a828151811061080f5761080f61242b565b60200260200101518983815181106108295761082961242b565b60200260200101518c84815181106108435761084361242b565b6020026020010151610855919061246e565b90610d0d565b83828151811061086d5761086d61242b565b6020026020010181815250506108a889828151811061088e5761088e61242b565b602002602001015184838151811061040d5761040d61242b565b6108b2908361246e565b9150806108be81612486565b9150506107f1565b506000806108d88b8b8b87878c610e70565b915091506000670de0b6b3a764000083116108f4576000610382565b610382610909670de0b6b3a764000085612457565b8a90610d89565b600061093261092785670429d069189e0000610d89565b831115610131610e32565b60006109486109418487612457565b86906109f7565b9050600061095685886109f7565b905060006109648383610e44565b9050600061097a670de0b6b3a764000083612457565b90506105578a82610a9b565b60008383116109975750600061055e565b60006109a385856109f7565b905060006109b9670de0b6b3a764000088610d0d565b90506109cd826709b6e64a8ec60000611000565b915060006109db8383610e44565b905060006109eb61073e83610ce3565b90506105578187610d89565b600081610a1f5760405162461bcd60e51b8152600401610a16906124a1565b60405180910390fd5b82610a2c575060006104e4565b6000610a40670de0b6b3a7640000856124c8565b9050670de0b6b3a7640000610a5585836124fd565b14610a725760405162461bcd60e51b8152600401610a1690612511565b82610a7e600183612457565b610a8891906124fd565b610a9390600161246e565b9150506104e4565b600080610aa883856124c8565b9050831580610abf575082610abd85836124fd565b145b610adb5760405162461bcd60e51b8152600401610a1690612537565b80610aea5760009150506104e4565b670de0b6b3a7640000610a7e600183612457565b6000606085516001600160401b03811115610b1b57610b1b61219b565b604051908082528060200260200182016040528015610b44578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015610cd7576000868281518110610b7257610b7261242b565b6020026020010151861115610c27576000610ba1610b8f88610ce3565b8c858151811061040d5761040d61242b565b90506000818a8581518110610bb857610bb861242b565b6020026020010151610bca9190612457565b90506000610bea610be389670de0b6b3a7640000612457565b83906109f7565b9050610bf68282612457565b868681518110610c0857610c0861242b565b6020908102919091010152610c1d818461246e565b9350505050610c44565b878281518110610c3957610c3961242b565b602002602001015190505b6000610c888b8481518110610c5b57610c5b61242b565b6020026020010151838d8681518110610c7657610c7661242b565b60200260200101516108559190612457565b9050610cc0610cb98b8581518110610ca257610ca261242b565b602002602001015183610de390919063ffffffff16565b8690610d89565b945050508080610ccf90612486565b915050610b55565b50965096945050505050565b6000670de0b6b3a76400008210610cfb5760006104e4565b6104e482670de0b6b3a7640000612457565b600081610d2c5760405162461bcd60e51b8152600401610a16906124a1565b82610d39575060006104e4565b6000610d4d670de0b6b3a7640000856124c8565b9050670de0b6b3a7640000610d6285836124fd565b14610d7f5760405162461bcd60e51b8152600401610a1690612511565b610a9383826124fd565b600080610d9683856124c8565b9050831580610dad575082610dab85836124fd565b145b610dc95760405162461bcd60e51b8152600401610a1690612537565b610ddb670de0b6b3a7640000826124fd565b949350505050565b600080610df08484611019565b90506000610e0a610e0383612710610a9b565b600161122a565b905080821015610e1f576000925050506104e4565b610e298282611278565b925050506104e4565b81610e4057610e40816112c5565b5050565b600080610e518484611019565b90506000610e64610e0383612710610a9b565b905061055e828261122a565b6000606085516001600160401b03811115610e8d57610e8d61219b565b604051908082528060200260200182016040528015610eb6578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015610cd757600085878381518110610ee557610ee561242b565b60200260200101511115610f80576000610f0a610b8f670de0b6b3a764000089612457565b90506000818a8581518110610f2157610f2161242b565b6020026020010151610f339190612457565b90506000610f418289610a9b565b9050610f4d8183612457565b610f57908461246e565b935080868681518110610f6c57610f6c61242b565b602002602001018181525050505050610f9d565b878281518110610f9257610f9261242b565b602002602001015190505b6000610fcf8b8481518110610fb457610fb461242b565b6020026020010151838d86815181106108435761084361242b565b9050610fe9610cb98b8581518110610ca257610ca261242b565b945050508080610ff890612486565b915050610ec7565b6000818310156110105781611012565b825b9392505050565b60008161102f5750670de0b6b3a76400006104e4565b8261103c575060006104e4565b600160ff1b83106110815760405162461bcd60e51b815260206004820152600f60248201526e585f4f55545f4f465f424f554e445360881b6044820152606401610a16565b8261109968056bc75e2d63100000600160fe1b6124fd565b83106110d95760405162461bcd60e51b815260206004820152600f60248201526e595f4f55545f4f465f424f554e445360881b6044820152606401610a16565b826000826110f767016345785d8a0000670de0b6b3a764000061255d565b12801561111c5750611119670de0b6b3a764000067016345785d8a000061259c565b83125b1561118557600061112c84611318565b9050670de0b6b3a76400008361114282846125dd565b61114c91906125f1565b6111569190612676565b83611169670de0b6b3a764000084612676565b61117391906125f1565b61117d919061259c565b91505061119c565b8161118f8461154f565b61119991906125f1565b90505b6111ae670de0b6b3a764000082612676565b905080680238fd42c5cf03ffff19131580156111d3575068070c1cc73b00c800008113155b6112175760405162461bcd60e51b815260206004820152601560248201527450524f445543545f4f55545f4f465f424f554e445360581b6044820152606401610a16565b61122081611b31565b9695505050505050565b600080611237838561246e565b9050838110156110125760405162461bcd60e51b815260206004820152600c60248201526b4144445f4f564552464c4f5760a01b6044820152606401610a16565b6000828211156112b95760405162461bcd60e51b815260206004820152600c60248201526b5355425f4f564552464c4f5760a01b6044820152606401610a16565b6000610ddb8385612457565b62461bcd60e51b6000908152602060045260076024526652455123000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b600061132c670de0b6b3a7640000836125f1565b915060006113486a0c097ce7bc90715b34b9f160241b8461259c565b6a0c097ce7bc90715b34b9f160241b611361818661255d565b61136b91906125f1565b6113759190612676565b905060006a0c097ce7bc90715b34b9f160241b61139283806125f1565b61139c9190612676565b905081806a0c097ce7bc90715b34b9f160241b6113b984836125f1565b6113c39190612676565b91506113d0600383612676565b6113da908261259c565b90506a0c097ce7bc90715b34b9f160241b6113f584846125f1565b6113ff9190612676565b915061140c600583612676565b611416908261259c565b90506a0c097ce7bc90715b34b9f160241b61143184846125f1565b61143b9190612676565b9150611448600783612676565b611452908261259c565b90506a0c097ce7bc90715b34b9f160241b61146d84846125f1565b6114779190612676565b9150611484600983612676565b61148e908261259c565b90506a0c097ce7bc90715b34b9f160241b6114a984846125f1565b6114b39190612676565b91506114c0600b83612676565b6114ca908261259c565b90506a0c097ce7bc90715b34b9f160241b6114e584846125f1565b6114ef9190612676565b91506114fc600d83612676565b611506908261259c565b90506a0c097ce7bc90715b34b9f160241b61152184846125f1565b61152b9190612676565b9150611538600f83612676565b611542908261259c565b90506112208160026125f1565b6000670de0b6b3a764000082121561158f5761158682611577670de0b6b3a7640000806125f1565b6115819190612676565b61154f565b6104e4906126a4565b60006115b9670de0b6b3a764000072195e54c5dd42177f53a27172fa9ec63026282760241b6125f1565b83126115f7576115df72195e54c5dd42177f53a27172fa9ec63026282760241b84612676565b92506115f46806f05b59d3b20000008261259c565b90505b611615670de0b6b3a76400006b1425982cf597cd205cef73806125f1565b8312611649576116316b1425982cf597cd205cef738084612676565b92506116466803782dace9d90000008261259c565b90505b6116546064826125f1565b90506116616064846125f1565b92506e01855144814a7ff805980ff008400083126116be576e01855144814a7ff805980ff008400061169c68056bc75e2d63100000856125f1565b6116a69190612676565b92506116bb68ad78ebc5ac620000008261259c565b90505b6b02df0ab5a80a22c61ab5a7008312611713576b02df0ab5a80a22c61ab5a7006116f168056bc75e2d63100000856125f1565b6116fb9190612676565b92506117106856bc75e2d6310000008261259c565b90505b693f1fce3da636ea5cf850831261176457693f1fce3da636ea5cf85061174268056bc75e2d63100000856125f1565b61174c9190612676565b9250611761682b5e3af16b188000008261259c565b90505b690127fa27722cc06cc5e283126117b557690127fa27722cc06cc5e261179368056bc75e2d63100000856125f1565b61179d9190612676565b92506117b26815af1d78b58c4000008261259c565b90505b68280e60114edb805d0383126118045768280e60114edb805d036117e268056bc75e2d63100000856125f1565b6117ec9190612676565b9250611801680ad78ebc5ac62000008261259c565b90505b680ebc5fb41746121110831261185357680ebc5fb4174612111061183168056bc75e2d63100000856125f1565b61183b9190612676565b925061185068056bc75e2d631000008261259c565b90505b6808f00f760a4b2db55d83126118a2576808f00f760a4b2db55d61188068056bc75e2d63100000856125f1565b61188a9190612676565b925061189f6802b5e3af16b18800008261259c565b90505b6806f5f177578893793783126118f1576806f5f17757889379376118cf68056bc75e2d63100000856125f1565b6118d99190612676565b92506118ee68015af1d78b58c400008261259c565b90505b6806248f33704b286603831261193f576806248f33704b28660361191e68056bc75e2d63100000856125f1565b6119289190612676565b925061193c67ad78ebc5ac6200008261259c565b90505b6805c548670b9510e7ac831261198d576805c548670b9510e7ac61196c68056bc75e2d63100000856125f1565b6119769190612676565b925061198a6756bc75e2d63100008261259c565b90505b60006119a268056bc75e2d631000008561259c565b68056bc75e2d631000006119b6818761255d565b6119c091906125f1565b6119ca9190612676565b9050600068056bc75e2d631000006119e283806125f1565b6119ec9190612676565b9050818068056bc75e2d63100000611a0484836125f1565b611a0e9190612676565b9150611a1b600383612676565b611a25908261259c565b905068056bc75e2d63100000611a3b84846125f1565b611a459190612676565b9150611a52600583612676565b611a5c908261259c565b905068056bc75e2d63100000611a7284846125f1565b611a7c9190612676565b9150611a89600783612676565b611a93908261259c565b905068056bc75e2d63100000611aa984846125f1565b611ab39190612676565b9150611ac0600983612676565b611aca908261259c565b905068056bc75e2d63100000611ae084846125f1565b611aea9190612676565b9150611af7600b83612676565b611b01908261259c565b9050611b0e6002826125f1565b90506064611b1c828761259c565b611b269190612676565b979650505050505050565b6000680238fd42c5cf03ffff198212158015611b56575068070c1cc73b00c800008213155b611b955760405162461bcd60e51b815260206004820152601060248201526f1253959053125117d1561413d391539560821b6044820152606401610a16565b6000821215611bcb57611baf611baa836126a4565b611b31565b611bc1670de0b6b3a7640000806125f1565b6104e49190612676565b60006806f05b59d3b20000008312611c1057611bf06806f05b59d3b20000008461255d565b925072195e54c5dd42177f53a27172fa9ec63026282760241b9050611c4d565b6803782dace9d90000008312611c4957611c336803782dace9d90000008461255d565b92506b1425982cf597cd205cef73809050611c4d565b5060015b611c586064846125f1565b925068056bc75e2d6310000068ad78ebc5ac620000008412611cb957611c8768ad78ebc5ac620000008561255d565b935068056bc75e2d63100000611cac6e01855144814a7ff805980ff0084000836125f1565b611cb69190612676565b90505b6856bc75e2d6310000008412611d0b57611cdc6856bc75e2d6310000008561255d565b935068056bc75e2d63100000611cfe6b02df0ab5a80a22c61ab5a700836125f1565b611d089190612676565b90505b682b5e3af16b188000008412611d5b57611d2e682b5e3af16b188000008561255d565b935068056bc75e2d63100000611d4e693f1fce3da636ea5cf850836125f1565b611d589190612676565b90505b6815af1d78b58c4000008412611dab57611d7e6815af1d78b58c4000008561255d565b935068056bc75e2d63100000611d9e690127fa27722cc06cc5e2836125f1565b611da89190612676565b90505b680ad78ebc5ac62000008412611dfa57611dce680ad78ebc5ac62000008561255d565b935068056bc75e2d63100000611ded68280e60114edb805d03836125f1565b611df79190612676565b90505b68056bc75e2d631000008412611e4957611e1d68056bc75e2d631000008561255d565b935068056bc75e2d63100000611e3c680ebc5fb41746121110836125f1565b611e469190612676565b90505b6802b5e3af16b18800008412611e9857611e6c6802b5e3af16b18800008561255d565b935068056bc75e2d63100000611e8b6808f00f760a4b2db55d836125f1565b611e959190612676565b90505b68015af1d78b58c400008412611ee757611ebb68015af1d78b58c400008561255d565b935068056bc75e2d63100000611eda6806f5f1775788937937836125f1565b611ee49190612676565b90505b68056bc75e2d6310000084611efc818361259c565b9150600268056bc75e2d63100000611f1488846125f1565b611f1e9190612676565b611f289190612676565b9050611f34818361259c565b9150600368056bc75e2d63100000611f4c88846125f1565b611f569190612676565b611f609190612676565b9050611f6c818361259c565b9150600468056bc75e2d63100000611f8488846125f1565b611f8e9190612676565b611f989190612676565b9050611fa4818361259c565b9150600568056bc75e2d63100000611fbc88846125f1565b611fc69190612676565b611fd09190612676565b9050611fdc818361259c565b9150600668056bc75e2d63100000611ff488846125f1565b611ffe9190612676565b6120089190612676565b9050612014818361259c565b9150600768056bc75e2d6310000061202c88846125f1565b6120369190612676565b6120409190612676565b905061204c818361259c565b9150600868056bc75e2d6310000061206488846125f1565b61206e9190612676565b6120789190612676565b9050612084818361259c565b9150600968056bc75e2d6310000061209c88846125f1565b6120a69190612676565b6120b09190612676565b90506120bc818361259c565b9150600a68056bc75e2d631000006120d488846125f1565b6120de9190612676565b6120e89190612676565b90506120f4818361259c565b9150600b68056bc75e2d6310000061210c88846125f1565b6121169190612676565b6121209190612676565b905061212c818361259c565b9150600c68056bc75e2d6310000061214488846125f1565b61214e9190612676565b6121589190612676565b9050612164818361259c565b915060648468056bc75e2d6310000061217d85876125f1565b6121879190612676565b61219191906125f1565b6112209190612676565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126121c257600080fd5b813560206001600160401b03808311156121de576121de61219b565b8260051b604051601f19603f830116810181811084821117156122035761220361219b565b60405293845285810183019383810192508785111561222157600080fd5b83870191505b84821015611b2657813583529183019190830190612227565b600080600080600060a0868803121561225857600080fd5b85356001600160401b038082111561226f57600080fd5b61227b89838a016121b1565b9650602088013591508082111561229157600080fd5b61229d89838a016121b1565b955060408801359150808211156122b357600080fd5b506122c0888289016121b1565b9598949750949560608101359550608001359392505050565b600081518084526020808501945080840160005b83811015612309578151875295820195908201906001016122ed565b509495945050505050565b828152604060208201526000610ddb60408301846122d9565b60008060006060848603121561234257600080fd5b83356001600160401b0381111561235857600080fd5b612364868287016121b1565b9660208601359650604090950135949350505050565b60208152600061101260208301846122d9565b600080604083850312156123a057600080fd5b82356001600160401b03808211156123b757600080fd5b6123c3868387016121b1565b935060208501359150808211156123d957600080fd5b506123e6858286016121b1565b9150509250929050565b600080600080600060a0868803121561240857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60008282101561246957612469612441565b500390565b6000821982111561248157612481612441565b500190565b600060001982141561249a5761249a612441565b5060010190565b6020808252600d908201526c2d22a927afa224ab24a9a4a7a760991b604082015260600190565b60008160001904831182151516156124e2576124e2612441565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261250c5761250c6124e7565b500490565b6020808252600c908201526b11125597d25395115493905360a21b604082015260600190565b6020808252600c908201526b4d554c5f4f564552464c4f5760a01b604082015260600190565b60008083128015600160ff1b85018412161561257b5761257b612441565b6001600160ff1b038401831381161561259657612596612441565b50500390565b600080821280156001600160ff1b03849003851316156125be576125be612441565b600160ff1b83900384128116156125d7576125d7612441565b50500190565b6000826125ec576125ec6124e7565b500790565b60006001600160ff1b038184138284138082168684048611161561261757612617612441565b600160ff1b600087128281168783058912161561263657612636612441565b6000871292508782058712848416161561265257612652612441565b8785058712818416161561266857612668612441565b505050929093029392505050565b600082612685576126856124e7565b600160ff1b82146000198414161561269f5761269f612441565b500590565b6000600160ff1b8214156126ba576126ba612441565b506000039056fea2646970667358221220bfd9b5d452de7abebcb4805dc43dbb8d7109723834cd5f938dc421dccbd56cb964736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_calcTokenInGivenExactBptOut(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Intermediate function to avoid stack-too-deep \""
      },
      "_calcTokenOutGivenExactBptIn(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Intermediate function to avoid stack-too-deep \""
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}